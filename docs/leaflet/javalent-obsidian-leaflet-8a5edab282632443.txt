Directory structure:
└── javalent-obsidian-leaflet/
    ├── README.md
    ├── CHANGELOG.md
    ├── esbuild.config.mjs
    ├── index.d.ts
    ├── index.ts
    ├── manifest.json
    ├── package.json
    ├── README_zh_CN.md
    ├── release-please-config.json
    ├── tsconfig.json
    ├── versions.json
    ├── webpack.config.js
    ├── .npmignore
    ├── .release-please-manifest.json
    ├── publish/
    │   ├── documentation-addition.md
    │   └── Folder-parameters.md
    ├── src/
    │   ├── main.ts
    │   ├── styles.css
    │   ├── worker.d.ts
    │   ├── assets/
    │   │   └── main.css
    │   ├── controls/
    │   │   ├── controls.ts
    │   │   ├── distance.ts
    │   │   ├── filter.ts
    │   │   ├── gpx.ts
    │   │   ├── index.ts
    │   │   ├── layers.ts
    │   │   ├── lock.ts
    │   │   ├── mapview.ts
    │   │   ├── reset.ts
    │   │   └── zoom.ts
    │   ├── draw/
    │   │   ├── actions.ts
    │   │   ├── base.ts
    │   │   ├── color.ts
    │   │   ├── controller.ts
    │   │   ├── controls.ts
    │   │   ├── geojson.ts
    │   │   ├── polygon.ts
    │   │   ├── polyline.ts
    │   │   ├── rectangle.ts
    │   │   ├── shape.ts
    │   │   ├── text.ts
    │   │   └── vertex.ts
    │   ├── initiative/
    │   │   └── initiative.ts
    │   ├── l10n/
    │   │   ├── README.md
    │   │   ├── locale.ts
    │   │   └── locales/
    │   │       ├── en.ts
    │   │       └── zh_CN.ts
    │   ├── layer/
    │   │   ├── geojson.ts
    │   │   ├── gpx.ts
    │   │   ├── index.ts
    │   │   ├── layer.ts
    │   │   ├── marker.ts
    │   │   └── overlay.ts
    │   ├── map/
    │   │   ├── divicon.ts
    │   │   ├── index.ts
    │   │   ├── popup.ts
    │   │   └── view.ts
    │   ├── modals/
    │   │   ├── command.ts
    │   │   ├── context.ts
    │   │   ├── geojson.ts
    │   │   ├── icon.ts
    │   │   ├── index.ts
    │   │   ├── mapview.ts
    │   │   ├── path.ts
    │   │   ├── settings.ts
    │   │   ├── suggester.ts
    │   │   └── tag.ts
    │   ├── settings/
    │   │   └── settings.ts
    │   ├── utils/
    │   │   ├── constants.ts
    │   │   ├── hotline.ts
    │   │   ├── icons.ts
    │   │   ├── index.ts
    │   │   ├── leaflet-import.ts
    │   │   ├── units.ts
    │   │   ├── utils.ts
    │   │   ├── watcher.ts
    │   │   └── fullscreen/
    │   │       ├── fullscreen.ts
    │   │       └── leaflet.fullscreen.css
    │   └── worker/
    │       ├── gpx.worker.ts
    │       ├── image.worker.ts
    │       └── loader.ts
    ├── types/
    │   ├── controls.d.ts
    │   ├── gpx.d.ts
    │   ├── index.d.ts
    │   ├── layers.d.ts
    │   ├── main.d.ts
    │   ├── map.d.ts
    │   ├── marker.d.ts
    │   ├── overlay.d.ts
    │   ├── saved.d.ts
    │   └── view.d.ts
    └── .github/
        └── workflows/
            └── release-please.yml

================================================
FILE: README.md
================================================
# Obsidian Leaflet
> **Development Status**: Maintenance Mode
> 
> Due to a glut of high priority Javalent plugin projects, this plugin is now entering maintenance mode for the time being. This is **not** a permanent status.
> - PR's will be reviewed.
> - *Yay* bugs will be reviewed and worked if able.
> - Feature Requests **will not** be worked.

---

Adds interactable mapping functionality to Obsidian.md, using [Leaflet.js](https://leafletjs.com/)

<img src="https://raw.githubusercontent.com/valentine195/obsidian-leaflet-plugin/master/images/7d595a3db9bf0eff9f2a2150819d2bd6956ddcd8.gif">

<img src="https://raw.githubusercontent.com/valentine195/obsidian-leaflet-plugin/master/images/275ff1f560bb6dec0d4fc02b267a7f63860f20c9_2_690x262.jpeg">

Proof of concept currently. May not work as expected. Currently only tested on Windows & Mac.


Read this in other languages: [简体中文](./README_zh_CN.md).

## Working with the plugin & example

A map can be created with a `leaflet` code block. For example:

````markdown
```leaflet
id: leaflet-map
image: [[Image.jpg]]
height: 500px
lat: 50
long: 50
minZoom: 1
maxZoom: 10
defaultZoom: 5
unit: meters
scale: 1
marker: default, 39.983334, -82.983330, [[Note]]
darkMode: true
```
````

## Options

> :pencil: Using Links
>
> Several parameters below are for providing links to the map, whether that be for images, marker files, etc.
>
> In all cases, either Obsidian's Wikilinks (`[[Link]]`) _or_ standard markdown links (`[Link](./path/to/file)`) may be provided.

| Option                                  | Description                                                                                                 | Default                                    |
|-----------------------------------------|-------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|
| [id](#map-ids)                          | Unique identifier (can be anything). **Required.**                                                          |                                            |
| [image](#image-maps)                    | Direct URL/file path to an image file to be used as the map layer.                                          | OpenStreetMap map                          |
| [tileServer](#real-world-maps)          | Add additional tile servers as different layers                                                             |                                            |
| [tileSubdomains](#tile-subdomains)      | Add Available subdomains for additional tile servers  concurrent requests. Spilt by ',', etc. 'a,b,c' | a,b,c                                      |
| [tileOverlay](#real-world-maps)         | Add additional tile servers an overlay over the base map.                                                   |                                            |
| [osmLayer](#real-world-maps)            | Turn off the OpenStreetMap layer (only usable if additional Tile Servers have been provided)                |                                            |
| [lat](#initial-coordinates)             | Default latitude to display when rendering.                                                                 | 50% (image) / 39.983334 (open street map)  |
| [long](#initial-coordinates)            | Default longitude to display when rendering.                                                                | 50% (image) / -82.983330 (open street map) |
| height                                  | Height of the map element. Can be provided in pixels or percentage of note height.                          | 500px                                      |
| width                                   | Width of the map element. Can be provided in pixels or percentage of note width.                            | 100%                                       |
| [minZoom](#initial-zoom-level)          | Minimum allowable zoom level of the map.                                                                    | 1                                          |
| [maxZoom](#initial-zoom-level)          | Maximum allowable zoom level of the map.                                                                    | 10                                         |
| [defaultZoom](#initial-zoom-level)      | Map will load zoomed to this level.                                                                         | 5                                          |
| [zoomDelta](#initial-zoom-level)        | Zoom level will change by this amount when zooming.                                                         | 1                                          |
| zoomFeatures                            | The map will automatically fit all [GeoJSON](#geojson) and [GPX](#gpx) features                             |                                            |
| [unit](#unit-and-scale)                 | Unit to display distances in                                                                                | meters                                     |
| [scale](#unit-and-scale)                | Scale factor for image map distance calculation.                                                            | 1                                          |
| [marker](#markers)                      | Create immutable markers on the map                                                                         |                                            |
| [commandMarker](#defined-in-code-block) | Create immutable markers that execute commands                                                              |                                            |
| [markerFile](#marker-file)              | Create immutable marker from a note's frontmatter                                                           |                                            |
| [markerFolder](#marker-folders)         | Create immutable markers from _all_ of the notes in the given Paths (relative or absolute to the Vault-Root). Limit Depth by appending one '/' per Folder-Level  |                                            |
| [markerTag\*](#marker-tags)             | Create immutable markers from _all_ of the notes with the given tags.                                       |                                            |
| [filterTag\*](#filter-tag)              | Filter what files are used to create markers. Only markers that match the tags will be used.                |                                            |
| [linksTo\*](#links)                     | Create immutable markers from _all_ of the notes linking **TO** a note                                      |                                            |
| [linksFrom\*](#links)                   | Create immutable markers from _all_ of the notes linking **FROM** a note                                    |                                            |
| [darkMode](#dark-mode)                  | Invert map colors                                                                                           | false                                      |
| [overlay](#overlays)                    | Add a circle overlay to the map                                                                             |                                            |
| [overlayTag](#overlay-tag)              | Define a YAML tag to search for in specified marker notes                                                   |                                            |
| [overlayColor](#overlay-color)          | Change default overlay color                                                                                | blue                                       |
| [bounds](#bounds)                       | Set image map bounds to specified coordinates instead of default                                            |                                            |
| [coordinates](#initial-coordinates)     | Read location data from a note and use it as initial coordinates                                            |                                            |
| [zoomTag](#initial-zoom-level)          | Read distance-to-zoom data from a note and use it as default initial zoom                                   |                                            |
| [geojson](#geojson)                     | Load multiple *.GeoJSON file-Paths in Json or YAML Syntax into this map. Relative Paths to the current doc start with `.` (dot). |                                            |
| [geojsonColor](#styles-and-color)       | Change the default color of the GeoJSON features.                                                           | #3388ff                                    |
| geojsonFolder                           | Search in multiple folders (Json or YAML Syntax) for `*.geojson` or `*.json` files to load into this map. Relative Paths start with `.` (Dot). Limit Subfolder Depth by appending one Slash per Folder-Level |      |
| [gpx](#gpx)                             | Load GPX files onto maps.                                                                                   |                                            |
| [gpxMarkers](#gpx-markers)              | Set default start, stop and waypoint markers                                                                |                                            |
| gpxColor                                | Control default GPX color                                                                                   | #3388ff                                    |
| gpxFolder                               | Parse a folder for `.gpx` files to load to the map.                                                         |                                            |
| [imageOverlay](#image-overlays)         | Add an image overlay to the map.                                                                            |                                            |
| [draw](#enable-draw-mode-by-default)    | Enable the draw controller on the map.                                                                      | true                                       |
| drawColor                               | Default color that new shapes will be drawn with                                                            | #3388ff                                    |
| showAllMarkers                          | Map will open showing all markers.                                                                          | false                                      |
| preserveAspect                          | If the note pane the map is in is resized, the map will resize itself to maintain its initial aspect ratio. | false                                      |
| noUI                                    | No controls will be added to the map.                                                                       | false                                      |
| lock                                    | Control whether the map will start locked or unlocked                                                       | false                                      |
| recenter                                | Forces map to stay re-center itself after panning.                                                          | false                                      |
| noScrollZoom                            | Turns off scrollwheel zooming.                                                                              | false                                      |

> \*: Requires the [DataView plugin](https://github.com/blacksmithgu/obsidian-dataview).

### YAML syntax

As of version **3.11.0**, all parameters may be defined using YAML syntax instead of using multiple of the same tag. The original syntax will still work, but the two cannot be combined.

For example:

````
```leaflet
image:
    - [[Image 1]]
    - [[Image 2]]
    - [[Image 3]]
marker:
    - [<type>, <lat>, <long>, <link>]
    - [<type>, <lat>, <long>, <link>]
```
````

#### Marker Tags in YAML

YAML considers the `#` symbol to be a comment, so the `markerTag` or `filterTag` parameters must either be wrapped in quotes (`"#tag"`) or defined without the `#` symbol.

#### Links

I

## Map IDs

As of **3.0.0**, map ids are required. If a note with a old map block is opened, the plugin will warn you that the map now requires an ID.

Once an old map is given an ID, the plugin will try to associate the marker data with the new map.

The first time you open the plugin after updating to 3.0.0, a backup of your marker data will be created in case you need to downgrade. If you run into issues, please create an issue on Github.

## Initial Map View

### Initial Coordinates

The map will open to the latitude and longitude defined using `lat` and `long`. If not provided, it will default to the latitude and longitude defined in settings.

Alternatively, the latitude and longitude may be defined using the `coordinates` parameter. Coordinates may be defined as an array of numbers, or as a wikilink to a note that has a `location` frontmatter tag:

```
coordinates: [36, -89]
coordinates: [[Note with Location Frontmatter]]
```

### Initial Zoom Level

> :warning: Using an Image Map?
>
> Zoom levels and image maps may be a little unintuitive.
>
> Check out [Zooming with Image Maps](#zooming-with-image-maps) below.

The initial zoom level of the map may be set using the `defaultZoom` parameter. This must be a number between the `minZoom` and `maxZoom` parameters - if outside of them, it will be set to the nearest parameter.

Alternatively, if a `coordinates` note has been defined, the initial zoom level may be read from that note's frontmatter as `<distance> <unit>`.

For example, if a note has the following frontmatter:

```
### Note With Frontmatter.md
---
location: [-36, 89]
nearby: 100 mi
---
```

and the map was defined like this:

```leaflet
coordinates: [[Note With Frontmatter]]
zoomTag: nearby
```

Then the map will read the `nearby` tag, recognize it is `100 miles`, and set the map's initial zoom to the closest level that will display 100 miles (this depends on `minZoom`, `maxZoom`, and `zoomDelta`).

## Real World Maps

Real world maps are created if the `image` parameter is not provided. These maps by default will load the `OpenStreetMap` map, but additional tile servers can be provided using the `tileServer` parameter.

**It is up to you to ensure that the tile servers you use are publically usable.**

At this time, tile servers requiring API access are not usable.

If additional tile servers are provided, the `OpenStreetMap` layer can be turned off using the `osmLayer: false` parameter.

### Tile Servers

As mentioned above, additional tile servers can be added using the `tileServer` and `tileOverlay` parameter. Both have the same syntax:

`tileServer: <domain>|<alias (optional)>`

For example:

```md
tileServer: https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png|Dark

---

tileServer:

-   https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png|Dark
-   https://tiles.wmflabs.org/hillshading/{z}/{x}/{y}.png|Hills
```

Tile servers specified in `tileServer` will be added as additional **layers** that can be fully switched to.

### Tile Overlays

Tile servers specified as `tileOverlay` instead as `tileServer` will be added as overlays that will load on top of the base map.

Tile overlays can be set to default on by appending `|on` to the end:

```md
tileServer: https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png|Dark|on
```

### Tile Subdomains

Add Available subdomains for additional tile servers  concurrent requests. Spilt by ',', etc. 'a,b,c'.

`tileSubdomains: <domain1>,<domain2>,<domain3>`

For example:
----
```leaflet
osmLayer: false
tileServer: https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}
tileSubdomains: 1,2,3
```
---

So that map will load map data from below urls:
https://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}
https://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}
https://webrd03.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}


## Image Maps

> **:warning: Making an Image Map?**
>
> For images maps, it is **highly** recommended that you set your [bounds](#bounds) first.
>
> This will make working with your images much easier!
>
> Read the [discussion](https://github.com/valentine195/obsidian-leaflet-plugin/discussions/130) about the process. Josh Plunkett has also made a great video breaking down the process [here](https://www.youtube.com/watch?v=54EyMzJP5DU).

### Image Map URL / file path

Image maps can be loaded one of three ways:

1. Direct URL (e.g., https://i.imgur.com/jH8j3mJ.jpg)
2. Obsidian URL (e.g., obsidian://open?vault=VaultName&file=Path/To/Image.jpg)
3. Obsidian wikilink of image (e.g., [[Image.jpg]])

### Zooming with Image Maps

You may notice that basic image maps and zooming do not necessarily behave the way you think they would. For instance, you may find that setting a higher max zoom value just makes the map _start farther away_, instead of actually allowing you to zoom in more.

This is because of the way image maps are essentially a hack on top of the LeafletJS module. There is still an underlying map that still has its latitude and longitude, it just can't be seen. The image is then drawn on top of that map (centered at [0, 0]) and then stretched to fit. If you change parameters (such as the zoom levels), the underlying map is changed... but the image is **still placed at [0, 0] and stretched to fit!**

Instead, the [image bounds](#bounds) need to be set for your map. This tells Leaflet _exactly_ what coordinates your image should be placed at on the underlaying map layer. No matter how the map instance changes, the image will be in the same spot and the same size, **every time!**

### Multi-Image Maps

Images can be layered on top of each other by providing multiple images to the plugin:

````markdown
```leaflet
id: Map With Layered Images
image:
    - [[Image1.jpg|Optional Alias]]
    - [[Image2.jpg]]
    - [[Image3.jpg]]
```
````

This will generate a map with 3 layers. Image 1 will be on top, Image 2 in the middle, and Image 3 on bottom. The images will be aligned around their center points.

The control box in the top right of the map will allow you to change layers.

Markers can be created and saved on each layer separately from one another.

If given an alias, the layer control box will display the given name instead of the file name.

### Bounds

Custom bounds may be given to an image map using the `bounds` parameter:

````
```leaflet
image: [[Image.jpg]]
bounds:
    - [<top-left-latitude>, <top-left-longitude>]
    - [<bottom-right-latitude>, <bottom-right-longitude>]
```
````

This will cause the latitude and longitude of the image map to be updated to fit within the bounds. _This will skew the image if the provided bounds do not match the aspect ratio of the image._

Any markers or overlays defined on the map will not be updated.

### Latitude and Longtitude of Image Maps

Because an image map does not have a true coordinate system, the latitude and longitude provided must be given as a percentage from the **top left corner of the image**.

This setting may seem to not do anything without changing the default zoom level of the map.

### Unit and Scale

If provided, the plugin will scale the calculated distance between two points by `scale` and display the result as `xxx unit`.

On real-world maps, only `unit: ` is required. It will attempt to scale the measurement from `meters` to `unit`.

## Markers

New markers can be added to the map by right clicking.

If any additional marker types have been created in plugin settings or a `markers.json` file in the same directory, a list will appear to choose from.

Once a marker has been created, it can be dragged to a different location.

Markers created on the map will be saved to the map instance. Marker data saved this way will persist as long as the map is associated with a note - if the map blocks are removed from notes, or if all of the notes containing map blocks are removed, **the data associated with it will be deleted after 7 days.**

### Marker Zoom Level Breakpoints

Markers given zoom level breakpoints will be removed from the map when the map is zoomed above or below the breakpoints.

These breakpoints can be set in right-click menu of markers created on the map as well as using parameters for markers created in the source block (see [Objects Defined in the Code Block](#objects-defined-in-the-code-block) for more information).

Be careful! Make sure the breakpoints are within the map's zoom boundaries, otherwise the marker might never be displayed!

### Marker Coordinates

<kbd>Alt</kbd> or <kbd>Shift</kbd>-clicking on a marker will reveal its coordinates.

### Marker Links

A marker can also point to a note; right-click on it, and a popup will appear. The target can be entered as the name of the note. Additionally, headers or blocks within a note can be the target of a marker:

`Note`

`Note#Header1`

If you have multiple notes with the same name, you should specify the direct path to the note. Otherwise, the map may not open the one you expect.

Once linked, a click will open the note (<kbd>Ctrl</kbd>/<kbd>Cmd</kbd>-click to open in new window).

Additionally, markers can be created by dragging a note from the file tree and dropping it on the map.

Marker links can also be set to external websites. Clicking the marker will open the website.

#### Obsidian Commands as Links

Markers links can also be set to a defined Obsidian command from the command palette one of two ways.

The command must be the full name of the command as it appears in the palette.

**Setting a marker link to a command will execute the command when the marker is clicked.**

> ##### **Warning**
>
> Using a command as a marker target could have unintended consequences.
>
> Please see [this issue](https://github.com/valentine195/obsidian-leaflet-plugin/issues/38) for reference.

##### Defined in Code Block

Use `commandMarker:` instead of `marker:`

##### Created on Map

Turning on the `Command Marker` toggle.

### Bulk Editing

As of version 3.9.0, a bulk-edit button has been added to the map. Clicking this button will open a modal allowing for easy editing of all the mutable markers defined on the map.

## Overlays

Overlays may be added to the map by <kbd>Shift</kbd>-right clicking, dragging the mouse to set the radius, and clicking again. Hitting <kbd>Escape</kbd> will cancel the drawing and remove the overlay. Overlays added to the map in this manner are saved to the map instance just like the markers, and will be recreated when the map is re-opened.

Additionally, overlays may be specified in the source block using the `overlay` parameter, as so:

`overlay: [<color>, [<lat>, <long>], <radius> <unit?>, <desc>]`

OR

```
overlay:
    - [<color>, [<lat>, <long>], <radius> <unit?>, <desc>]
    - [<color>, [<lat>, <long>], <radius> <unit?>, <desc>]
    ...
```

This will create a `<color>`-overlay circle centered at `<lat>, <long>`, with a radius `<radius>` in `<unit>`.

> **Please Note**
>
> Overlays are drawn _in the order they are specified_. If a smaller overlay is obscured by a larger one, the smaller one will not be interactable.

The `<color>` may be _any_ valid CSS color, including hexadecimals, `rgb()` and `hsl()`.

Please note that due to the YAML syntax, strings starting with `#` and entries with commas must be enclosed in quotes.

Examples:

````
```leaflet
overlay: [blue, [32, -89], 25 mi, 'This is my overlay!']
```
````

````
```leaflet
overlay:
  - ['rgb(255, 255, 0)', [32, -89], 25 km, 'This is also my overlay!']
  - ['#00FF00', [32, -89], 500 ft, 'This is a third overlay!']
```
````

### Editing the Overlay

Overlays drawn directly on the map may be edited. The radius and color may be changed, or the overlay removed, by right-clicking on the overlay.

### Overlays using Note frontmatter

Similarly to markers, overlays may be created from notes found using the `markerFile`, `markerFolder`, and `markerTag` parameters. The `filterTag` parameter may be used to filter what files are used based on their tags.

The plugin will scan the frontmatter of the notes and generate an overlay from a frontmatter `mapoverlay` parameter, defined using the same syntax as above.

### Overlay Tag

The overlay tag parameter can be used to auto-generate an overlay from a tag in a note's frontmatter.

Example:

````
```leaflet
overlayTag: nearby
```
````

Note frontmatter:

```
nearby: 50 km
```

### Overlay Color

The overlay color tag may be used to specify the default overlay color when drawing on the map or when using the overlay tag parameter.

## Image Overlays

Image overlays can be added to the map using the `imageOverlay` parameter in the code block.

This parameter uses the following syntax:

````
```leaflet
imageOverlay:
 - [ [[ImageFile|Optional Alias]], [Top Left Coordinates], [Bottom Right Coordinates] ]
 - [ [[ImageFile2|Optional Alias]], [Top Left Coordinates], [Bottom Right Coordinates] ]
 - ...
```
````

This will add an image overlay positioned between the two coordinate bounds. If the coordinate bounds are not provided, the overlay will:

1. On Image maps, overlay the entire image.
2. On Real maps, overlay the initial map view.

Image overlays can be toggled on or off using the layer control box in the top-right. Similarly to maps with multiple layers, if the optional alias is provided, the layer box will display the alias instead of the file name.

## GeoJSON

GeoJSON is a format used to describe geographic data structures, such as points, lines, and shapes. Please see [this](https://datatracker.ietf.org/doc/html/rfc7946) for a full reference of the GeoJSON format.

GeoJSON can be loaded into the map using the following syntax:

````
```leaflet
geojson: [[GeoJSON_File.json]]|optional-alias
```
````

or

````
```leaflet
geojson:
  - [[GeoJSON_File.json]]
  - [[GeoJSON_File_2.json]]|optional-alias|[[optional-note-wikilink]]
```
````

_Please note that GeoJSON is drawn in the order it is provided. If a smaller file overlaps a larger file, you may not be able to interact with it._

Especially large or a large number of GeoJSON files could slow down initial rendering.

### Linking to Notes

A GeoJSON file can link to a note by appending `|[[]]` to the end.

**Please note that the alias is required when linking to a note.**

### Styles and Color

The default color for GeoJSON features can be defined in the map's code block using the `geojsonColor` parameter. This color must be a valid CSS color.

Additionally, the map will attempt to read the style properties defined for the GeoJSON features to apply styles. Styles should be defined using the [MapBox SimpleStyle specification](https://github.com/mapbox/simplestyle-spec/tree/master/1.1.0).

### Tooltip

The map will attempt to read the title of the GeoJSON feature to display the tooltip when hovered. This title should be defined in the `title`, `description` or `name` field of the GeoJSON feature properties.

## GPX

GPX, or GPS eXchange, files can be added to the map using the `gpx` parameter similarly to how GeoJSON files are added to maps.

> Want to show your Apple Health workouts in Obsidian? Follow [these](https://support.apple.com/guide/iphone/share-health-and-fitness-data-iph27f6325b2/ios) steps, then add the exported GPX files to your vault and use them in a map!

````
```leaflet
gpx: [[GPX_File.gpx]]
```
````

or

````
```leaflet
gpx:
  - [[GPX_File.gpx]]
  - [[GPX_File 2.gpx]]
```
````

Especially large or a large number of GPX files could slow down rendering.

### GPX Markers

By default, the map will not show markers on the starting point, ending point or the defined waypoints. The map can be told to use marker types you have defined in settings using the `gpxMarkers` parameter:

````
```leaflet
gpx: [[GPX_File.gpx]]
gpxMarkers:
  start: start_marker_type
  waypoint: waypoint_marker_type
```
````

### GPX Data

GPX files are parsed for datapoints which can be displayed on the map as heatlines. Clicking on a GPX route will open a control box where these datapoints can be selected. Hovering over a point on the track will display information for that specific point.

Currently, the data parsed out of a GPX file is:

1. Cadence
2. Elevation
3. Heartrate
4. Speed

If any of these are missing from the file, it will not be an option.

## Objects Defined in the Code Block

Markers and overlays may be defined directly in the code block using the following syntax:

| Type    | Syntax                                                                                |
| ------- | ------------------------------------------------------------------------------------- |
| Marker  | `marker: <type*>,<latitude>,<longitude>,<link*>,<description*>,<minZoom*>,<maxZoom*>` |
| Overlay | `overlay: [<color*>, [<latitude, longitude>], <radius*>, <description*>]`             |

An arbitrary number of objects can be defined, but _none of these objects will be editable._ If a change needs to be made to these objects, the code block must be edited.

The marker link may be defined as an Obsidian wikilink.

> \*: These parameters are optional and can be left blank in the definition.
> For example, `marker: ,25,25,,,3` will use the default marker type, latitude and longitude 25, no link, no description, minZoom 3, no maxZoom.

**These will not be included in exported data.**

### Marker Files, Marker Folders, Marker Tags, and Markers from Links

These parameters allow you to create markers directly from the specified note files.

There is no limit to how many of these parameters you can have defined in the code block; all of the files found will be parsed for defined markers.

_Please note that until I implement some form of caching, having a large amount of marker files defined could impact performance._

#### Note Frontmatter

The `markerFile`, `markerFolder`, `markerTag`, `filterTag`, `linksTo`, and `linksFrom` parameters tell the plugin _where to look for notes_. The notes themselves determine how the markers are created, using note frontmatter tags.

All markers created from the note will automatically have their link set to the note.

| Frontmatter Tag | Use                                                                                             |
| --------------- | ----------------------------------------------------------------------------------------------- |
| location        | Create a marker at this location. Also used if the `coordinates` parameter points to this note. |
| mapmarker       | Use this marker type for the marker created using `location`. Optional.                         |
| mapzoom         | Marker created from this note will have its zoom breakpoint set to `[min, max]`. Optional.      |
| mapmarkers      | Array of markers to create. See below for syntax.                                               |
| mapoverlay      | Array of overlays to create. See below for syntax.                                              |

##### mapmarker

The `mapmarker` parameter can be used to define the _type_ of marker created. This can be one of two things:

1. The name given to the marker type in settings.
2. A definition defining the icon name, color, and whether or not to layer the icon on the default marker type.

Examples:

```
mapmarker: event    # A marker type named event has been created in settings.

# OR

mapmarker:
  icon: user        # Font Awesome icon name.
  color: 00ff00     # Hex color string. Optional.
  layer: false      # Whether or not to layer. Optional.
```

##### mapmarkers

The `mapmarkers` parameter can be used to define an arbitrary number of markers to display on the map. This does not require the `location` tag to be set.

A marker defined using `mapmarkers` should have the following syntax:

```
---
mapmarkers:
  - [<type>, [<latitude>, <longitude>], <optional description>, <optional minZoom>, <optional maxZoom>]
  - [<type>, [<latitude>, <longitude>], <optional description>, <optional minZoom>, <optional maxZoom>]
  - ...
---
```

##### mapoverlays

The `mapoverlay` parameter can be used to define an arbitrary number of overlays to display on the map. This does not require the `location` tag to be set.

A marker defined using `mapoverlay` should have the following syntax:

```
---
mapoverlay:
  - [<color>, [<latitude>, <longitude>], <radius> <unit?>, <optional description>]
  - [<color>, [<latitude>, <longitude>], <radius> <unit?>, <optional description>]
  - ...
---
```

As shown above, the radius of the overlay should be specified using `<radius> <unit>` (such as `100 miles`). If the `<unit>` is not provided, it will default to `meters`. Please see [this](src/utils/units.ts) for a list of supported units.

#### Marker File

Marker files may be defined in the code block using the following syntax:

`markerFile: [[WikiLinkToFile]]` **OR**
`markerFile: Direct/Path/To/Note`

#### Marker Folders

Marker folders may be defined in the code block using the following syntax:

`markerFolder: Direct/Path/To/Folder`

This will by default include notes from all subfolders. 

To limit the number of subfolders, append one '/' (Slash) to the path for each sub-folder-level to include.

#### Marker Tags

If you have the [Dataview plugin](https://github.com/blacksmithgu/obsidian-dataview) installed, markers may also be created from tags using the following syntax:

`markerTag: <tag>, <tag>, ...`

**Please note: The plugin uses YAML to parse the code block, so tags defined with `#` \*will not work\* unless wrapped in quotes (`"#tag"`).**

Each `markerTag` parameter will return notes that have _all_ of the tags defined in that paramter. If you are looking for files containing _any_ tag listed, use separate `markerTag` parameters.

Example:

```
markerTag:
  - tag1
  - [tag2, tag3]
  - tag4
```

The above will parse:

1. Any note containing `tag1`.
2. Any notes containing _both_ `tag2` **and** `tag3`.
3. Any note containing `tag4`.

> Note: notes are only parsed once, even if a note matches multiple criteria.

#### Filter Tag

Returned files can be filtered using the `filterTag` parameter. This parameter uses the same syntax as `markerTag`, but instead of _adding_ files, it will require that each file found using `markerFile`, `markerFolder` or `markerTag` match a set of tags.

#### Links

The `linksTo` and `linksFrom` parameters uses DataView's link index to find notes linked to or from the notes specified in the parameter to build immutable markers, using the same syntax as above.

> Please note: Both `links` parameters require the [Dataview plugin](https://github.com/blacksmithgu/obsidian-dataview) to be installed.

Multiple files can be specified using YAML array syntax:

```
linksTo: [[File]]
linksFrom:
    - [[File 1]]
    - [[File 2]]
```

#### Examples

```
markerFile: [[MarkerFile]]
```

would

1. Load the MarkerFile.md note file and, if it has the correct frontmatter fields, create a marker for it.

```
markerFile: [[MarkerFile]]
markerFolder: People and Locations
```

would

1. Load the MarkerFile.md note
2. Look through the People and Locations folder for additional notes

```
markerTag: #location, #friends
```

would

1. Find _all_ notes tagged with both `#location` **and** `#friends` and create markers using their frontmatter

```
markerFolder: People and Locations
markerFolder: Interests/Maps of the World
markerTag: #people, #friends
markerTag: #Paris
```

would search for notes that

1. Are in the folders People and Locations OR Interests/Maps of the World, AND
2. Contain both tags #people AND #friends OR the tag #Paris

## Distances

<kbd>Shift</kbd> or <kbd>Alt</kbd>-clicking the map or a marker, then <kbd>Shift</kbd> or <kbd>Alt</kbd>-clicking again, will display the distance between the two points.

Distances are displayed in meters, unless a scale factor and/or unit is specified in the map block.

A control box in the bottom-left corner of the map displays the last-calculated distance. Hovering on this will display the distance line on the map, and clicking on it will zoom the map to those coordinates.

## Dark Mode

The `darkMode` parameter will invert the colors of the map using CSS. This is done by applying a `.dark-mode` CSS class to the map tile layer, and the following CSS:

```css
.leaflet-container .dark-mode {
    filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(
            0.3
        ) brightness(0.7);
}
```

Overriding this CSS in a custom snippet will allow for customization of the dark mode appearance. For a reference to the CSS `filter` property, please see [this article](https://developer.mozilla.org/en-US/docs/Web/CSS/filter).

## Settings

### Marker CSV Files

Marker data may be exportable to a CSV file. This data takes the following format:

| Column 1 | Column 2    | Column 3 | Column 4  | Column 5    | Column 6     | Column 7  |
| -------- | ----------- | -------- | --------- | ----------- | ------------ | --------- |
| Map ID   | Marker Type | Latitude | Longitude | Marker Link | Marker Layer | Marker ID |

If left blank, Marker Type will default to "default".

Marker layer may be kept blank if a map only has 1 layer.

For new markers, Marker ID may be kept blank.

Marker data in this format can then be re-imported. This feature is still under development and may not work as expected.

### Default Marker Tooltip Behavior

Setting this will cause marker tooltips to default to this behavior.

You can override this behavior in the right-click context menu of a marker.

### Enable Draw Mode by Default

If disabled, the draw controller will not be added to the map unless the `draw` parameter is set to true in the map block.

### Display Note Preview

Use Obsidian's note preview when hovering a linked marker.

**Please note, the Obsidian Page preview core plugin must be enabled to use this feature.**

### Display Overlay Tooltip

If disabled, overlay tooltips will not be displayed by default. This can be changed on a per-overlay basis inside the overlay context menu.

It is not currently possible to change this setting on immutable overlay.

### Copy Coordinates on Shift-Click

Turning this setting on will copy the latitude and longitude coordinates to the clipboard when <kbd>Ctrl</kbd> + <kbd>Shift</kbd>-clicking anywhere on the map.

### Latitude and Longitude

A real-world map will open to this default latitude and longitude if not provided.

### Default Map Marker

The default marker setting allows you to define a marker that other markers can be layered on top of. If no additional markers have been added, right clicking on the map will place this marker.

#### Marker Icon

The [Font Awesome Free](https://fontawesome.com/icons?d=gallery&p=2&s=solid&m=free) icon name to use.

#### Marker Color

Color selector for the marker color.

#### Layer Base Marker

Additional markers will be layered on top of this marker by default. This setting can be overridden on specific additional markers.

### Additional Markers

Additional marker types can be added, selectable from a context menu on the map.

#### Creating an additional marker

Adding a new marker displays a new window, where the new marker parameters can be added.

| Parameter       | Description                                                                                          |
| --------------- | ---------------------------------------------------------------------------------------------------- |
| Marker Name     | Displayed in the context menu when adding a marker (e.g., Location, Event, Person)                   |
| Marker Icon     | The [Font Awesome Free](https://fontawesome.com/icons?d=gallery&p=2&s=solid&m=free) icon name to use |
| Upload Image    | Upload a custom image to use for the marker icon instead of using a Font Awesome icon                |
| Layer Icon      | Layer this icon on top of the base marker. If off, the icon itself will be used.                     |
| Icon Color      | Override the default icon color                                                                      |
| Associated Tags | Immutable markers will use this marker type if the file has this tag _and `mapmarker` is not set_.   |

If layer icon is on, the icon be moved around the base icon by clicking and dragging, to customize where the icon is layered. If <kbd>Shift</kbd> is held while moving the icon, it will snap to the midlines.

#### Creating local marker types

New markers can also be defined in a `markers.json` file. These marker types will be available to any notes in the same directory as the json file. The json file should contain an array of Icon objects, See the [Icon interface](https://github.com/javalent/obsidian-leaflet/blob/1fa4c237deceff1def883872fdad3822f9bff560/types/saved.d.ts#L7) for details.

#### Using an Image as a Marker Icon

When creating an additional marker, an image may be uploaded to use as the marker icon instead of selecting a Font Awesome icon.

Click the "Upload Image" button and select the image to use. The plugin will load the image and scale it to `24px x 24px`. The image used for the marker cannot be edited once it has been uploaded.

If an image has been uploaded, selecting a Font Awesome icon will remove the image.

#### Associated Tags

Associate a tag with a marker type.

If a note is found using `markerFile`, `markerFolder`, or `markerTag`, the plugin will first use the frontmatter `mapmarker` parameter to determine marker type. If that is not set, it will then use the note's tags to find a marker type associated with one of the tags.

The tags are searched in order of definition on the marker type.

# Initiative Tracker Plugin Integration

If the [Initiative Tracker](https://github.com/valentine195/obsidian-initiative-tracker) plugin is installed, a battlemap can be opened from the Initiative Tracker view.

This battlemap will pre-load any active creatures in the loaded combat as markers. Default marker types can be set for both PCs and NPCs, and you can further set which marker type each individual creature will use.

The battlemap will sync its state to the Initiative Tracker combat - as creatures are added, removed, etc, their state will update on the map.

# Version History

See [the changelog](https://github.com/valentine195/obsidian-leaflet-plugin/blob/master/CHANGELOG.md).

# Installation

## From within Obsidian

From Obsidian v0.9.8, you can activate this plugin within Obsidian by doing the following:

-   Open Settings > Third-party plugin
-   Make sure Safe mode is **off**
-   Click Browse community plugins
-   Search for this plugin
-   Click Install
-   Once installed, close the community plugins window and activate the newly installed plugin

## From GitHub

-   Download the Latest Release from the Releases section of the GitHub Repository
-   Extract the plugin folder from the zip to your vault's plugins folder: `<vault>/.obsidian/plugins/`
    Note: On some machines the `.obsidian` folder may be hidden. On MacOS you should be able to press `Command+Shift+Dot` to show the folder in Finder.
-   Reload Obsidian
-   If prompted about Safe Mode, you can disable safe mode and enable the plugin.
    Otherwise head to Settings, third-party plugins, make sure safe mode is off and
    enable the plugin from there.

### Updates

You can follow the same procedure to update the plugin

# Warning

This plugin comes with no guarantee of stability and bugs may delete data.
Please ensure you have automated backups.

# TTRPG plugins

If you're using Obsidian to run/plan a TTRPG, you may find my other plugin useful:

-   [5e Statblocks](https://github.com/valentine195/obsidian-5e-statblocks/) - Create 5e-styled statblocks inside notes
-   [Dice Roller](https://github.com/valentine195/obsidian-dice-roller) - Roll & re-roll dice in notes
-   [Initiative Tracker](https://github.com/valentine195/obsidian-initiative-tracker) - Initiative Tracker view in Obsidian

<a href="https://www.buymeacoffee.com/valentine195"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=☕&slug=valentine195&button_colour=e3e7ef&font_colour=262626&font_family=Inter&outline_colour=262626&coffee_colour=ff0000"></a>



================================================
FILE: CHANGELOG.md
================================================
# Changelog

All notable changes to this project will be documented in this file. See [standard-version](https://github.com/conventional-changelog/standard-version) for commit guidelines.

## [6.0.5](https://github.com/javalent/obsidian-leaflet/compare/6.0.4...6.0.5) (2024-03-31)


### Bug Fixes

* Inspect document body for theme instead of vault config (close [#440](https://github.com/javalent/obsidian-leaflet/issues/440)) ([fa1a3f4](https://github.com/javalent/obsidian-leaflet/commit/fa1a3f42ebee556ca1427ec637f1522a09bba0e2))

## [6.0.4](https://github.com/javalent/obsidian-leaflet/compare/6.0.3...6.0.4) (2024-03-27)


### Bug Fixes

* Fixes another instance where image markers might not resize properly ([f75836a](https://github.com/javalent/obsidian-leaflet/commit/f75836ac66185c7e2794009b51911a9e831caf46))

## [6.0.3](https://github.com/javalent/obsidian-leaflet/compare/6.0.2...6.0.3) (2024-03-27)


### Bug Fixes

* Fixes some instances where custom marker images were not resized ([505e3b2](https://github.com/javalent/obsidian-leaflet/commit/505e3b2f3b0334025cd796896ce0e98aa9902979))

## [6.0.2](https://github.com/javalent/obsidian-leaflet/compare/6.0.1...6.0.2) (2024-01-26)


### Bug Fixes

* Update plugin name per Obsidian developer guidelines ([56bdbfc](https://github.com/javalent/obsidian-leaflet/commit/56bdbfcc02010aec809c2f70ee5ee56a072e2491))

## [6.0.1](https://github.com/javalent/obsidian-leaflet/compare/6.0.0...6.0.1) (2023-12-01)


### Bug Fixes

* Marker tooltips should hide when a layer is changed ([19d5765](https://github.com/javalent/obsidian-leaflet/commit/19d5765073cbfd022f178b64c4a995c69b0a3272))

## [6.0.0](https://github.com/javalent/obsidian-leaflet/compare/5.8.0...6.0.0) (2023-10-31)


### ⚠ BREAKING CHANGES

* Switched map tile provider (close #424)

### Features

* Switched map tile provider (close [#424](https://github.com/javalent/obsidian-leaflet/issues/424)) ([c80da47](https://github.com/javalent/obsidian-leaflet/commit/c80da47a82c0486072a3d3ecce6078856394ae43))

## [5.8.0](https://github.com/javalent/obsidian-leaflet/compare/5.7.3...5.8.0) (2023-10-08)


### Features

* can now specify layer for code block markers ([ebcec59](https://github.com/javalent/obsidian-leaflet/commit/ebcec59d4b57e259c91d21f254ad1866406cc26c))

## [5.7.3](https://github.com/javalent/obsidian-leaflet/compare/5.7.2...5.7.3) (2023-08-29)


### Bug Fixes

* invalidate map size to prevent incorrect starting positions in some situations ([a9ac194](https://github.com/javalent/obsidian-leaflet/commit/a9ac1949d7aad283050afab339253d0e141f7fba))

## [5.7.2](https://github.com/javalent/obsidian-leaflet/compare/5.7.1...5.7.2) (2023-07-23)


### Bug Fixes

* Displays GPX tracks on load ([fe79ca0](https://github.com/javalent/obsidian-leaflet/commit/fe79ca0060aec2f3fdc0d0391885c9f876cfc2ea))

## [5.7.1](https://github.com/javalent/obsidian-leaflet/compare/5.7.0...5.7.1) (2023-07-03)


### Bug Fixes

* fixes issue preventing map view from opening ([3b2ecee](https://github.com/javalent/obsidian-leaflet/commit/3b2ecee45454f65f0107b23d5878c7a48babc425))

## [5.7.0](https://github.com/javalent/obsidian-leaflet/compare/5.6.1...5.7.0) (2023-06-29)


### Features

* Define custom marker types in json files ([#400](https://github.com/javalent/obsidian-leaflet/issues/400)) ([b9305f5](https://github.com/javalent/obsidian-leaflet/commit/b9305f50529e862df1359a46641bf8b0280c5b49))


### Bug Fixes

* restore removal of custom marker types ([#401](https://github.com/javalent/obsidian-leaflet/issues/401)) ([73e1f4b](https://github.com/javalent/obsidian-leaflet/commit/73e1f4b46f796d679ed7a5efcf06c3916ba7f879))

## [5.6.1](https://github.com/javalent/obsidian-leaflet/compare/5.6.0...5.6.1) (2023-05-07)


### Bug Fixes

* revert to webpack build to avoid collision with Map View (close [#384](https://github.com/javalent/obsidian-leaflet/issues/384)) ([8154392](https://github.com/javalent/obsidian-leaflet/commit/81543929c65b5c099fe9198784223cb6cdc426fa))

## [5.6.0](https://github.com/javalent/obsidian-leaflet/compare/5.5.8...5.6.0) (2023-05-04)


### Features

* Enable marker opacity (close [#334](https://github.com/javalent/obsidian-leaflet/issues/334)) ([59f26dc](https://github.com/javalent/obsidian-leaflet/commit/59f26dc7c6ab236fae50a942239f60589b8a50b7))


### Bug Fixes

* clean up settings ([#381](https://github.com/javalent/obsidian-leaflet/issues/381)) ([4df1590](https://github.com/javalent/obsidian-leaflet/commit/4df15901d65916101ecb7aa2e96d2e825d8657f9))
* default to infinite recursion for geojson (close [#366](https://github.com/javalent/obsidian-leaflet/issues/366)) ([ad2b37a](https://github.com/javalent/obsidian-leaflet/commit/ad2b37a49af93531aaccd7ef99c6dbe0dcc2a95a))
* display geojson causing error in notice ([174b80d](https://github.com/javalent/obsidian-leaflet/commit/174b80d6311e257fd1e468ebc5223f0c9672b3ac))
* fixes longitude i10n message ([97adff3](https://github.com/javalent/obsidian-leaflet/commit/97adff3007a4e75ae0efa67923d61ab05eae94cd))

## [5.5.8](https://github.com/javalent/obsidian-leaflet/compare/5.5.7...5.5.8) (2023-04-30)


### Bug Fixes

* update Chinese translation (thank you @Wanxp) ([d0e19c6](https://github.com/javalent/obsidian-leaflet/commit/d0e19c615ad0e9fbba83f41269a4dcd9b0f14251))

## [5.5.7](https://github.com/javalent/obsidian-leaflet/compare/5.5.6...5.5.7) (2023-04-29)


### Bug Fixes

* latidude and longitude can be set (closes [#373](https://github.com/javalent/obsidian-leaflet/issues/373)) ([#374](https://github.com/javalent/obsidian-leaflet/issues/374)) ([d92df41](https://github.com/javalent/obsidian-leaflet/commit/d92df4181998be02556571108febb397e58b253e))

## [5.5.6](https://github.com/javalent/obsidian-leaflet/compare/5.5.5...5.5.6) (2023-04-28)


### Bug Fixes

* expand local links for obsidian's hover-preview (closes [#361](https://github.com/javalent/obsidian-leaflet/issues/361)) ([#375](https://github.com/javalent/obsidian-leaflet/issues/375)) ([c145fdd](https://github.com/javalent/obsidian-leaflet/commit/c145fdd464346e7084e276ae03f0b378172245d5))

## [5.5.5](https://github.com/javalent/obsidian-leaflet/compare/5.5.4...5.5.5) (2023-04-25)


### Bug Fixes

* latitude and longitude can be 0 (close [#362](https://github.com/javalent/obsidian-leaflet/issues/362)) ([deff0a8](https://github.com/javalent/obsidian-leaflet/commit/deff0a810ca5416e885feace4b0bebc62eeb5128))

## [5.5.4](https://github.com/javalent/obsidian-leaflet/compare/5.5.3...5.5.4) (2023-04-21)


### Bug Fixes

* markers should respect layers when reset now (close [#308](https://github.com/javalent/obsidian-leaflet/issues/308)) ([fcf974a](https://github.com/javalent/obsidian-leaflet/commit/fcf974aef7b6042a3b9cf3bbd3b1386116c40328))

## [5.5.3](https://github.com/javalent/obsidian-leaflet/compare/5.5.2...5.5.3) (2023-04-20)


### Bug Fixes

* fix-version ([bf3801e](https://github.com/javalent/obsidian-leaflet/commit/bf3801e2901690c34504c97c721b231da28ae5af))
* setup for npm release ([f00409a](https://github.com/javalent/obsidian-leaflet/commit/f00409ad2d812aadf66ed37ca5f9487d7d11e498))

## [3.5.5](https://github.com/javalent/obsidian-leaflet/compare/v3.5.4...3.5.5) (2023-04-20)


### Bug Fixes

* setup for npm release ([f00409a](https://github.com/javalent/obsidian-leaflet/commit/f00409ad2d812aadf66ed37ca5f9487d7d11e498))

### [5.5.2](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.5.1...5.5.2) (2023-04-11)


### Bug Fixes

* adds small dropshadow to markers (close [#363](https://github.com/valentine195/obsidian-leaflet-plugin/issues/363)) ([8badcaf](https://github.com/valentine195/obsidian-leaflet-plugin/commit/8badcaf57981198c3d544f2b769590c39190ebfd))

## [5.5.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.4.0...5.5.0) (2023-04-08)


### Features

* Can now measure in segments by continuing to mod-click ([fbdf5f0](https://github.com/valentine195/obsidian-leaflet-plugin/commit/fbdf5f095722b408ce4899bca9e8a23555a57111))

## [5.4.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.6...5.4.0) (2023-04-07)


### Features

* can alt-click to measure polylines from drawing ([6bc541f](https://github.com/valentine195/obsidian-leaflet-plugin/commit/6bc541f859c46f4ce52be8a4df602f935ef94e1c))


### Bug Fixes

* fixes incorrect use of Set ([b3f5c47](https://github.com/valentine195/obsidian-leaflet-plugin/commit/b3f5c47473e3c4f3c25be85f5b0de7f12b2a2506))

## [5.3.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.6...5.3.0) (2023-04-06)

### New Features
* Adds support for Chinese internalization (@Wanxp) [#358](https://github.com/valentine195/obsidian-leaflet-plugin/pull/358)
* Adds ability to save drawings as GeoJSON (close #337) (@preslavnpetrov) [#360](https://github.com/valentine195/obsidian-leaflet-plugin/pull/360)
* Improves GeoJSON file resolving (@SpocWeb) [#350](https://github.com/valentine195/obsidian-leaflet-plugin/pull/350)

### Bug Fixes

* fixes incorrect use of Set ([b3f5c47](https://github.com/valentine195/obsidian-leaflet-plugin/commit/b3f5c47473e3c4f3c25be85f5b0de7f12b2a2506))

### [5.2.7](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.6...5.2.7) (2023-03-29)

### [5.2.6](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.5...5.2.6) (2023-02-28)


### Bug Fixes

* fixes hover popover decoration ([734dd67](https://github.com/valentine195/obsidian-leaflet-plugin/commit/734dd676d0562b29e2e33d14823a9bfb3d0eceed))

### [5.2.5](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.4...5.2.5) (2023-02-28)


### Bug Fixes

* fixes source issue for hover-link ([4e60236](https://github.com/valentine195/obsidian-leaflet-plugin/commit/4e60236e13134f3a79ac5b07a4e468c409dc21bf))

### [5.2.4](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.3...5.2.4) (2023-02-28)


### Bug Fixes

* decorate leaflet sourced hover-popovers ([617d69f](https://github.com/valentine195/obsidian-leaflet-plugin/commit/617d69f7d2e2e7d0402f8dd33ab4b5935bbed15d))

### [5.2.3](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.2...5.2.3) (2023-02-28)


### Bug Fixes

* adds plugin as link hover source ([ada3e64](https://github.com/valentine195/obsidian-leaflet-plugin/commit/ada3e64627b5472c185ce4949135b94b70dd2e95))
* map now respects cmd-hover ([cd2142e](https://github.com/valentine195/obsidian-leaflet-plugin/commit/cd2142e23c4a187d307be21b6fc571ca9b93ec82))

### [5.2.2](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.1...5.2.2) (2023-02-14)


### Bug Fixes

* fixes copy on shift-click ([f623074](https://github.com/valentine195/obsidian-leaflet-plugin/commit/f62307466c2695c1ff2f93e5f2bbd89fbd0230b4))

### [5.2.1](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.2.0...5.2.1) (2023-02-14)


### Bug Fixes

* adds copy coordinates to mobile context menu ([400894f](https://github.com/valentine195/obsidian-leaflet-plugin/commit/400894f41c16fac2259ed00b952f4767a224a63f))

## [5.2.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.1.2...5.2.0) (2023-02-14)


### Features

* Mobile measuring added to map long-press menu ([525ae2d](https://github.com/valentine195/obsidian-leaflet-plugin/commit/525ae2dbd9fb503a17ab28e36eafb0b6aa15a72f))

### [5.1.2](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.1.1...5.1.2) (2023-01-30)


### Bug Fixes

* lock state persists ([d6436b1](https://github.com/valentine195/obsidian-leaflet-plugin/commit/d6436b1cb4ad324174db81428b76f620aff0f71a))

### [5.1.1](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.0.5...5.1.1) (2022-11-13)


### Bug Fixes

* version ([7f3f66b](https://github.com/valentine195/obsidian-leaflet-plugin/commit/7f3f66b5dcbebcffe8b9040647eabe2fd08f5f61))

### [5.0.5](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.1.0...5.0.5) (2022-11-13)

### [5.0.4](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.0.3...5.0.4) (2022-09-12)


### Bug Fixes

* fixes appearance of native context menus ([a70a041](https://github.com/valentine195/obsidian-leaflet-plugin/commit/a70a0415c84a2d925799f048a2151152ecbc772d))

### [5.0.3](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.0.2...5.0.3) (2022-04-02)


### Bug Fixes

* Fixes issue where marker types deleted in settings would crash the plugin ([bacc370](https://github.com/valentine195/obsidian-leaflet-plugin/commit/bacc37086f5822832eb5346c0312465b62178b0c))

### [5.0.2](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.0.1...5.0.2) (2022-03-30)


### Bug Fixes

* Fixes icons not rendering due to SVG mask duplication (close [#293](https://github.com/valentine195/obsidian-leaflet-plugin/issues/293)) ([6e95de5](https://github.com/valentine195/obsidian-leaflet-plugin/commit/6e95de573634887de500caed78a8a10b8155dad1))

### [5.0.1](https://github.com/valentine195/obsidian-leaflet-plugin/compare/5.0.0...5.0.1) (2022-03-15)


### Bug Fixes

* Fixes GPX tooltip not inheriting map units (close [#288](https://github.com/valentine195/obsidian-leaflet-plugin/issues/288)) ([8640245](https://github.com/valentine195/obsidian-leaflet-plugin/commit/8640245f87428a239b81bca13dce4230fcf4b880))

## [5.0.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.14.0...5.0.0) (2022-03-14)


### ⚠ BREAKING CHANGES

* OpenStreetMap has restricted use of its tile server in Obsidian. The default tile server for Obsidian Leaflet has been changed to Stamen Terrain. Please see #286 for more information. (close #286)

### Features

* OpenStreetMap has restricted use of its tile server in Obsidian. The default tile server for Obsidian Leaflet has been changed to Stamen Terrain. Please see [#286](https://github.com/valentine195/obsidian-leaflet-plugin/issues/286) for more information. (close [#286](https://github.com/valentine195/obsidian-leaflet-plugin/issues/286)) ([3b33092](https://github.com/valentine195/obsidian-leaflet-plugin/commit/3b33092ddf540d444033a2457e3fe6d7c68867f5))

## [4.14.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.13.0...4.14.0) (2022-02-28)


### Features

* Adds description field + reorganizes Edit Marker modal ([b1a648f](https://github.com/valentine195/obsidian-leaflet-plugin/commit/b1a648feeff2b171c824e7f2349d5e62fa21bf6c))
* Adds support for markdown links in addition to wikilinks (close [#280](https://github.com/valentine195/obsidian-leaflet-plugin/issues/280)) ([c903209](https://github.com/valentine195/obsidian-leaflet-plugin/commit/c9032096810b908c768a093769fce7401ce08d40))
* Marker double-clicks now open the edit marker modal ([1c01511](https://github.com/valentine195/obsidian-leaflet-plugin/commit/1c01511e9e6869dc58df54d5199990175de99749))


### Bug Fixes

* Fixed issue where setting a marker description could also set the link ([138d59b](https://github.com/valentine195/obsidian-leaflet-plugin/commit/138d59bdb9e91ff6493d6c24e6c6135a131e1133))
* Marker descriptions now displayed in tooltip even if there is a link ([bd9a200](https://github.com/valentine195/obsidian-leaflet-plugin/commit/bd9a200c23f46898e84287e4ebb9c33a98ac848e))

## [4.13.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.12.1...4.13.0) (2022-01-26)


### Features

* adds ability to force map to recenter when dragged ([057f9c6](https://github.com/valentine195/obsidian-leaflet-plugin/commit/057f9c61e54b2d01fabaf9299b72bb5f5a2452ab))
* adds noScrollZoom block parameter ([a8b607f](https://github.com/valentine195/obsidian-leaflet-plugin/commit/a8b607fe234e14c2c247bfa89f25999716ccb2a7))

### [4.12.1](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.12.0...4.12.1) (2022-01-25)


### Bug Fixes

* geojson and gpx now default to the file name [#263](https://github.com/valentine195/obsidian-leaflet-plugin/issues/263) ([4e9b72b](https://github.com/valentine195/obsidian-leaflet-plugin/commit/4e9b72b04ca25f4504f19c742f6dbb9b3fbb87cc))

## [4.12.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.11.0...4.12.0) (2022-01-25)


### Features

* can now link geojson to notes ([9eb6b2a](https://github.com/valentine195/obsidian-leaflet-plugin/commit/9eb6b2a24993dd55044ecd16df9de8e4ab495c75))
* maps can now be locked to prevent editing ([25befa7](https://github.com/valentine195/obsidian-leaflet-plugin/commit/25befa710a2d73ab02952281d23864e51a207a4a))
* tile layers can now default on with the `|on` flag ([f5a4e56](https://github.com/valentine195/obsidian-leaflet-plugin/commit/f5a4e565f0b86528af66bb4af2b69160ca63c89a))


### Bug Fixes

* fixes control order when just using tileoverlays ([8bbce58](https://github.com/valentine195/obsidian-leaflet-plugin/commit/8bbce58807fac4638cc8fe1a829b6193beea50cc))

## [4.11.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.10.0...4.11.0) (2022-01-24)


### Features

* much improved image loading ([08c80ed](https://github.com/valentine195/obsidian-leaflet-plugin/commit/08c80ed73b44ab870d0ae5d4b7947b4690400bec))

## [4.10.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.9.0...4.10.0) (2022-01-23)


### Features

* now show current zoom level on Reset Zoom control ([e53ace5](https://github.com/valentine195/obsidian-leaflet-plugin/commit/e53ace5a4b83765f45b5b86e091a1ff07c6ce29a))


### Bug Fixes

* Update release notes message ([8d8ec5c](https://github.com/valentine195/obsidian-leaflet-plugin/commit/8d8ec5cdf48fbb4de26eb53c77b7c932ee7ea81f))

## [4.9.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.8.0...4.9.0) (2022-01-11)


### Features

* add settings to change default tile servers ([043e248](https://github.com/valentine195/obsidian-leaflet-plugin/commit/043e248c7d17bd17374527b5a5838c41fd6f12dc))

## [4.8.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.7.4...4.8.0) (2021-12-16)


### Features

* added `width` parameter (close [#262](https://github.com/valentine195/obsidian-leaflet-plugin/issues/262)) ([d2d2a22](https://github.com/valentine195/obsidian-leaflet-plugin/commit/d2d2a2252c0e06893b99e7c377bc4f6648b7d829))


### Bug Fixes

* removed console logs ([34feb92](https://github.com/valentine195/obsidian-leaflet-plugin/commit/34feb92e040a1d2a2e3896f2dddec6fa7c59985e))
* scopes now properly inherit global scopes ([0b3b681](https://github.com/valentine195/obsidian-leaflet-plugin/commit/0b3b681f26e84baf7017d68ae492ac6b172f996f))

### [4.7.4](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.7.3...4.7.4) (2021-12-11)


### Bug Fixes

* fixed issue with tile overlay ([22da6cc](https://github.com/valentine195/obsidian-leaflet-plugin/commit/22da6cc8adde8d8ad0a5a3109084c5b3514abb26))

### [4.7.2](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.7.1...4.7.2) (2021-12-10)


### Bug Fixes

* update release message ([b27bfa8](https://github.com/valentine195/obsidian-leaflet-plugin/commit/b27bfa8c531facaffd4f689cafe1f5f32a4f67e9))

### [4.7.1](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.7.0...4.7.1) (2021-12-10)


### Bug Fixes

* fix release version ([a3b4c44](https://github.com/valentine195/obsidian-leaflet-plugin/commit/a3b4c44b3cc68d7644781e937e9f24f4b634340e))

## [4.7.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.6.2...4.7.0) (2021-12-10)


### Features

* testing changelog for claire ([a7d6464](https://github.com/valentine195/obsidian-leaflet-plugin/commit/a7d64644c54714ab386bc0f489f779a95e826148))

### [4.6.2](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.6.1...4.6.2) (2021-12-10)


### Bug Fixes

* index bug ([e11f663](https://github.com/valentine195/obsidian-leaflet-plugin/commit/e11f663b1eac24e2d499b84c64e3e3895b682238))

### [4.6.1](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.6.0...4.6.1) (2021-12-10)


### Bug Fixes

* bug with naming of new tileoverlays ([7398e5d](https://github.com/valentine195/obsidian-leaflet-plugin/commit/7398e5d594b17465e0136b855968da9957b8ce9b))

## [4.6.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.5.0...4.6.0) (2021-12-10)


### Features

* added `tileOverlay` map option to specify tile servers as map overlays ([eec6368](https://github.com/valentine195/obsidian-leaflet-plugin/commit/eec636861baaf1add50182d301ef033ec2ddf865))

## [4.5.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.4.0...4.5.0) (2021-12-06)


### Features

* added noUI parameter ([452dbc2](https://github.com/valentine195/obsidian-leaflet-plugin/commit/452dbc2347a10d3af64137c1cda22f3fd989beb0))

## [4.4.0](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.3.7...4.4.0) (2021-12-06)


### Features

* added `preserveAspect` map parameter (close [#254](https://github.com/valentine195/obsidian-leaflet-plugin/issues/254)) ([e507416](https://github.com/valentine195/obsidian-leaflet-plugin/commit/e5074160a62c1ad6b8dde5bc0c8bbcd2260efa5d))

### [4.3.7](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.3.6...4.3.7) (2021-12-06)


### Bug Fixes

* markers with only descriptions will display their popup (close [#253](https://github.com/valentine195/obsidian-leaflet-plugin/issues/253)) ([ceb8498](https://github.com/valentine195/obsidian-leaflet-plugin/commit/ceb8498b0cd50b55ed1aca9c7baaec92f5251bae))

### [4.3.6](https://github.com/valentine195/obsidian-leaflet-plugin/compare/4.3.5...4.3.6) (2021-12-06)


### Bug Fixes

* fixed issue where drag and drop was not linking note to marker ([f9261e3](https://github.com/valentine195/obsidian-leaflet-plugin/commit/f9261e388a2a0238fbf81532bcfec6cc4c9af1b6))

## 4.0.0
Highlights:

1. The *entire* plugin has been rewritten, resulting in a much faster and smoother experience.
2. Images are loaded in a background process and no longer block Obsidian from responding.
3. You can now view detailed health data on the map, including elevation, pace, cadence and more!
4. There is a brand-new Leaflet Map View. You can save parameters for your in-note maps to the view to open an exact copy, or create your own, custom view.
5. You can now draw and edit shapes directly on maps!
6. For those of you using Obsidian to run TTRPGs, Leaflet now integrates directly with the Initiative Tracker, giving you the ability to use it as a full-on battlemap.
7. You can now specify alternate map serves other than OpenStreetMap, and real-world maps can now have multiple layers.
8. The plugin now has full localization support (but currently only supports English).

Several bug fixes.

## 3.18.0

- Added support for GeoJSON styling using the MapBox SimpleStyle specification
- GeoJSON now displays a tooltip if the features have a `title`, `description` or `name` specified
- The default GeoJSON color can be set with the new `geojsonColor` parameter
- Fixed issue where maps would not load if a non-markdown file was present in the immutable file list

## 3.17.0

-   Added support for GeoJSON files
-   Added support for `mapmarkers` frontmatter tag
-   Backend updates

## 3.16.0

-   Added file watchers to automatically update immutable markers and overlays when note frontmatter changes
-   Fixed issue where `zoomDelta` was not respected when using scroll wheel
-   Fixes issue where markerFiles, markerFolders and markerTags were not rendered

## 3.15.0

-   Added `linksTo` and `linksFrom` parameters
-   Map overlays from note frontmatter will filter with the `mapmarker` type
-   Add new `coordinates` and `zoomTag` parameter
    -   `coordinates` can be used in lieu of `lat` and `long` parameters
    -   If the `coordinates` is a note file wikilink, it will read the note file's `location` frontmatter tag and use that for initial starting coordinates
    -   If `zoomTag` is specified, it will read the tag from the frontmatter of the _same_ file specified in `coordinates`. If `coordinates` is not a file, `zoomTag` does nothing. - It will use the tag (formatted the same as `overlayTag` - `<distance> <unit>`) to calculate the default zoom level to display

## 3.14.0

-   Close #74 - Added `bounds` parameter to set custom image map coordinates
-   Greatly improved error reporting
-   Fixed an issue where maps were defaulting to dark mode
-   Fixed issue where canceling drawing an overlay could cause an error on the next click

## 3.13.0

-   Added overlay descriptions
    -   Changed overlay syntax to `[<color>, <location>, <radius> <unit>, <description>]`
-   Added `overlayTag` and `overlayColor` map block parameters
-   Fixed issue where immutable markers would still launch the context modal
-   Fixed issue where transparent images were not uploading correctly
-   Fixed issue where a map with overlays but no markers would not save
-   Fixed issue where overlays drawn directly on image maps would not re-render correctly
-   Fixed issue where overlays defined with a non-hex color would display black in the color-picker
-   Fixed issue where edited parameters in the overlay context menu were not correctly applied
-   Overlay radiuses in the context menu now correctly display the radius in the correct unit
-   Improved visual appearance of a loading map
-   Improved documentation

## 3.12.0

-   Added ability to upload images to use as marker icons
    -   Images will be resized to 24px wide maximum
    -   Markers with image icons cannot be layered
    -   If the default marker is set to an image, additional marker types cannot be layered
-   Improved behavior of Filter Marker control box
-   File upload buttons now respect theme CSS
-   Fixed some bugs related to removing/adding marker types when maps are open

## 3.11.0

-   Large codebase re-organization
-   Maps are now generated by a Markdown render child generator
-   Maps now handle their own escape scopes
-   Image maps now load the first image then load remaining images in the background
-   Improved image rendering speed
-   Added ability to define `image`, `marker`, `commandMarker`, `markerFile`, `markerFolder`, and `markerTag` parameters using YAML syntax instead of multiple parameter tags
    -   `markerTag` instances cannot be defined using # in YAML - # denotes a comment
    -   YAML-style syntax cannot be combined with original syntax
-   Added basic circle map overlays
    -   Can be created on the map by <kbd>Shift</kbd>-right clicking on a point to begin drawing
    -   Can be defined in source block using new `overlay` parameter
    -   Can be created from note frontmatter (found using existing `markerFile`, `markerFolder` and `markerTag` parameters) using `mapoverlay`
    -   Please see [the ReadME section](./README.md#Overlays) for syntax
-   Fixed several issues related to marker filter control box
-   Fixed issue where the `Layer Marker` setting of a Marker Type was not being respected

## 3.10.0

-   Changed coordinate copy-to-clipboard from `[lat, lng]` to `lat, lng`
-   Added "Show All Markers" and "Reset View" control buttons
-   Added Filter Markers button that allows filtering by marker type (more filters to come, possibly)
-   Moved Bulk Edit Markers to Top Right
    -   Top Left -> View Controls
    -   Top Right -> Layer controls (incl. markers)
    -   Bottom Left -> Distance controls

## 3.9.2

-   In an effort to reduce notice spam, copying map/marker coordinates now must be done by <kbd>Ctrl</kbd> + <kbd>Shift</kbd>/<kbd>Alt</kbd>-clicking

## 3.9.0

-   Added `darkMode` parameter to invert map colors
-   Added "Bulk Edit Markers" button to maps underneath the fullscreen control
    -   Adds a simple way to change the type, location, and link of all mutable markers defined on the map.

## 3.8.3

-   Improved code structure
-   removed Notice of distance calculation
-   added control box in bottom-left corner that displays previously measured distance
    -   hovering the control box displays the previous distance line
    -   clicking the control box pans the map to fit the line
-   reduced number of decimals for distance display to 1
-   moved distance line tooltip to mouse cursor position
-   distance line tooltip is now always on top (no longer bounces around)

## 3.8.0

-   Added fullscreen map button
-   Distance line now correctly snaps to markers
-   Fixed some issues related to escaping from the distance line

## 3.7.0

-   Removed some unnecessary map events
-   Removed requirement for `scale` parameter on real world maps. Supplying a unit will try to auto-convert.
-   Added `distanceMultiplier` parameter that will display an additional, multiplied distance value when calculating distance
-   Fixed issue where clicking on the map without a modifier key was displaying click coordinates
-   added distance line display to map, from original click -> mouse cursor, with real-time distance tooltip
-   distances are now displayed according to user's locale
-   distance lines can be aborted by pressing <kbd>Escape</kbd>

## 3.6.0

-   Marker tooltips are now fully interactable (copy/paste, click)
-   Added ability to shift/alt click on map to display coordinates
-   Added setting toggle to copy location to clipboard on shift/alt click

## 3.5.0

-   Added ability to <kbd>Shift</kbd>-click to display marker coordinates along with existing <kbd>Alt</kbd>-click functionality
-   Changed distance feature to use <kbd>Shift</kbd> or <kbd>Alt</kbd> instead of <kbd>Ctrl</kbd>
-   Added ability to calculate distances using markers

## 3.4.0

-   Added explicit `commandMarker` and Command Marker toggles
    -   These are **required** if the marker is to execute a command

## 3.3.0

-   Marker links may now be Obsidian commands

## 3.2.0

-   Added <kbd>Alt<kbd>-click on marker to reveal coordinates

## 3.1.0

-   Changed from `marker` to `mapmarker` for frontmatter tag
    -   `marker` will continue to work for a few releases
    -   Added change notice warning
-   Added `markerTag` parameter
    -   requires Dataview plugin

## 3.0.0

### New Features

-   Map IDs are now required.
    -   A map that does not have an id will **not render**
    -   The plugin will try to load previously defined marker data once an id has been given to the map.
    -   This means marker definitions are no longer tied to maps - giving a map on a different note the same ID will load the same marker data
-   Marker data that is not associated with a file will now be deleted after 7 days to prevent data accumulation
-   Map data is now only saved if the map has defined markers
-   Image files can now be linked using an Obsidian wikilink (e.g., [[Image Name.jpg]])
-   New `markerFile` and `markerFolder` parameters in maps
    -   `markerFile` will read a note file's frontmatter and create a marker based on the `marker` and `location` tags
        -   `marker` should be a defined marker type (will default to `default` if not provided)
        -   `location` should be a array of [latitude, longitude]. **If not provided, the marker will not be created**
        -   The marker link target will be set to the file
    -   `markerFolder` will read _all_ of the files in the folder, and try to parse the frontmatter as above.
-   Made display of marker link in tooltip consistent with Obsidian's display style
-   Added data attributes to marker HTML element
    -   data-type: marker type
    -   data-link: marker link target, if any
    -   data-mutable: whether marker data can be edited
    -   data-type: marker type name (such as default)
-   Switched from uuid to 6 digit nanoid
-   Rendering improvements

### Bug Fixes

-   Fixed issue where a new marker type's Layer Icon setting was not respecting the default layer marker setting
-   Fixed issue where clicking a marker could open the context menu
-   Fixed issue where clicking a marker without a link could cause an error
-   Fixed issue with opening a marker link defined with alt-text
-   Fixed issue where resizing the leaf containing a map caused it to calculate marker positions incorrectly
-   Fixed issue where having the same map open in multiple windows was not adding markers correctly
-   Fixed issue where dragging a marker created on a map open in multiple views would not drag correctly on other maps
-   Fixed issue where turning the plugin off would leave map tiles in random locations on open notes
-   Fixed issue where showing the note preview of a note with a map that is already open in the workspace would cause the map to be disassociated

## 2.1.0

-   Added marker parameter in code block
-   Fixed issue where importing a CSV file that changed a marker on an open map failed to update the marker information

## 2.0.0

-   Added ability to export marker data to a CSV file
-   Added ability to import marker data from a CSV file
-   Added Obsidian-like file chooser to marker link path

## 1.3.0

-   Removed requirement for file path in marker target
-   Added ability to target blocks in marker target

## 1.2.0

-   Add rudimentary distance calculation between two points on the map
-   Fixed issue where opening the same map in multiple leaves could cause one map to de-render

## 1.1.0

-   Maps now recalculate their sizing when the window is resized

## 1.0.0

-   Switch to proper semantic versioning
-   Added Note Preview setting
    -   This setting displays the Obsidian page preview when you hover over a linked marker
-   Map height can now be in provided as a percentage

## 0.3.1

-   Added image map layers
    -   It is now possible to have an arbitrary number of image maps layered on top of each other by supplying multiple images to the code block
    -   Markers created on a specific layer are only displayed when that layer is active
    -   Navigation between layers is done using the layer control box in the top right

## 0.2.2

-   Added real-world maps
-   Added latitude and longitude options
-   Added zoom delta option
-   Added tooltip display on markers that link to notes
-   Bug fixes



================================================
FILE: esbuild.config.mjs
================================================
import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import inlineWorkerPlugin from "esbuild-plugin-inline-worker";
import { replace } from "esbuild-plugin-replace";
import { config } from "dotenv";

config();

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";

const dir = prod ? "./" : process.env.OUTDIR;

esbuild
    .build({
        banner: {
            js: banner
        },
        entryPoints: ["src/main.ts", "src/styles.css"],
        bundle: true,
        external: [
            "obsidian",
            "electron",
            "@codemirror/autocomplete",
            "@codemirror/collab",
            "@codemirror/commands",
            "@codemirror/language",
            "@codemirror/lint",
            "@codemirror/search",
            "@codemirror/state",
            "@codemirror/view",
            "@lezer/common",
            "@lezer/highlight",
            "@lezer/lr",
            ...builtins
        ],
        format: "cjs",
        watch: !prod,
        target: "es2020",
        logLevel: "info",
        sourcemap: prod ? false : "inline",
        minify: prod,
        treeShaking: true,
        outdir: dir,
        loader: { ".png": "base64" },
        plugins: [inlineWorkerPlugin()]
    })
    .catch(() => {
        process.exit(1);
    });



================================================
FILE: index.d.ts
================================================
/* import type {
    Feature,
    FeatureCollection,
    GeoJsonObject,
    GeoJsonProperties,
    GeoJsonTypes,
    Geometry
} from "geojson"; */

declare module "@tmcw/togeojson" {
    export function kml(doc: Document): GeoJSON.FeatureCollection;

    export function kml<TProperties extends GeoJSON.GeoJsonProperties>(
        doc: Document
    ): GeoJSON.FeatureCollection<GeoJSON.Geometry, TProperties>;

    export function kmlGen(doc: Document): Generator<GeoJSON.Feature, void, boolean>;
    export function kmlGen<TProperties extends GeoJSON.GeoJsonProperties>(
        doc: Document
    ): Generator<GeoJSON.Feature<GeoJSON.Geometry, TProperties>, void, boolean>;

    export function gpx(doc: Document): GeoJSON.FeatureCollection;
    export function gpx<TProperties extends GeoJSON.GeoJsonProperties>(
        doc: Document
    ): GeoJSON.FeatureCollection<GeoJSON.Geometry>;

    export function gpxGen(doc: Document): Generator<GeoJSON.Feature, void, boolean>;
    export function gpxGen<TProperties extends GeoJSON.GeoJsonProperties>(
        doc: Document
    ): Generator<GeoJSON.Feature<GeoJSON.Geometry, TProperties>, void, boolean>;

    export function tcx(doc: Document): GeoJSON.FeatureCollection;
    export function tcx<TProperties extends GeoJSON.GeoJsonProperties>(
        doc: Document
    ): GeoJSON.FeatureCollection<GeoJSON.Geometry, GeoJSON.GeoJsonProperties>;
}



================================================
FILE: index.ts
================================================
import { ObsidianAppData } from "types";

export interface LeafletAPI {
    openInitiativeView(
        pcs: import("../src/utils/creature").Creature[],
        npcs: import("../src/utils/creature").Creature[]
    ): unknown;
    markerIcons: MarkerIcon[];
    data: ObsidianAppData;
}

interface MarkerIcon {
    html: string;
    type: string;
}



================================================
FILE: manifest.json
================================================
{
    "id": "obsidian-leaflet-plugin",
    "name": "Leaflet",
    "description": "Interactive maps inside your notes",
    "version": "6.0.5",
    "minAppVersion": "0.12.12",
    "author": "Jeremy Valentine",
    "repo": "valentine195/obsidian-leaflet-plugin",
    "isDesktopOnly": false
}



================================================
FILE: package.json
================================================
{
    "name": "obsidian-leaflet",
    "version": "6.0.5",
    "description": "Leaflet integration for Obsidian.md",
    "main": "main.js",
    "scripts": {
        "dev": "export NODE_ENV=development && npm run build",
        "build": "webpack",
        "dev-es": "node ./esbuild.config.mjs",
        "build-es": "node ./esbuild.config.mjs production"
    },
    "keywords": [],
    "author": "",
    "license": "MIT",
    "devDependencies": {
        "@fortawesome/fontawesome-svg-core": "^1.2.35",
        "@fortawesome/free-regular-svg-icons": "^5.15.2",
        "@fortawesome/free-solid-svg-icons": "^5.15.1",
        "@popperjs/core": "^2.9.2",
        "@tmcw/togeojson": "^4.5.0",
        "@types/color": "^3.0.1",
        "@types/leaflet": "^1.7.4",
        "@types/leaflet-fullscreen": "^1.0.4",
        "@types/mime": "^2.0.3",
        "@types/node": "^14.14.31",
        "@types/pako": "^2.0.0",
        "@types/papaparse": "^5.2.5",
        "@types/xmldom": "^0.1.31",
        "builtin-modules": "^3.3.0",
        "color": "^3.1.3",
        "compare-versions": "^3.6.0",
        "convert": "^1.8.3",
        "copy-webpack-plugin": "^9.0.1",
        "css-loader": "^5.2.7",
        "dotenv": "^16.0.3",
        "esbuild": "^0.14.47",
        "esbuild-loader": "^2.21.0",
        "esbuild-plugin-inline-worker": "^0.1.1",
        "esbuild-plugin-replace": "^1.3.0",
        "ignore-loader": "^0.1.2",
        "imports-loader": "^3.0.0",
        "javalent-obsidian-overload": "^1.0.0",
        "leaflet": "^1.7.1",
        "leaflet-fullscreen": "^1.0.2",
        "leaflet-hotline": "^0.4.0",
        "mime": "^2.5.2",
        "mini-css-extract-plugin": "^2.1.0",
        "monkey-around": "^2.3.0",
        "obsidian": "^1.2.8",
        "papaparse": "^5.3.0",
        "standard-version": "^9.3.2",
        "string-replace-loader": "^3.0.3",
        "ts-loader": "^9.2.3",
        "tslib": "^2.0.3",
        "typescript": "^4.3.5",
        "webpack": "^5.44.0",
        "webpack-bundle-analyzer": "^4.4.2",
        "webpack-cli": "^4.7.2",
        "webpack-inject-plugin": "^1.5.5",
        "worker-loader": "^3.0.8",
        "xmldom": "^0.6.0"
    },
    "dependencies": {
        "pako": "^2.1.0"
    }
}



================================================
FILE: README_zh_CN.md
================================================
[Binary file]


================================================
FILE: release-please-config.json
================================================
{
    "packages": {
        ".": {
            "changelog-path": "CHANGELOG.md",
            "release-type": "node"
        }
    },
    "include-component-in-tag": false,
    "include-v-in-tag": false,
    "extra-files": [
        {
            "type": "json",
            "path": "manifest.json",
            "jsonpath": "$.version"
        }
    ],
    "$schema": "https://raw.githubusercontent.com/googleapis/release-please/main/schemas/config.json"
}



================================================
FILE: tsconfig.json
================================================
{
    "compilerOptions": {
        "baseUrl": ".",
        "sourceMap": true,
        "module": "esnext",
        "target": "es6",
        "allowJs": true,
        "noImplicitAny": true,
        "moduleResolution": "node",
        "importHelpers": true,
        "experimentalDecorators": true,
        "allowSyntheticDefaultImports": true,
        "lib": ["dom", "esnext", "scripthost", "es2019"]
    },
    "include": ["**/*.ts"]
}



================================================
FILE: versions.json
================================================
{
    "0.2.14": "0.11.0",
    "0.3.1": "0.11.0",
    "1.0.2": "0.11.0",
    "1.1.1": "0.11.0",
    "1.3.0": "0.11.0",
    "2.0.4": "0.11.0",
    "2.1.1": "0.11.0",
    "3.0.0": "0.11.13",
    "3.1.1": "0.11.13",
    "3.2.1": "0.11.13",
    "3.3.0": "0.11.13",
    "3.4.1": "0.11.13",
    "3.5.0": "0.11.13",
    "3.6.0": "0.11.13",
    "3.7.2": "0.11.13",
    "3.8.3": "0.11.13",
    "3.9.5": "0.11.13",
    "3.11.3": "0.11.13",
    "3.12.1": "0.11.13",
    "3.13.6": "0.11.13",
    "3.14.1": "0.12.0",
    "3.15.0": "0.12.0",
    "3.16.4": "0.12.0",
    "3.17.0": "0.12.0",
    "3.18.14": "0.12.0",
    "3.19.10": "0.12.0",
    "3.20.2": "0.12.10",
    "3.21.3": "0.12.10",
    "3.22.2": "0.12.10",
    "3.23.2": "0.12.10",
    "3.24.3": "0.12.10",
    "4.0.0": "0.12.12",
    "4.2.2": "0.12.12",
    "4.3.5": "0.12.12"
}


================================================
FILE: webpack.config.js
================================================
const path = require("path");
const CopyPlugin = require("copy-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const webpack = require("webpack");
const InjectPlugin = require("webpack-inject-plugin").default;
const { config } = require("dotenv");

config();
const isDevMode = process.env.NODE_ENV === "development";

module.exports = {
    entry: "./src/main.ts",
    output: {
        path: path.resolve(isDevMode ? process.env.OUTDIR : __dirname, "."),
        filename: "main.js",
        libraryTarget: "commonjs"
    },
    target: "node",
    mode: isDevMode ? "development" : "production",
    watch: isDevMode,
    ...(isDevMode ? { devtool: "eval" } : {}),
    module: {
        rules: [
            {
                test: /leaflet(\.path|-hotline|-freedraw|-fullscreen|-editable|-textbox)/,
                loader: "string-replace-loader",
                options: {
                    multiple: [
                        {
                            search: /(\.|\s|\()L\./g,
                            replace: (match, p1) =>
                                `${p1}window.OBSIDIAN_LEAFLET_PLUGIN.`
                        }
                    ]
                }
            },
            {
                test: /\.worker\.ts?$/,
                loader: "worker-loader",
                options: {
                    inline: "no-fallback",
                    worker: {
                        type: "Worker",
                        options: {
                            name: "Leaflet Image Loader",
                            esModule: false
                        }
                    }
                }
            },
            {
                test: /\.tsx?$/,
                loader: "esbuild-loader",
                options: {
                    loader: "tsx", // Or 'ts' if you don't need tsx
                    target: "es2020"
                }
            },
            {
                test: /\.css?$/,
                use: [
                    MiniCssExtractPlugin.loader,
                    {
                        loader: "css-loader",
                        options: {
                            url: false
                        }
                    }
                ]
            },
            {
                test: /\.(png)$/,
                type: "asset/inline"
            }
        ]
    },
    plugins: [
        new CopyPlugin({
            patterns: [{ from: "./manifest.json", to: "." }]
        }),
        new webpack.optimize.LimitChunkCountPlugin({
            maxChunks: 1
        }),
        new MiniCssExtractPlugin({
            filename: "styles.css"
        })
    ],
    resolve: {
        extensions: [".ts", ".tsx", ".js"],
        mainFields: ["browser", "module", "main"],
        alias: {
            src: path.resolve(__dirname, "src")
        }
    },
    externals: {
        obsidian: "commonjs2 obsidian",
        moment: "commonjs2 moment"
    }
};



================================================
FILE: .npmignore
================================================
**/*
!types/**/*
!index.ts
!tsconfig.json


================================================
FILE: .release-please-manifest.json
================================================
{
  ".": "6.0.5"
}


================================================
FILE: publish/documentation-addition.md
================================================

# Your Feature Title Here

Describe what your new feature is.

Describe how to use it.

Feel free to include screenshots. Place them in the publish/images folder

## Code Block Example
````yaml
```encounter
Wrap your encounter code block examples in a yaml wrapper as well.
```
````


## Long Code Block Example
>[!code]- Feature Title Long Code Block
>````yaml
>```encounter
>Wrap your encounter code block examples in a yaml wrapper as well.
>```
>````

## H2 if Needed

## H3 if Needed



================================================
FILE: publish/Folder-parameters.md
================================================
# Folder-parameters in leaflet

## `geojsonFolder`
The `geojsonFolder` Tag allows to specify one or more Folders to contain *.geojson or *.json Files to be rendered into the current map.

## `markerFolder` 
Similarly, the `markerFolder` Tag allows to specify one or more Folders to contain *.md Files with `location` and `mapmarker` Tags in their YAML FrontMatter to be displayed as Markers in the Map. 

Both Folder Paths can start with a 
- '/' (Slash) based on the Vault Directory or
- './' relative to the current *.md Document 

By default Files from all Subfolders are added. 

To limit the Number of Subfolders, append one or more '/' (Slashes) to the path, one for each Folder-Level to include. 

## Code Block Example
````yaml
```leaflet
zoomFeatures: true 
minZoom: 2 
maxZoom: 18
geojsonFolder: ./Germany~East/
markerFolder: ./Germany~East/City
```
````

This renders both...
- *.geojson Files from the Germany~East Folder and its direct Subfolders and
- Markers for the Cities.md Files in the Germany~East/City Folder 

The Result looks like this: 
![./images/Germany~East.png] 

(Find the full example [here](https://github.com/SpocWiki/_public/blob/main/geo/Continent/Europe/Germany/Germany~East.md))




================================================
FILE: src/main.ts
================================================
/* import "leaflet"; */
import "../node_modules/leaflet/dist/leaflet.css";
import "./assets/main.css";
import { Creature } from "../../obsidian-initiative-tracker/src/utils/creature";

import {
    Notice,
    MarkdownPostProcessorContext,
    Plugin,
    TFile,
    addIcon,
    Platform,
    WorkspaceLeaf,
    debounce,
    HoverParent,
    EphemeralState,
    HoverPopover
} from "obsidian";
import { around } from "monkey-around";

//Local Imports

import { ObsidianLeafletSettingTab } from "./settings/settings";

import {
    getIcon,
    DEFAULT_SETTINGS,
    getParamsFromSource,
    getMarkerIcon,
    DESCRIPTION_ICON,
    DESCRIPTION_ICON_SVG,
    log,
    BULLSEYE,
    BULLSEYE_ICON_SVG,
    VIEW_ICON_SVG,
    VIEW_ICON,
    VIEW_TYPE,
    MODIFIER_KEY,
    UNIT_SYSTEM,
    DEFAULT_TILE_SERVER,
    getId,
    OBSIDIAN_LEAFLET_POPOVER_SOURCE,
    DEFAULT_ATTRIBUTION
} from "./utils";
import {
    MapInterface,
    MarkerIcon,
    ObsidianAppData,
    Icon,
    Marker,
    BaseMapType
} from "../types";

import { LeafletRenderer } from "./renderer/renderer";
import { markerDivIcon } from "./map/divicon";
import { InitiativeMapView } from "./initiative/initiative";
import t from "./l10n/locale";
import { CreateMarkerModal } from "./modals";
import { LeafletMapView } from "./map/view";
import { Length } from "convert/dist/types/units";

//add commands to app interface

import type { Plugins } from "../../obsidian-overload/index";

declare module "obsidian" {
    interface HoverPopover {
        targetEl: HTMLElement;
        onShow(): void;
    }
    interface EphemeralState {
        focus?: boolean;
        subpath?: string;
        line?: number;
        startLoc?: Loc;
        endLoc?: Loc;
        scroll?: number;
        source?: string;
    }
    interface InternalPlugin {
        disable(): void;
        enable(): void;
        enabled: boolean;
        _loaded: boolean;
        instance: { name: string; id: string };
    }
    interface InternalPlugins {
        "page-preview": InternalPlugin;
    }
    interface App {
        //@ts-ignore
        plugins: {
            getPlugin<T extends keyof Plugins>(plugin: T): Plugins[T];
        };
        internalPlugins: {
            plugins: InternalPlugins;
            getPluginById<T extends keyof InternalPlugins>(
                id: T
            ): InternalPlugins[T];
        };

        commands: {
            commands: { [id: string]: Command };
            editorCommands: { [id: string]: Command };
            findCommand(id: string): Command;
            executeCommandById(id: string): void;
            listCommands(): Command[];
            executeCommandById(id: string): void;
            findCommand(id: string): Command;
        };
        keymap: {
            pushScope(scope: Scope): void;
            popScope(scope: Scope): void;
        };
    }
    interface MarkdownPostProcessorContext {
        containerEl: HTMLElement;
    }

    interface MenuItem {
        dom: HTMLDivElement;
    }
    interface Vault {
        //@ts-ignore
        config: {
            theme: "moonstone" | "obsidian";
        };
    }
    interface Workspace {
        on(
            name: "initiative-tracker:unload",
            callback: (...args: any) => any
        ): EventRef;
    }
}

export default class ObsidianLeaflet extends Plugin {
    data: ObsidianAppData;
    markerIcons: MarkerIcon[];
    maps: MapInterface[] = [];
    mapFiles: { file: string; maps: string[] }[] = [];
    watchers: Set<TFile> = new Set();
    Platform = Platform;
    isDesktop = Platform.isDesktopApp;
    isMobile = Platform.isMobileApp;
    isMacOS = Platform.isMacOS;
    get modifierKey() {
        return this.isMacOS ? "Meta" : "Control";
    }
    /* escapeScope: Scope; */
    get view() {
        const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
        const leaf = leaves.length ? leaves[0] : null;
        if (leaf && leaf.view && leaf.view instanceof LeafletMapView)
            return leaf.view;
    }

    get initiativeView() {
        const leaves = this.app.workspace.getLeavesOfType(
            "INITIATIVE_TRACKER_MAP_VIEW"
        );
        const leaf = leaves.length ? leaves[0] : null;
        if (leaf && leaf.view && leaf.view instanceof InitiativeMapView)
            return leaf.view;
    }

    get defaultUnit() {
        if (this.data.defaultUnitType === "imperial") return "mi";
        return "km";
    }

    unitSystemForUnit(unit: Length) {
        if (!unit) return this.data.defaultUnitType;
        return (
            (UNIT_SYSTEM[unit] as "metric" | "imperial") ??
            this.data.defaultUnitType
        );
    }

    async onload(): Promise<void> {
        console.log(t("Loading Obsidian Leaflet v%1", this.manifest.version));
        await this.loadSettings();

        addIcon(DESCRIPTION_ICON, DESCRIPTION_ICON_SVG);
        addIcon(BULLSEYE, BULLSEYE_ICON_SVG);
        addIcon(VIEW_ICON, VIEW_ICON_SVG);

        if (this.data.mapViewEnabled) {
            this.addRibbonIcon(VIEW_ICON, t("Open Leaflet Map"), (evt) => {
                this.app.workspace
                    .getLeaf(evt.getModifierState(MODIFIER_KEY))
                    .setViewState({ type: VIEW_TYPE });
            });

            this.registerView(VIEW_TYPE, (leaf: WorkspaceLeaf) => {
                return new LeafletMapView(leaf, this);
            });
        }

        this.app.workspace.onLayoutReady(() => {
            this.patchLinkHover();

            this.registerEvent(
                this.app.vault.on("rename", async (file, oldPath) => {
                    if (!file) return;
                    if (!this.mapFiles.find(({ file: f }) => f === oldPath))
                        return;

                    this.mapFiles.find(({ file: f }) => f === oldPath).file =
                        file.path;

                    await this.saveSettings();
                })
            );
            this.registerEvent(
                this.app.vault.on("delete", async (file) => {
                    if (!file) return;
                    if (!this.mapFiles.find(({ file: f }) => f === file.path))
                        return;

                    this.mapFiles = this.mapFiles.filter(
                        ({ file: f }) => f != file.path
                    );

                    await this.saveSettings();
                })
            );

            this.registerHoverLinkSource(this.manifest.id, {
                display: this.manifest.name,
                defaultMod: false
            });
            //@ts-ignore
            if (this.app.plugins.getPlugin("initiative-tracker")) {
                this.registerView(
                    "INITIATIVE_TRACKER_MAP_VIEW",
                    (leaf: WorkspaceLeaf) => {
                        return new InitiativeMapView(leaf, this);
                    }
                );
            }

            this.registerEvent(
                this.app.workspace.on("initiative-tracker:unload", () => {
                    if (this.initiativeView) {
                        this.initiativeView.leaf.detach();
                    }
                })
            );
        });

        this.markerIcons = this.generateMarkerMarkup(this.data.markerIcons);
        this.registerMarkdownCodeBlockProcessor(
            "leaflet",
            this.postprocessor.bind(this)
        );

        this.addSettingTab(new ObsidianLeafletSettingTab(this.app, this));
    }
    patchLinkHover() {
        const plugin = this;
        const pagePreviewPlugin =
            this.app.internalPlugins.plugins["page-preview"];
        if (!pagePreviewPlugin.enabled) return;
        const uninstaller = around(HoverPopover.prototype, {
            onShow(old: Function) {
                return function () {
                    if (
                        this.parent?.state?.source ==
                        OBSIDIAN_LEAFLET_POPOVER_SOURCE
                    ) {
                        this.hoverEl.addClass("obsidian-leaflet-popover");
                    }
                    return old.call(this);
                };
            }
        });
        this.register(uninstaller);

        // This will recycle the event handlers so that they pick up the patched onLinkHover method
        pagePreviewPlugin.disable();
        pagePreviewPlugin.enable();

        plugin.register(function () {
            if (!pagePreviewPlugin.enabled) return;
            pagePreviewPlugin.disable();
            pagePreviewPlugin.enable();
        });
    }

    async onunload(): Promise<void> {
        console.log(t("Unloading Obsidian Leaflet"));

        this.maps.forEach((map) => {
            map?.map?.remove();
            let newPre = createEl("pre");
            newPre.createEl("code", {}, (code) => {
                code.innerText = `\`\`\`leaflet\n${map.source}\`\`\``;
                map.el.parentElement.replaceChild(newPre, map.el);
            });
        });

        if (this.view) {
            this.view.leaf.detach();
        }

        if (this.initiativeView) {
            this.initiativeView.leaf.detach();
        }

        this.maps = [];
    }

    async postprocessor(
        source: string,
        el: HTMLElement,
        ctx: MarkdownPostProcessorContext
    ): Promise<void> {
        /* try { */
        /** Get Parameters from Source */
        let params = getParamsFromSource(source);

        if (!params.id) {
            new Notice(t("Obsidian Leaflet maps must have an ID."));
            throw new Error(t("ID required"));
        }
        log(params.verbose, params.id, "Beginning Markdown Postprocessor.");

        const renderer = new LeafletRenderer(
            this,
            ctx.sourcePath,
            el,
            params,
            source
        );

        const map = await renderer.getMap();
        this.registerMapEvents(map);

        ctx.addChild(renderer);

        /** Add Map to Map Store
         */
        this.maps = this.maps.filter((m) => m.el != el);
        this.maps.push({
            map,
            source,
            el,
            id: params.id
        });

        if (this.mapFiles.find(({ file }) => file == ctx.sourcePath)) {
            this.mapFiles
                .find(({ file }) => file == ctx.sourcePath)
                .maps.push(params.id);
        } else {
            this.mapFiles.push({
                file: ctx.sourcePath,
                maps: [params.id]
            });
        }

        /* } catch (e) {
            console.error(e);
            new Notice("There was an error loading the map.");
            renderError(el, e.message);
        } */
    }
    get configDirectory() {
        if (!this.data.configDirectory) return;
        return `${this.data.configDirectory}/plugins/obsidian-leaflet-plugin`;
    }
    get configFilePath() {
        if (!this.data.configDirectory) return;
        return `${this.configDirectory}/data.json`;
    }
    async loadSettings() {
        this.data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());

        if (
            this.configDirectory &&
            (await this.app.vault.adapter.exists(this.configFilePath))
        ) {
            this.data = Object.assign(
                {},
                this.data,
                JSON.parse(
                    await this.app.vault.adapter.read(this.configFilePath)
                )
            );
        }

        if (
            this.data.version?.major != null &&
            this.data.version?.major < 5 &&
            (this.data.defaultTile.contains("stamen-tiles") ||
                this.data.defaultTileDark.contains("stamen-tiles"))
        ) {
            new Notice(
                createFragment((e) => {
                    e.createSpan({
                        text: "Obsidian Leaflet: Stamen has removed its map tile servers."
                    });
                    e.createEl("br");
                    e.createEl("br");
                    e.createSpan({
                        text: "Going forward, the default tile server will be "
                    });
                    e.createEl("a", {
                        href: "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png",
                        text: "CartoDB"
                    });
                    e.createSpan({ text: "." });
                }),
                0
            );
            if (this.data.defaultTile.contains("stamen-tiles")) {
                this.data.defaultTile = DEFAULT_TILE_SERVER;
            }
            if (this.data.defaultTileDark.contains("stamen-tiles")) {
                this.data.defaultTileDark = DEFAULT_TILE_SERVER;
            }
            if (this.data.defaultAttribution.contains("Stamen Design")) {
                this.data.defaultAttribution = DEFAULT_ATTRIBUTION;
            }
        }
        if (
            this.data.version?.major != null &&
            this.data.version?.major < 6 &&
            (this.data.defaultTile.contains("stamen") ||
                this.data.defaultTileDark.contains("stamen"))
        ) {
            new Notice(
                createFragment((e) => {
                    e.createSpan({
                        text: "Obsidian Leaflet: OpenStreetMap has restricted the use of its tile server in Obsidian."
                    });
                    e.createEl("br");
                    e.createEl("br");
                    e.createSpan({
                        text: "Going forward, the default tile server will be "
                    });
                    e.createEl("a", {
                        href: "http://maps.stamen.com/#terrain/12/37.7706/-122.3782",
                        text: "Stamen Terrain"
                    });
                    e.createSpan({ text: "." });
                }),
                0
            );
            if (this.data.defaultTile.contains("openstreetmap")) {
                this.data.defaultTile = DEFAULT_TILE_SERVER;
            }
            if (this.data.defaultTileDark.contains("openstreetmap")) {
                this.data.defaultTileDark = DEFAULT_TILE_SERVER;
            }
        }
        this.data.previousVersion = this.manifest.version;
        const splitVersion = this.data.previousVersion.split(".");
        this.data.version = {
            major: Number(splitVersion[0]),
            minor: Number(splitVersion[1]),
            patch: Number(splitVersion[2])
        };
        if (typeof this.data.displayMarkerTooltips === "boolean") {
            this.data.displayMarkerTooltips = this.data.displayMarkerTooltips
                ? "hover"
                : "never";
        }
        if (!this.data.defaultMarker || !this.data.defaultMarker.iconName) {
            this.data.defaultMarker = DEFAULT_SETTINGS.defaultMarker;
            this.data.layerMarkers = false;
        }
        await this.saveSettings();
    }
    saveSettings = debounce(
        async () => {
            this.maps.forEach((map) => {
                this.data.mapMarkers = this.data.mapMarkers.filter(
                    ({ id }) => id != map.id
                );
                this.data.mapMarkers.push({
                    ...map.map.toProperties(),
                    files: this.mapFiles
                        .filter(({ maps }) => maps.indexOf(map.id) > -1)
                        .map(({ file }) => file)
                });
            });

            /** Only need to save maps with defined marker data */
            this.data.mapMarkers = this.data.mapMarkers.filter(
                ({ markers, overlays, shapes }) =>
                    markers.length > 0 ||
                    overlays.length > 0 ||
                    shapes.length > 0
            );

            await this.saveData(this.data);
        },
        100,
        false
    );

    async saveMarkerTypes() {
        await this.saveSettings();
        this.markerIcons = this.generateMarkerMarkup(this.data.markerIcons);

        this.maps.forEach((map) => {
            map.map.updateMarkerIcons();
        });
    }

    async saveData(data: Record<any, any>) {
        if (this.configDirectory) {
            try {
                if (
                    !(await this.app.vault.adapter.exists(this.configDirectory))
                ) {
                    await this.app.vault.adapter.mkdir(this.configDirectory);
                }
                await this.app.vault.adapter.write(
                    this.configFilePath,
                    JSON.stringify(data)
                );
            } catch (e) {
                console.error(e);
                new Notice(
                    t(
                        "There was an error saving into the configured directory."
                    )
                );
            }
        }
        await super.saveData(data);
    }

    registerMapEvents(map: BaseMapType) {
        this.registerDomEvent(map.contentEl, "dragover", (evt) => {
            evt.preventDefault();
        });
        this.registerDomEvent(map.contentEl, "drop", (evt) => {
            evt.stopPropagation();
            let link = decodeURIComponent(
                evt.dataTransfer.getData("text/plain")
            )
                .split("file=")
                .pop();

            const extension = /\.\w+$/.test(link) ? "" : ".md";

            const file = this.app.vault.getAbstractFileByPath(
                `${link}${extension}`
            );

            if (!(file instanceof TFile)) return;

            const latlng = map.leafletInstance.mouseEventToLatLng(evt);
            const loc: [number, number] = [latlng.lat, latlng.lng];

            let marker = map.createMarker(
                map.defaultIcon.type,
                loc,
                undefined,
                undefined,
                file.basename
            );
            marker.leafletInstance.closeTooltip();
        });

        map.on("marker-added", async (marker: Marker) => {
            marker.leafletInstance.closeTooltip();
            marker.leafletInstance.unbindTooltip();
            this.maps
                .filter(
                    ({ id, map: m }) =>
                        id == map.id && m.contentEl != map.contentEl
                )
                .forEach((map) => {
                    map.map.addMarker(marker.toProperties());
                });
            await this.saveSettings();
        });

        map.on("marker-dragging", (marker: Marker) => {
            this.maps
                .filter(
                    ({ id, map: m }) =>
                        id == map.id && m.contentEl != map.contentEl
                )
                .forEach((otherMap) => {
                    let existingMarker = otherMap.map.markers.find(
                        (m) => m.id == marker.id
                    );
                    if (!existingMarker) return;

                    existingMarker.leafletInstance.setLatLng(
                        marker.leafletInstance.getLatLng()
                    );
                });
        });

        map.on("marker-data-updated", async (marker: Marker) => {
            await this.saveSettings();
            this.maps
                .filter(
                    ({ id, map: m }) =>
                        id == map.id && m.contentEl != map.contentEl
                )
                .forEach((map) => {
                    let existingMarker = map.map.markers.find(
                        (m) => m.id == marker.id
                    );
                    if (!existingMarker) return;

                    existingMarker.leafletInstance.setLatLng(
                        marker.leafletInstance.getLatLng()
                    );
                });
        });

        map.on("marker-deleted", (marker) => {
            const otherMaps = this.maps.filter(
                ({ id, map: m }) => id == map.id && m.contentEl != map.contentEl
            );
            for (let { map } of otherMaps) {
                map.removeMarker(marker);
            }
        });

        map.on("marker-updated", (marker) => {
            const otherMaps = this.maps.filter(
                ({ id, map: m }) => id == map.id && m.contentEl != map.contentEl
            );
            for (let { map } of otherMaps) {
                map.updateMarker(marker);
            }
        });
    }

    public parseIcon(icon: Icon): MarkerIcon {
        if (!icon.transform) {
            icon.transform = this.data.defaultMarker.transform;
        }
        if (!icon.iconName) {
            icon.iconName = this.data.defaultMarker.iconName;
        }
        const params =
            icon.layer && !this.data.defaultMarker.isImage
                ? {
                      transform: icon.transform,
                      mask: getIcon(this.data.defaultMarker.iconName)
                  }
                : {};
        let node = getMarkerIcon(icon, {
            ...params,
            classes: ["full-width-height"]
        }).node as HTMLElement;
        node.style.color = icon.color
            ? icon.color
            : this.data.defaultMarker.color;
        node.style.opacity = `${
            icon.alpha ?? this.data.defaultMarker.alpha ?? 1
        }`;
        return {
            type: icon.type,
            html: node.outerHTML,
            icon: markerDivIcon({
                html: node.outerHTML,
                className: `leaflet-div-icon`
            }),
            markerIcon: icon
        };
    }

    public generateMarkerMarkup(
        markers: Icon[] = this.data.markerIcons
    ): MarkerIcon[] {
        let ret: MarkerIcon[] = markers.map(
            (marker): MarkerIcon => this.parseIcon(marker)
        );
        const defaultHtml = getMarkerIcon(this.data.defaultMarker, {
            classes: ["full-width-height"],
            styles: {
                color: this.data.defaultMarker.color,
                opacity: `${this.data.defaultMarker.alpha ?? 1}`
            },
            maskId: `leaflet-mask-${getId()}`
        }).html;
        ret.unshift({
            type: "default",
            html: defaultHtml,
            icon: markerDivIcon({
                html: defaultHtml,
                className: `leaflet-div-icon`
            }),
            markerIcon: this.data.defaultMarker
        });

        return ret;
    }

    public async getLocalFileMarkers(
        file: TFile,
        markerFileName = "markers.json"
    ): Promise<MarkerIcon[]> {
        if (!file) return [];
        const markerFilePath = `${file.parent.path}/${markerFileName}`;
        const markerFile = this.app.vault.getAbstractFileByPath(markerFilePath);
        const markers: MarkerIcon[] = [];
        if (markerFile instanceof TFile) {
            const markerJson = await this.app.vault.read(markerFile);
            try {
                const icons = JSON.parse(markerJson);
                markers.push(...icons.map((i: Icon) => this.parseIcon(i)));
            } catch {
                console.error(`Badly formatted marker file ${markerFilePath}`);
            }
        }
        return markers;
    }

    public getIconForTag(tags: Set<string>) {
        return this.data.markerIcons.find((icon) =>
            (
                (icon.tags ?? []).filter((t) =>
                    tags.has(`${t[0] == "#" ? "" : "#"}${t}`)
                ) ?? []
            ).shift()
        )?.type;
    }
    public getIconForType(type: string) {
        return (
            this.data.markerIcons.find((i) => i.type == type) ??
            this.data.defaultMarker
        );
    }
    public createNewMarkerType(options?: {
        original?: Icon;
        layer?: boolean;
        name?: string;
    }): Promise<Icon | void> {
        return new Promise((resolve) => {
            let newMarker: Icon = options?.original ?? {
                type: options?.name ?? "",
                iconName: null,
                color:
                    options?.layer ?? this.data.layerMarkers
                        ? this.data.defaultMarker.color
                        : this.data.color,
                alpha: 1,
                layer: options?.layer ?? this.data.layerMarkers,
                transform: this.data.defaultMarker.transform,
                isImage: false,
                imageUrl: "",
                tags: [],
                minZoom: null,
                maxZoom: null
            };
            let newMarkerModal = new CreateMarkerModal(
                this.app,
                this,
                newMarker
            );
            newMarkerModal.open();
            newMarkerModal.onClose = async () => {
                if (newMarkerModal.saved) resolve(newMarker);
                resolve();
            };
        });
    }

    public async openInitiativeView(
        players?: Creature[],
        creatures?: Creature[]
    ) {
        if (!this.initiativeView) {
            const bool = this.app.workspace
                .getLayout()
                .main.children.filter((c: any) => c?.state?.type != "empty");

            const leaf = this.app.workspace.getLeaf(bool.length > 0);

            await leaf.open(
                new InitiativeMapView(leaf, this, players, creatures)
            );
        } else {
            this.initiativeView.addPlayers(...players);
            this.initiativeView.addCreatures(...creatures);
        }

        if (!this.initiativeView) {
            new Notice("There was an error opening the initiative map view.");
            return;
        }
    }
}



================================================
FILE: src/styles.css
================================================
@import "../node_modules/leaflet/dist/leaflet.css";
@import "./assets/main.css";



================================================
FILE: src/worker.d.ts
================================================
declare module "*.worker.ts" {
    class WebpackWorker extends Worker {
        constructor();
    }
    export = WebpackWorker;
}

declare module "*.png" {
    const PngFile: string;
    export = PngFile;
}


================================================
FILE: src/assets/main.css
================================================
/* Settings */
.icon > .suggestion-flair {
    background-color: unset;
    width: 12px;
    height: 16px;
    font-size: 12px;
    text-align: center;
}

.obsidian-leaflet-settings .coffee {
    border-top: 1px solid var(--background-modifier-border);
    width: 100%;
    color: var(--text-faint);
    padding: 1rem;
    text-align: center;
}
.obsidian-leaflet-settings .coffee img {
    height: 30px;
}

.additional-markers-container > .setting-item:not(.setting-item-heading) {
    border: 0px;
}

.additional-markers-container {
    border-top: 1px solid var(--background-modifier-border);
    padding: 18px 0 0 0;
}

.additional-markers-container > .setting-item-heading:only-child {
    padding-bottom: 18px;
}

.additional-markers-control > input:first-of-type {
    margin-right: auto !important;
}

.additional-markers-container > .additional-markers {
    margin: 6px 12px;
}
.additional-markers-container > .additional-markers > .setting-item {
    border-top: 0;
    padding-top: 9px;
}
.additional-markers-container
    > .additional-markers
    > .setting-item
    > .setting-item-control
    > *:first-child {
    margin: 0 6px;
}

.setting-item-name > .marker-type-display {
    display: flex;
    justify-content: flex-start;
}
.marker-type-display > .marker-icon-display {
    margin-right: 12px;
    font-size: 24px;
    width: 18px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.marker-creation-modal {
    padding-top: 18px;
    display: grid;
    grid-template-columns: 75% 1fr;
    grid-template-rows: 1fr;
    gap: 1rem;
}

.marker-creation-modal .setting-item {
    border-top: none;
}

.marker-creation-modal .icon-display {
    padding: 1rem;
}

.marker-creation-modal .icon-display canvas {
    width: 100%;
}

.markers {
    display: none;
}

.marker-icon-display * {
    margin-right: 0px !important;
}

.marker-icon-display input[type="color"] {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    width: 100%;
    height: 100%;
    margin-right: 12px;
}

.full-width-height,
.full-width-height > * {
    height: 100% !important;
    width: 100% !important;
}

.full-width,
.full-width > * {
    width: 100% !important;
}

/** Invalid Setting */

.leaflet-settings-modal .unset-align-items {
    align-items: unset;
}

.leaflet-settings-modal .has-invalid-message {
    flex-grow: unset;
    flex-flow: column nowrap;
}

.leaflet-settings-modal input.is-invalid {
    border-color: #dc3545 !important;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right calc(0.375em + 0.1875rem) center;
    background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
}

.leaflet-settings-modal .invalid-feedback {
    display: block;
    width: 100%;
    margin-top: 0.25rem;
    font-size: 0.875em;
    color: #dc3545;
}

.block-language-leaflet {
    margin: 0 auto;
}

.block-language-leaflet > .leaflet-container {
    z-index: 0;
    background-color: var(--background-secondary-alt);
}

.block-language-leaflet > .adding-text {
    cursor: text;
}

.block-language-leaflet .leaflet-bar a {
    font-style: unset;
}
.block-language-leaflet .leaflet-bar.disabled {
    cursor: not-allowed;
}
.block-language-leaflet .leaflet-bar.disabled > a {
    background-color: lightgrey;
    pointer-events: none;
}

/* immutable leaflet markers */
/* .leaflet-marker-icon:not(.leaflet-marker-draggable) {
    cursor: not-allowed;
}
 */
/* div icon override */
.block-language-leaflet .leaflet-div-icon img {
    pointer-events: none;
    cursor: pointer;
}

.block-language-leaflet .leaflet-div-icon {
    background: transparent !important;
    border: none !important;
    width: 25px !important;
    height: 25px !important;
    margin-left: -12.5px !important;
    margin-top: -25px !important;
}

.block-language-leaflet .leaflet-marker-link-tooltip {
    box-shadow: 0 2px 8px var(--background-modifier-box-shadow) !important;
    background-color: rgba(0, 0, 0, 0.9) !important;
    border: 1px solid rgba(0, 0, 0, 0.9) !important;
    border-radius: 6px !important;
    color: #dcddde !important;
    font-size: 14px !important;
    left: 50% !important;
    line-height: 20px !important;
    width: auto !important;
    padding: 5px 14px !important;
    /* pointer-events: none !important; */
    opacity: unset !important;
}

.block-language-leaflet .leaflet-marker-link-popup > * {
    animation: leaflet-pop-down 200ms forwards ease-in-out;
}

@keyframes leaflet-pop-down {
    0% {
        opacity: 0;
        transform: scale(1);
    }

    20% {
        opacity: 0.7;
        transform: scale(1.02);
    }
    40% {
        opacity: 1;
        transform: scale(1.05);
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

.block-language-leaflet
    .leaflet-marker-link-popup
    > .leaflet-popup-content-wrapper {
    background-color: rgba(0, 0, 0, 0.9) !important;
    color: #dcddde !important;
    padding: 5px 14px !important;
    border-radius: 6px !important;
    line-height: 20px !important;
}
.block-language-leaflet
    .leaflet-marker-link-popup
    > .leaflet-popup-content-wrapper
    > * {
    margin: 0;
    font-size: 14px;
    text-align: center;
}
.block-language-leaflet .leaflet-marker-link-popup .leaflet-popup-tip {
    background-color: rgba(0, 0, 0, 0.9) !important;
    width: 12px;
    height: 12px;
}

.block-language-leaflet .leaflet-marker-link-tooltip::before {
    border-top-color: rgba(0, 0, 0, 0.9) !important;
}

.block-language-leaflet
    .leaflet-control-layers:not(.leaflet-control-layers-expanded)
    .leaflet-control-layers-toggle {
    background-image: unset !important;
    display: flex !important;
}
.block-language-leaflet
    .leaflet-control-layers:not(.leaflet-control-layers-expanded) {
    width: unset;
    height: unset;
}
.block-language-leaflet .leaflet-control-layers-toggle {
    width: 30px !important;
    height: 30px !important;
}

.block-language-leaflet
    .leaflet-control-layers
    .leaflet-control-layers-selector {
    appearance: auto;
}

.block-language-leaflet .leaflet-control.disabled {
    pointer-events: hover;
}

.block-language-leaflet .leaflet-distance-control {
    background-color: #fff;
    border-radius: 2px;
    min-width: 30px;
    width: auto;
    height: 30px;
    padding: 5px;
    cursor: pointer !important;
}

.block-language-leaflet .leaflet-control-draw-paint-icon > svg {
    stroke: black;
    stroke-width: 25;
}
.block-language-leaflet .leaflet-control-draw-palette {
    position: relative;
}
.block-language-leaflet .leaflet-control input[type="color"] {
    visibility: hidden;
    position: absolute;
    top: 0;
    left: 0;
}
.leaflet-file-upload > input[type="file"] {
    display: none;
}

/** Bulk Marker Edit Settings */
.bulk-setting-hover:not(.marker) {
    box-shadow: 0 0px 8px var(--background-modifier-box-shadow) !important;
}
.bulk-setting-hover.marker::before {
    content: "";
    width: 120%;
    height: 120%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 100%;
    border: 3px solid #00ff00 !important;
}
/* .bulk-edit-markers {
    width: 675px;
} */
.bulk-edit-markers .setting-item,
.bulk-edit-markers > .setting-item-control {
    padding: 8px 2px;
    margin: 0 8px;
}
.bulk-edit-markers > .setting-item:first-child button {
    margin-right: 0;
}
.bulk-edit-markers-holder {
    height: 250px;
    overflow-y: auto;
}
.bulk-edit-markers-holder::-webkit-scrollbar {
    width: 2px !important;
}
.bulk-edit-marker-instance .setting-item-control {
    display: flex;
    flex-flow: row wrap;
    justify-content: space-between;
}
.bulk-edit-marker-instance .setting-item-control > *:not(:last-child) {
    margin-right: 0.5rem;
}

.block-language-leaflet .leaflet-container .dark-mode {
    filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg)
        saturate(0.3) brightness(0.7);
}

.block-language-leaflet .leaflet-container.drawing {
    cursor: crosshair;
}
.block-language-leaflet
    .leaflet-container.shape-dragging
    .leaflet-drawing-pane
    path {
    cursor: move;
}

.block-language-leaflet .leaflet-div-icon.initiative-marker-disabled {
    opacity: 50%;
}
.block-language-leaflet .leaflet-div-icon.initiative-marker-active svg {
    filter: drop-shadow(0 0 3px green);
}
.block-language-leaflet .leaflet-div-icon progress {
    width: 100%;
    top: 95%;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.block-language-leaflet .leaflet-div-icon .initiative-marker-status-container {
    position: absolute;
    top: -6px;
    right: -15px;
    display: flex;
    flex-flow: column wrap;
    justify-content: center;
    align-items: center;
    height: 46px;
    gap: 2px;
}
.block-language-leaflet
    .leaflet-div-icon
    .initiative-marker-status-container
    svg {
    height: 10px;
}
.block-language-leaflet
    .leaflet-div-icon
    .initiative-marker-status-container
    svg
    > * {
    stroke-width: 20px;
    stroke: white;
}

/** Filter Control */
.block-language-leaflet .leaflet-control-expandable {
    background: #fff;
}
.block-language-leaflet
    .leaflet-control-expandable:not(.expanded)
    > .leaflet-control-expandable-list {
    display: none;
}
.block-language-leaflet
    .leaflet-control-expandable.expanded
    > .leaflet-control-expandable-icon {
    display: none;
}
.block-language-leaflet .leaflet-control-expandable .task-list-item > * {
    cursor: pointer;
}

.block-language-leaflet .leaflet-control-expandable .input-container {
    margin: 0;
}
.block-language-leaflet .leaflet-control-expandable.expanded .input-container {
    padding: 6px 10px 6px 6px;
    margin: 0;
}

.block-language-leaflet .leaflet-control-expandable-list .input-item {
    display: flex;
    justify-content: flex-start;
    align-items: center;
}

.block-language-leaflet .leaflet-control-expandable input[type="radio"] {
    margin-top: 0;
}

.block-language-leaflet
    .leaflet-control-expandable-list
    .input-container
    .input-item
    > input {
    top: 0px;
    appearance: auto;
}
.block-language-leaflet
    .leaflet-control-expandable-list
    .input-container
    .input-item
    > label {
    display: flex;
    align-items: center;
    justify-content: flex-start;
}
.block-language-leaflet
    .leaflet-control-expandable-list
    .input-container
    .input-item
    .leaflet-control-expandable-icon {
    width: 18px;
    height: 18px;
    margin-right: 4px;
}
.block-language-leaflet
    .leaflet-control-expandable-list
    .leaflet-control-expandable-button-group {
    margin-bottom: 6px;
    padding: 6px 10px 0px 6px;
}
.block-language-leaflet
    .leaflet-control-expandable-list
    .leaflet-control-expandable-button-group
    button:last-child {
    margin-right: 0px;
}

.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-gpx
    .gpx-data {
    padding: 6px 10px 6px 6px;
    border-bottom: 1px solid var(--background-modifier-border);
}
.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-gpx
    .input-container {
    border-bottom: 1px solid var(--background-modifier-border);
}
.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-gpx
    .control-buttons {
    display: flex;
    justify-content: space-evenly;
    margin: 0.25rem;
}

.block-language-leaflet .leaflet-control-gpx .gpx-elevation {
    display: flex;
    justify-content: space-around;
}
.block-language-leaflet .gpx-elevation .elevation-gain {
    color: green;
}
.block-language-leaflet .gpx-elevation .elevation-loss {
    color: red;
}

.gpx-popup {
    display: flex;
    flex-flow: column;
    justify-content: flex-start;
    align-items: flex-start;
}
.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-draw.expanded
    .leaflet-control-expandable-list {
    display: flex;
    flex-flow: column nowrap;
}

.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-draw.expanded
    .leaflet-control-expandable-list
    .leaflet-control,
.block-language-leaflet .leaflet-control-draw a {
    margin: 0;
    border: 0;
}
.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-draw.expanded
    a {
    margin-right: 0;
}

.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-draw.expanded
    .leaflet-control-expandable-list
    .leaflet-control.leaflet-control-draw-trash,
.block-language-leaflet
    .leaflet-control-expandable.leaflet-control-draw.expanded
    .leaflet-control-expandable-list
    .leaflet-control.leaflet-control-draw-paint {
    border-top: 2px solid rgba(0, 0, 0, 0.2);
    border-top-left-radius: 0;
    border-top-right-radius: 0;
}
.block-language-leaflet .leaflet-control-has-actions {
    position: relative;
}

.block-language-leaflet .leaflet-control-has-actions .control-actions.expanded {
    display: flex;
    background-color: white;
}
.block-language-leaflet .leaflet-control-has-actions .control-actions {
    display: none;
    position: absolute;
    top: -1px;
    right: 100%;
    border: 1px solid #ccc;
    border-top-left-radius: 2px;
    border-bottom-left-radius: 2px;
}

.block-language-leaflet
    .leaflet-control-has-actions
    .control-actions
    .leaflet-control
    a {
    border-radius: 0;
}

.block-language-leaflet .leaflet-control-arrow.active,
.block-language-leaflet .leaflet-control-fill-color.active {
    background-color: #3388ff;
    color: white;
    border-radius: 0;
}
.block-language-leaflet .leaflet-control-arrow.active a,
.block-language-leaflet .leaflet-control-fill-color.active a {
    background-color: transparent;
    color: white;
}

.block-language-leaflet .leaflet-div-icon.leaflet-middle-icon,
.block-language-leaflet .leaflet-div-icon.leaflet-vertex-icon {
    border-radius: 100%;
    width: 12px !important;
    height: 12px !important;
    border: 1px solid rgb(204, 204, 204) !important;
    background-color: white !important;
    margin-top: -6px !important;
    margin-left: -6px !important;
    display: block;
}

.block-language-leaflet .leaflet-div-icon.leaflet-middle-icon {
    width: 10px !important;
    height: 10px !important;
    margin-top: -5px !important;
    margin-left: -5px !important;
}

.block-language-leaflet .leaflet-text-entry {
    position: relative;
    width: max-content;
}
.block-language-leaflet .leaflet-text-entry input {
    outline: none;
    position: absolute;
    transform: translate(-50%, 0%);
    left: 50%;
    text-align: center;
    background-color: transparent;
    border: 0;
}
.block-language-leaflet .leaflet-text-entry span {
    width: fit-content;
}

.block-language-leaflet .leaflet-pane.leaflet-geojson-pane {
    z-index: 398;
}
.block-language-leaflet .leaflet-pane.leaflet-image-overlay-pane {
    z-index: 397;
}
.block-language-leaflet .leaflet-pane.leaflet-gpx-pane {
    z-index: 405;
}
.block-language-leaflet .leaflet-pane.leaflet-gpx-canvas-pane {
    z-index: 301;
}
.block-language-leaflet .leaflet-pane.leaflet-base-layer-pane {
    z-index: 300;
}

.hidden-leaflet-popup {
    display: none;
    visibility: hidden;
}
/* 
.block-language-leaflet .leaflet-control-fullscreen a {
    background-image: unset;
} */

.block-language-leaflet .leaflet-control-layers-toggle {
    background-image: unset !important;
}
.block-language-leaflet .leaflet-retina .leaflet-control-layers-toggle {
    background-image: unset !important;
}
.block-language-leaflet .leaflet-default-icon-path {
    background-image: unset !important;
}

.leaflet-layer-targeted {
    filter: drop-shadow(0 0 3px green);
}

.leaflet-edit-parameters .context-buttons {
    display: flex;
    justify-content: flex-end;
    align-items: center;
}

.block-language-leaflet .leaflet-pm-toolbar .button-container {
    margin-top: unset;
}

.leaflet-marker-icon svg {
    filter: drop-shadow(1px 3px 3px black);
}



================================================
FILE: src/controls/controls.ts
================================================
import { icon } from "../utils/icons";
import { IconName } from "@fortawesome/free-solid-svg-icons";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { Events } from "obsidian";

const L = window[LeafletSymbol];

export interface FontAwesomeControlOptions extends L.ControlOptions {
    icon: IconName;
    cls: string;
    tooltip?: string;
}
export abstract class FontAwesomeControl extends L.Control {
    icon: IconName;
    controlEl: HTMLElement;
    cls: string;
    tooltip: string;
    leafletInstance: L.Map;
    enabled: boolean = true;
    iconEl: HTMLAnchorElement;
    constructor(opts: FontAwesomeControlOptions, leafletMap: L.Map) {
        super(opts);
        this.leafletInstance = leafletMap;
        this.icon = opts.icon;
        this.cls = opts.cls;
        this.tooltip = opts.tooltip;
        this.controlEl = L.DomUtil.create(
            "div",
            "leaflet-bar leaflet-control " + this.cls
        );
        this.controlEl.removeAttribute("title");
        this.iconEl = this.controlEl.createEl("a", {
            cls: this.cls + "-icon",
            href: "#"
        });
        this.iconEl.appendChild(
            icon({ prefix: "fas", iconName: this.icon }).node[0]
        );
        if (this.tooltip) {
            this.controlEl.children[0].setAttrs({
                "aria-label": this.tooltip
            });
        }
        L.DomEvent.on(this.controlEl, "click", (evt: MouseEvent) =>
            this.onClick(evt)
        );
    }
    onAdd(leafletMap: L.Map) {
        this.leafletInstance = leafletMap;

        L.DomEvent.disableClickPropagation(this.controlEl);
        L.DomEvent.disableScrollPropagation(this.controlEl);

        this.added();

        return this.controlEl;
    }
    abstract onClick(evt: MouseEvent): void;
    added() {}
    disable() {
        if (!this.enabled) return;
        this.controlEl.addClass("disabled");
        this.enabled = false;
    }
    enable() {
        if (this.enabled) return;
        this.controlEl.removeClass("disabled");
        this.enabled = true;
    }
    setTooltip(tooltip: string) {
        this.tooltip = tooltip;
        this.controlEl.children[0].setAttrs({
            "aria-label": this.tooltip
        });
    }
    removeTooltip() {
        this.tooltip = null;
        this.controlEl.children[0].removeAttribute("aria-label");
    }
    setIcon(name: IconName) {
        this.iconEl.empty();
        this.icon = name;
        this.iconEl.appendChild(
            icon({ prefix: "fas", iconName: this.icon }).node[0]
        );
    }
}



================================================
FILE: src/controls/distance.ts
================================================
import { BaseMapType, Popup } from "../types";
import { popup } from "src/map/popup";
import { LAT_LONG_DECIMALS } from "src/utils";

import { LeafletSymbol } from "src/utils/leaflet-import";

const L = window[LeafletSymbol];

class DistanceDisplay extends L.Control {
    controlEl: HTMLElement;
    get lines() {
        return this.map.previousDistanceLines;
    }
    popups: Popup[] = [];
    textEl: HTMLSpanElement;
    getPopup() {
        return popup(this.map, null, {
            permanent: true,
            className: "leaflet-marker-link-popup",
            autoClose: false,
            closeButton: false,
            closeOnClick: false,
            autoPan: false
        });
    }
    constructor(opts: L.ControlOptions, public map: BaseMapType) {
        super(opts);
    }
    initEvents() {
        this.controlEl.onmouseenter = this.onMouseEnter.bind(this);
        this.controlEl.onclick = this.onClick.bind(this);
        this.controlEl.onmouseleave = this.onMouseLeave.bind(this);
    }
    onMouseEnter() {
        if (this.lines.length) {
            const latlng = this.lines[0].getLatLngs()[0] as L.LatLng;
            const start = this.getPopup().setTarget(
                this.lines[0].getLatLngs()[0] as L.LatLng
            );
            start.open(
                `[${latlng.lat.toLocaleString("en-US", {
                    maximumFractionDigits: LAT_LONG_DECIMALS
                })}, ${latlng.lng.toLocaleString("en-US", {
                    maximumFractionDigits: LAT_LONG_DECIMALS
                })}]`
            );
            this.popups.push(start);
            this.map.leafletInstance.openPopup(start.leafletInstance);

            for (let i = 0; i < this.lines.length; i++) {
                const line = this.lines[i];
                const latlngs = line.getLatLngs() as L.LatLng[];

                const display = this.map.distanceAlongPolylines(
                    this.lines.slice(0, i + 1)
                );
                const segment = this.map.distanceAlongPolylines([line]);

                const popup = this.getPopup().setTarget(latlngs[1]);
                const element = createDiv();
                element.createSpan({ text: `${display} (${segment})` });
                element.createEl("br");
                element.createSpan({
                    text: ` [${latlngs[1].lat.toLocaleString("en-US", {
                        maximumFractionDigits: LAT_LONG_DECIMALS
                    })}, ${latlngs[1].lng.toLocaleString("en-US", {
                        maximumFractionDigits: LAT_LONG_DECIMALS
                    })}]`
                });
                popup.open(element);
                this.map.leafletInstance.openPopup(popup.leafletInstance);
                this.popups.push(popup);

                line.setStyle({ color: "blue", dashArray: "4 1" });
                line.addTo(this.map.leafletInstance);
            }
        }
    }
    onClick(evt: MouseEvent) {
        evt.stopPropagation();
        evt.preventDefault();

        if (this.lines.length) {
            const group = new L.FeatureGroup();
            for (const line of this.lines) {
                new L.Polyline([
                    line.getLatLngs()[0] as L.LatLng,
                    line.getLatLngs()[1] as L.LatLng
                ]).addTo(group);
            }
            this.map.leafletInstance.fitBounds(group.getBounds(), {
                duration: 0.5,
                easeLinearity: 0.1,
                animate: true,
                padding: [5, 5]
            });
        }
    }
    onMouseLeave() {
        if (this.lines) {
            for (const line of this.lines) {
                line.remove();
            }
        }
        for (const popup of this.popups) {
            this.map.leafletInstance.closePopup(popup.leafletInstance);
        }
        this.popups = [];
    }
    onAdd() {
        /* this.map = map; */
        this.controlEl = L.DomUtil.create(
            "div",
            "leaflet-bar leaflet-distance-control"
        );
        this.textEl = this.controlEl.createSpan();
        this.textEl.setText(`0 ${this.map.unit}`);

        this.initEvents();

        return this.controlEl;
    }
    setText(text: string) {
        this.textEl.setText(text);
        return this;
    }
}
export const distanceDisplay = function (
    opts: L.ControlOptions,
    map: BaseMapType
) {
    return new DistanceDisplay(opts, map);
};



================================================
FILE: src/controls/filter.ts
================================================
import type { BaseMapType } from "../types";
import { getId } from "src/utils";
import { FontAwesomeControl, FontAwesomeControlOptions } from "./controls";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { Platform } from "obsidian";
import t from "src/l10n/locale";

const L = window[LeafletSymbol];
export class FilterMarkers extends FontAwesomeControl {
    map: BaseMapType;
    section: HTMLElement;
    inputs: Map<string, HTMLInputElement>;
    expanded: boolean;
    drawn: boolean;
    constructor(opts: FontAwesomeControlOptions, map: BaseMapType) {
        super(opts, map.leafletInstance);
        this.map = map;
        this.map.on("markers-updated", () => {
            if (this.map.markers.length || this.map.overlays.length) {
                this.enable();
            } else {
                this.disable();
            }
        });
    }
    onClick(evt: MouseEvent) {
        this.expand();
    }
    added() {
        //add hidden filter objects

        this.section = this.controlEl.createEl("section", {
            cls: this.cls + "-list"
        });

        L.DomEvent.disableClickPropagation(this.controlEl);
        L.DomEvent.disableScrollPropagation(this.controlEl);

        this.iconEl.dataset["draggable"] = "false";

        this.map.leafletInstance.on("click", this.collapse, this);

        L.DomEvent.on(this.controlEl, "mouseenter", () => this.expand());
        L.DomEvent.on(this.controlEl, "mouseleave", () => this.collapse());

        if (Platform.isMobile) {
            L.DomEvent.on(this.controlEl, "click", this.expand, this);
        } else {
            L.DomEvent.on(this.controlEl, "focus", this.expand, this);
        }
    }
    private expand() {
        if (!this.enabled) {
            return;
        }
        if (this.expanded) {
            return;
        }
        this.expanded = true;
        L.DomUtil.addClass(this.controlEl, "expanded");
        this.draw();

        this.section.style.height = null;
        const acceptableHeight =
            this.leafletInstance.getSize().y - (this.controlEl.offsetTop + 50);

        if (acceptableHeight < this.section.clientHeight) {
            L.DomUtil.addClass(
                this.section,
                "leaflet-control-layers-scrollbar"
            );
            this.section.style.height = acceptableHeight + "px";
        } else {
            L.DomUtil.removeClass(
                this.section,
                "leaflet-control-layers-scrollbar"
            );
        }

        return this;
    }

    private collapse() {
        L.DomUtil.removeClass(this.controlEl, "expanded");
        this.expanded = false;
        return this;
    }
    private draw() {
        this.section.empty();
        this.inputs = new Map();
        const buttons = this.section.createDiv(
            "leaflet-control-expandable-button-group"
        );
        buttons.createEl("button", { text: t("All") }).onclick = (evt) => {
            evt.stopPropagation();
            this.map.markerIcons.forEach(({ type }) => {
                this.show(type);
            });
            this.update();
        };
        buttons.createEl("button", { text: t("None") }).onclick = (evt) => {
            evt.stopPropagation();
            this.map.markerIcons.forEach(({ type }) => {
                this.hide(type);
            });
            this.update();
        };

        const ul = this.section.createEl("div", "input-container");

        for (let [type, markerIcon] of this.map.markerIcons.entries()) {
            if (
                this.map.currentGroup.markers[type] &&
                this.map.currentGroup.markers[type].getLayers().length
            ) {
                const li = ul.createEl("div", "input-item");

                const id = getId();
                const input = li.createEl("input", {
                    attr: {
                        id: "leaflet-control-expandable-item-label-" + id,
                        ...(this.map.displaying.get(type)
                            ? { checked: true }
                            : {})
                    },
                    type: "checkbox"
                });

                const label = li.createEl("label", {
                    attr: { for: "leaflet-control-expandable-item-label-" + id }
                });
                label.createDiv({
                    cls: "leaflet-control-expandable-icon"
                }).innerHTML = markerIcon.html;

                label.createDiv({
                    text: type[0].toUpperCase() + type.slice(1).toLowerCase()
                });

                input.addEventListener("click", (evt) => {
                    if (input.checked) {
                        this.show(type);
                    } else if (this.map.displaying.get(type)) {
                        this.hide(type);
                    }

                    this.map.displaying.set(type, input.checked);
                });

                this.inputs.set(type, input);
            }
        }

        if (
            this.map.currentGroup.markers.custom &&
            this.map.currentGroup.markers.custom.getLayers()?.length
        ) {
            const li = ul.createEl("div", "input-item");

            const id = getId();
            const input = li.createEl("input", {
                attr: {
                    id: "leaflet-control-expandable-item-label-" + id,
                    ...(this.map.displaying.get("custom")
                        ? { checked: true }
                        : {})
                },
                type: "checkbox"
            });

            const label = li.createEl("label", {
                attr: { for: "leaflet-control-expandable-item-label-" + id }
            });

            label.createDiv({
                text: "Custom"
            });

            input.addEventListener("click", (evt) => {
                if (input.checked) {
                    this.show("custom");
                } else if (this.map.displaying.get("custom")) {
                    this.hide("custom");
                }

                this.map.displaying.set("custom", input.checked);
            });

            this.inputs.set("custom", input);
        }
    }
    private update() {
        for (let [type, input] of this.inputs) {
            input.checked = this.map.displaying.get(type);
        }
    }

    private show(type: string) {
        this.map.currentGroup.markers[type].addTo(this.leafletInstance);
        this.map.overlays
            .filter((o) => o.type === type)
            .forEach((o) =>
                o.leafletInstance.addTo(this.map.currentGroup.group)
            );

        this.map.sortOverlays();
        this.map.displaying.set(type, true);
    }
    private hide(type: string) {
        this.map.currentGroup.markers[type].remove();
        this.map.overlays
            .filter((o) => o.type === type)
            .forEach((o) => o.leafletInstance.remove());
        this.map.displaying.set(type, false);
    }
}

export function filterMarkerControl(opts: L.ControlOptions, map: BaseMapType) {
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon: "filter",
        cls: "leaflet-control-expandable",
        tooltip: t("Filter Markers")
    };
    return new FilterMarkers(options, map);
}



================================================
FILE: src/controls/gpx.ts
================================================
import { BaseMapType } from "../types";
import { GPX } from "src/layer";
import { FontAwesomeControl, FontAwesomeControlOptions } from "./controls";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { ExtraButtonComponent } from "obsidian";
import { BULLSEYE, formatNumber, getIcon, icon } from "src/utils";
import t from "src/l10n/locale";
import convert from "convert";
const L = window[LeafletSymbol];
class GPXControl extends FontAwesomeControl {
    target: GPX;
    expanded: boolean;
    section: HTMLElement;
    constructor(opts: FontAwesomeControlOptions, private map: BaseMapType) {
        super(opts, map.leafletInstance);
    }
    onClick(evt: MouseEvent) {
        if (!this.target)
            this.map.leafletInstance.fitBounds(this.map.gpxLayer.getBounds());
    }
    added() {
        //add hidden filter objects

        this.controlEl.addClass("leaflet-control-gpx");
        this.section = this.controlEl.createEl("section", {
            cls: this.cls + "-list"
        });

        L.DomEvent.disableClickPropagation(this.controlEl);
        L.DomEvent.disableScrollPropagation(this.controlEl);

        this.iconEl.dataset["draggable"] = "false";
    }
    setTarget(gpx: GPX) {
        if (this.target) this.removeTarget();
        this.target = gpx;
        this.target.targeted = true;
        this.removeTooltip();
        this.expand();
    }
    removeTarget() {
        this.target.deselect();
        this.target = null;
        this.collapse();
        this.setTooltip(
            t(
                `Zoom to %1 GPX Track%2`,
                `${this.map.gpxData.length}`,
                this.map.gpxData.length == 1 ? "" : "s"
            )
        );
    }
    expand() {
        if (!this.target) return;
        if (!this.target.parsed) return;
        this.expanded = true;
        L.DomUtil.addClass(this.controlEl, "expanded");
        this.draw();

        this.section.style.height = null;
        const acceptableHeight =
            this.leafletInstance.getSize().y - (this.controlEl.offsetTop + 50);

        if (acceptableHeight < this.section.clientHeight) {
            L.DomUtil.addClass(
                this.section,
                "leaflet-control-layers-scrollbar"
            );
            this.section.style.height = acceptableHeight + "px";
        } else {
            L.DomUtil.removeClass(
                this.section,
                "leaflet-control-layers-scrollbar"
            );
        }

        return this;
    }
    private collapse() {
        L.DomUtil.removeClass(this.controlEl, "expanded");
        this.expanded = false;
        return this;
    }
    private draw() {
        this.section.empty();

        let data: HTMLElement;
        let ul: HTMLElement;

        let heatLines = false;

        const addHeatlineDiv = () => {
            if (heatLines) return;
            heatLines = true;
            data = this.section.createDiv("gpx-data");

            ul = this.section.createEl("div", "input-container");
            ul.createSpan({
                text: t("Heatlines")
            });
        };

        const unit =
            this.map.plugin.unitSystemForUnit(this.map.unit) === "imperial"
                ? "mi"
                : "km";

        if (this.target.data.length) {
            addHeatlineDiv();
            data.createDiv("data-item").createSpan({
                text: `Distance: ${formatNumber(
                    convert(this.target.data.length).from("m").to(unit),
                    2
                )}${unit}`
            });
        }

        if (this.target.flags.elevation) {
            addHeatlineDiv();

            const elevationEl = data.createDiv("data-item");

            const unit =
                this.map.plugin.unitSystemForUnit(this.map.unit) === "imperial"
                    ? "ft"
                    : "m";

            elevationEl.createSpan({ text: `${t("Elevation")}:` });
            const gainLoss = elevationEl.createDiv("gpx-elevation");

            const gain = convert(this.target.elevation.max).from("m").to(unit);
            const gainEl = gainLoss.createDiv("elevation-gain");
            gainEl.appendChild(icon(getIcon("angle-up")).node[0]);
            gainEl.createSpan({
                text: `${formatNumber(gain, 0)}${unit}`
            });
            const loss = convert(this.target.elevation.min).from("m").to(unit);
            const lossEl = gainLoss.createDiv("elevation-loss");
            lossEl.appendChild(icon(getIcon("angle-down")).node[0]);
            lossEl.createSpan({
                text: `${formatNumber(loss, 0)}${unit}`
            });

            const li = ul.createDiv("input-item");
            const input = li.createEl("input", {
                attr: {
                    id: "leaflet-gpx-control-ele",
                    "data-which": "ele",
                    name: "leaflet-gpx-control-checkbox-group",
                    ...(this.target.displaying == "ele"
                        ? { checked: true }
                        : {})
                },
                type: "checkbox"
            });
            li.createEl("label", {
                attr: { for: "leaflet-gpx-control-ele" },
                text: t("Elevation")
            });

            input.onclick = (evt) => {
                this.trySwitch("ele");
            };
        }
        if (this.target.data.flags.speed) {
            addHeatlineDiv();

            let speed = this.target.speed.avg,
                unit: string,
                pace: string;
            switch (this.map.plugin.unitSystemForUnit(this.map.unit)) {
                case "metric": {
                    //kmh
                    speed = convert(speed).from("m").to("km") * 60 * 60;
                    unit = "km/h";
                    pace = "km";
                    break;
                }
                case "imperial": {
                    //mph
                    speed = convert(speed).from("m").to("mi") * 60 * 60;
                    unit = "mph";
                    pace = "mi";
                    break;
                }
            }

            data.createDiv("data-item").createSpan({
                text: `${t("Speed")}: ${formatNumber(speed, 0)} ${unit}`
            });
            data.createDiv("data-item").createSpan({
                text: `${t("Pace")}: ${formatNumber(60 / speed, 0)}"/${pace}`
            });

            const li = ul.createDiv("input-item");
            const input = li.createEl("input", {
                attr: {
                    id: "leaflet-gpx-control-speed",
                    "data-which": "speed",
                    name: "leaflet-gpx-control-checkbox-group",
                    ...(this.target.displaying == "speed"
                        ? { checked: true }
                        : {})
                },
                type: "checkbox"
            });
            li.createEl("label", {
                attr: { for: "leaflet-gpx-control-speed" },
                text: t("Speed")
            });

            input.onclick = (evt) => {
                this.trySwitch("speed");
            };
        }
        if (this.target.flags.cad) {
            addHeatlineDiv();

            data.createDiv("data-item").createSpan({
                text: `${t("Cadence")}: ${this.target.cad.avg} ${t("spm")}`
            });
            const li = ul.createDiv("input-item");
            const input = li.createEl("input", {
                attr: {
                    id: "leaflet-gpx-control-cad",
                    "data-which": "cad",
                    name: "leaflet-gpx-control-checkbox-group",
                    ...(this.target.displaying == "cad"
                        ? { checked: true }
                        : {})
                },
                type: "checkbox"
            });
            li.createEl("label", {
                attr: { for: "leaflet-gpx-control-cad" },
                text: t("Cadence")
            });

            input.onclick = (evt) => {
                this.trySwitch("cad");
            };
        }

        if (this.target.flags.hr) {
            if (!heatLines) {
            }
            data.createDiv("data-item").createSpan({
                text: `${t("Heart Rate")}: ${this.target.hr.avg}`
            });
            const li = ul.createDiv("input-item");
            const input = li.createEl("input", {
                attr: {
                    id: "leaflet-gpx-control-hr",
                    "data-which": "hr",
                    name: "leaflet-gpx-control-checkbox-group",
                    ...(this.target.displaying == "hr" ? { checked: true } : {})
                },
                type: "checkbox"
            });
            li.createEl("label", {
                attr: { for: "leaflet-gpx-control-hr" },
                text: t("Heart Rate")
            });

            input.onclick = (evt) => {
                this.trySwitch("hr");
            };
        }

        const buttons = this.section.createDiv("control-buttons");
        new ExtraButtonComponent(buttons)
            .setIcon(BULLSEYE)
            .setTooltip(t("Zoom to GPX"))
            .onClick(() => {
                this.map.leafletInstance.fitBounds(
                    this.target.leafletInstance.getBounds()
                );
            });
        new ExtraButtonComponent(buttons)
            .setIcon("cross-in-box")
            .setTooltip(t("Deselect"))
            .onClick(() => {
                this.removeTarget();
            });
    }
    trySwitch(str: "hr" | "cad" | "speed" | "ele") {
        if (this.target.displaying === str) {
            this.target.switch("default");
        } else {
            this.target.switch(str);
        }
        this.draw();
    }
}

export function gpxControl(opts: L.ControlOptions, map: BaseMapType) {
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon: "running",
        cls: "leaflet-control-expandable",
        tooltip: t(
            `Zoom to %1 GPX Track%2`,
            `${map.gpxData.length}`,
            map.gpxData.length == 1 ? "" : "s"
        )
    };
    return new GPXControl(options, map);
}



================================================
FILE: src/controls/index.ts
================================================
export { distanceDisplay } from "./distance";
export { filterMarkerControl } from "./filter";
export { resetZoomControl } from './reset';
export { zoomControl } from './zoom';


================================================
FILE: src/controls/layers.ts
================================================
import { icon } from "src/utils";
import { LeafletSymbol } from "src/utils/leaflet-import";
import type { GPX } from "src/layer";
import type { GeoJSON } from "../layer/geojson";

const L = window[LeafletSymbol];

declare module "leaflet" {
    interface Control {
        _separator: HTMLElement;
    }
}

export default class LayerControl extends L.Control.Layers {
    geojsonAdded: boolean = false;
    gpxAdded: boolean = false;
    container: HTMLElement;
    constructor() {
        super({}, {});
    }
    onAdd(map: L.Map) {
        const container = super.onAdd(map);
        /* this.container = container; */
        const layerIcon = icon({ iconName: "layer-group", prefix: "fas" })
            .node[0];
        layerIcon.setAttr(`style`, "color: var(--text-normal);margin: auto;");
        container.children[0].appendChild(layerIcon);

        return container;
    }
    addGeoJSON(layer: GeoJSON) {
        if (!this.geojsonAdded) {
            this.container.appendChild(this._separator.cloneNode(true));
        }
    }
    addGPX(layer: GPX) {}
}



================================================
FILE: src/controls/lock.ts
================================================
import { BaseMapType } from "../types";
import { FontAwesomeControl, FontAwesomeControlOptions } from "./controls";

export class LockControl extends FontAwesomeControl {
    map: BaseMapType;
    constructor(opts: FontAwesomeControlOptions, map: BaseMapType) {
        super(opts, map.leafletInstance);
        this.map = map;
    }
    onClick(evt: MouseEvent) {
        this.map.options.lock = !this.map.options.lock;
        this.setState(this.map.options.lock);
        this.map.trigger("lock");
        this.map.trigger("should-save");
    }
    setState(state: boolean) {
        if (!state) {
            this.setIcon("unlock");
            this.setTooltip("Lock Map");
        } else {
            this.setIcon("lock");
            this.setTooltip("Unlock Map");
        }
    }
}

export function lockControl(opts: L.ControlOptions, map: BaseMapType) {
    const icon = map.options.lock ? "lock" : "unlock";
    const tooltip = map.options.lock ? "Unlock Map" : "Lock Map";
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon,
        cls: "leaflet-control-lock",
        tooltip
    };
    return new LockControl(options, map);
}



================================================
FILE: src/controls/mapview.ts
================================================
import { BaseMapType } from "../types";
import t from "src/l10n/locale";
import { EditParametersModal } from "src/modals/mapview";
import { FontAwesomeControl, FontAwesomeControlOptions } from "./controls";

class MapViewControl extends FontAwesomeControl {
    map: BaseMapType;
    constructor(opts: FontAwesomeControlOptions, map: BaseMapType) {
        super(opts, map.leafletInstance);
        this.map = map;
    }
    onClick(evt: MouseEvent) {
        const modal = new EditParametersModal(this.map.plugin);
        modal.onClose = () => {};
        modal.open();
    }
}

export function mapViewControl(opts: L.ControlOptions, map: BaseMapType) {
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon: "edit",
        cls: "leaflet-control-edit-parameters",
        tooltip: t("Edit View Parameters")
    };
    return new MapViewControl(options, map);
}
class SaveMapParametersControl extends FontAwesomeControl {
    map: BaseMapType;
    constructor(opts: FontAwesomeControlOptions, map: BaseMapType) {
        super(opts, map.leafletInstance);
        this.map = map;
    }
    async onClick(evt: MouseEvent) {
        this.map.plugin.data.mapViewParameters = this.map.renderer.params;

        this.map.trigger('should-save');
    }
}

export function saveMapParametersControl(
    opts: L.ControlOptions,
    map: BaseMapType
) {
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon: "save",
        cls: "leaflet-control-save-param",
        tooltip: t("Save Parameters to View")
    };
    return new SaveMapParametersControl(options, map);
}



================================================
FILE: src/controls/reset.ts
================================================
import { Map } from "leaflet";
import { BaseMapType } from "../types";
import t from "src/l10n/locale";
import { FontAwesomeControl, FontAwesomeControlOptions } from "./controls";

class ResetZoomControl extends FontAwesomeControl {
    map: BaseMapType;
    constructor(opts: FontAwesomeControlOptions, map: BaseMapType) {
        super(opts, map.leafletInstance);
        this.map = map;
        this.map.leafletInstance.on("zoomend zoom zoomstart", () => {
            this.controlEl.setAttr(
                "aria-label",
                `Reset Zoom\nCurrent: ${this.map.leafletInstance.getZoom()}`
            );
        });
    }
    onAdd(leafletMap: Map): HTMLElement {
        this.controlEl.setAttr(
            "aria-label",
            `Reset Zoom\nCurrent: ${this.map.leafletInstance.getZoom()}`
        );
        return this.controlEl;
    }
    onClick(evt: MouseEvent) {
        this.map.resetZoom();
    }
}

export function resetZoomControl(opts: L.ControlOptions, map: BaseMapType) {
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon: "bullseye",
        cls: "leaflet-control-reset-zoom"
        /* tooltip: t("Reset View") */
    };
    return new ResetZoomControl(options, map);
}



================================================
FILE: src/controls/zoom.ts
================================================
import { BaseMapType } from "../types";
import { FontAwesomeControl, FontAwesomeControlOptions } from "./controls";

import { LeafletSymbol } from "src/utils/leaflet-import";
import t from "src/l10n/locale";
const L = window[LeafletSymbol];

class ZoomControl extends FontAwesomeControl {
    controlEl: any;
    map: BaseMapType;
    constructor(opts: FontAwesomeControlOptions, map: BaseMapType) {
        super(opts, map.leafletInstance);
        this.map = map;

        this.map.on("markers-updated", () => {
            if (this.map.markers.length) {
                this.enable();
            } else {
                this.disable();
            }
        });
    }
    onClick(evt: MouseEvent) {
        if (!this.enabled) {
            return;
        }

        this.map.zoomAllMarkers();
    }
}

export function zoomControl(opts: L.ControlOptions, map: BaseMapType) {
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon: "map-marked-alt",
        cls: "leaflet-control-zoom-markers",
        tooltip: t("Show All Markers")
    };
    return new ZoomControl(options, map);
}



================================================
FILE: src/draw/actions.ts
================================================
import { FontAwesomeControl } from "src/controls/controls";
import { BaseDrawControl } from "./base";

export class CompleteControl extends FontAwesomeControl {
    constructor(public drawControl: BaseDrawControl) {
        super(
            {
                icon: "check",
                cls: "leaflet-control-complete",
                tooltip: "Finish"
            },
            drawControl.map.leafletInstance
        );
    }
    //Complete and save
    onClick(evt: MouseEvent) {
        evt.stopPropagation();
        this.drawControl.controller.newShape(
            this.drawControl.controller.shape.newInstance()
        );
    }
}
export class UndoControl extends FontAwesomeControl {
    constructor(public drawControl: BaseDrawControl) {
        super(
            {
                icon: "undo-alt",
                cls: "leaflet-control-undo",
                tooltip: "Undo"
            },
            drawControl.map.leafletInstance
        );
    }
    //Undo Last Vertex
    onClick(evt: MouseEvent) {
        evt.stopPropagation();
        this.drawControl.controller.shape.undo();
    }
}
export class CancelControl extends FontAwesomeControl {
    constructor(public drawControl: BaseDrawControl) {
        super(
            {
                icon: "times-circle",
                cls: "leaflet-control-cancel",
                tooltip: "Cancel"
            },
            drawControl.map.leafletInstance
        );
    }
    //Stop and remove from map
    onClick(evt: MouseEvent) {
        evt.stopPropagation();
        this.drawControl.parent.stopDrawingContext();
    }
}



================================================
FILE: src/draw/base.ts
================================================
import {
    FontAwesomeControl,
    FontAwesomeControlOptions
} from "src/controls/controls";
import { CompleteControl, UndoControl, CancelControl } from "./actions";
import { DrawControl } from "./controls";

export abstract class BaseDrawControl extends FontAwesomeControl {
    complete = new CompleteControl(this);
    undo = new UndoControl(this);
    cancel = new CancelControl(this);
    get map() {
        return this.parent.map;
    }
    get controller() {
        return this.parent.controller;
    }
    constructor(opts: FontAwesomeControlOptions, public parent: DrawControl) {
        super(opts, parent.map.leafletInstance);
        this.draw();
    }

    actionsEl = this.controlEl.createDiv("control-actions");

    onClick() {
        this.openActions();
    }
    openActions() {
        this.actionsEl.addClass("expanded");
    }
    closeActions() {
        this.actionsEl.removeClass("expanded");
        
    }
    abstract draw(): void;
}



================================================
FILE: src/draw/color.ts
================================================
import { FontAwesomeControl } from "src/controls/controls";
import t from "src/l10n/locale";
import { BaseDrawControl } from "./base";
import { DrawControl } from "./controls";

export class ColorControl extends BaseDrawControl {
    onClick() {
        this.parent.stopDrawingContext();
        this.openActions();
    }
    draw() {}
    fill = new ColorFillControl(this);
    pick = new ColorPickControl(this);
    constructor(parent: DrawControl) {
        super(
            {
                icon: "circle",
                cls: "leaflet-control-has-actions leaflet-control-draw-paint",
                tooltip: t("Color")
            },
            parent
        );
        this.iconEl.setAttr("style", `color: ${this.parent.controller.color}`);
        this.actionsEl.appendChild(this.fill.controlEl);
        this.actionsEl.appendChild(this.pick.controlEl);
    }
    updateColor(color: string) {
        this.parent.controller.color = color;
        this.iconEl.setAttr("style", `color: ${this.parent.controller.color}`);
    }
    closeActions() {
        super.closeActions();
        this.fill.setActive(false);
    }
}

class ColorPickControl extends FontAwesomeControl {
    input: HTMLInputElement;
    onClick() {
        this.drawControl.fill.setActive(false);

        this.input.click();
    }
    constructor(public drawControl: ColorControl) {
        super(
            {
                icon: "palette",
                cls: "leaflet-control-has-actions leaflet-control-draw-palette",
                tooltip: t("Color")
            },
            drawControl.map.leafletInstance
        );
        this.input = this.controlEl.createEl("input", {
            type: "color"
        });
        this.input.oninput = (evt) => {
            this.drawControl.updateColor(
                (evt.target as HTMLInputElement).value
            );
        };
        this.input.onchange = () => {
            this.drawControl.fill.setActive(true);
        };
    }
}

class ColorFillControl extends FontAwesomeControl {
    active: boolean = false;
    setActive(b: boolean) {
        this.active = b;
        this.drawControl.controller.isColoring = b;
        if (b) {
            this.controlEl.addClass("active");
        } else {
            this.controlEl.removeClass("active");
        }
    }
    onClick(evt: MouseEvent) {
        evt.stopPropagation();
        this.setActive(!this.active);
    }
    constructor(public drawControl: ColorControl) {
        super(
            {
                icon: "fill-drip",
                cls: "leaflet-control-fill-color",
                tooltip: t("Fill Color")
            },
            drawControl.map.leafletInstance
        );
    }
}



================================================
FILE: src/draw/controller.ts
================================================
import { BaseMapType } from "../types";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { Polygon } from "./polygon";
import { Polyline, PolylineProperties } from "./polyline";
import { Rectangle } from "./rectangle";
import { Shape, ShapeProperties } from "./shape";
import { Vertex } from "./vertex";

const L = window[LeafletSymbol];

export class DrawingController {
    draggingShape: Shape<L.Path>;
    getSelectedVertex() {
        const vertices = Object.values(this.shapes)
            .flat()
            .map((shape) => shape.vertices)
            .flat();

        return vertices.find((v) => v.selected);
    }
    removeShape(shape: Shape<L.Path>) {
        this.shapes[shape.type] = this.shapes[shape.type].filter(
            (s) => s != shape
        );
        shape.remove();
    }
    isDrawing: boolean = false;
    isDeleting: boolean = false;
    isColoring: boolean = false;
    isDragging: boolean = false;
    isAddingArrows: boolean = false;
    setArrowContext(bool: boolean) {
        this.isAddingArrows = bool;
        if (this.shape?.type != "polyline") return;
        if (bool) {
            (this.shape as unknown as Polyline).addArrows();
        } else {
            (this.shape as unknown as Polyline).removeArrows();
        }
    }
    shape: Shape<L.Path>;
    shapes: Record<string, Shape<L.Path>[]> = {
        rectangle: [],
        polyline: [],
        polygon: []
    };

    color: string = this.map.options.drawColor;

    get flatShapes() {
        return Object.values(this.shapes).flat();
    }

    get vertices() {
        return this.flatShapes.map((shape) => shape.vertices).flat();
    }

    constructor(public map: BaseMapType, shapes?: any[]) {}

    hideVertices() {
        this.flatShapes.forEach((shape) => shape.hideVertices());
    }
    showVertices() {
        this.flatShapes.forEach((shape) => shape.showVertices());
    }

    addShape(shape: ShapeProperties) {
        let newShape: Shape<L.Path>;
        switch (shape.type) {
            case "polygon": {
                newShape = new Polygon(this, shape.vertices, shape.color);
                break;
            }
            case "polyline": {
                newShape = new Polyline(
                    this,
                    shape.vertices,
                    shape.color,
                    (shape as PolylineProperties).arrows,
                    (shape as PolylineProperties).reversed
                );
                break;
            }
            case "rectangle": {
                newShape = new Rectangle(this, shape.vertices, shape.color);
                break;
            }
        }
        newShape.checkAndAddToMap();
        this.shapes[shape.type].push(newShape);
    }

    newShape(shape?: Shape<L.Path>) {
        const newShape = shape ?? this.shape.newInstance();
        if (this.shape) this.saveShape();
        this.shape = newShape;
        this.startDrawing();
    }
    saveShape() {
        if (this.shape) {
            this.shape.stopDrawing();
            if (this.shape.canSave) {
                this.shapes[this.shape.type].push(this.shape);
                this.shape.registerEvents();
                this.map.trigger("should-save");
            }
        }
        this.stopDrawing();
    }
    startDragging() {
        this.stopDrawing();
        this.isDragging = true;
        this.map.contentEl.addClass("shape-dragging");
        this.map.leafletInstance.on("mousemove touchmove", this.onDrag, this);
    }
    stopDragging() {
        this.isDragging = false;
        this.map.contentEl.removeClass("shape-dragging");
        this.map.leafletInstance.off("mousemove touchmove", this.onDrag, this);
    }
    onDrag(evt: L.LeafletMouseEvent) {
        L.DomEvent.stop(evt);
        if (this.draggingShape) {
            this.draggingShape.onDrag(evt);
        }
    }
    startDrawing() {
        this.isDrawing = true;
        this.registerDrawing();
    }
    stopDrawing() {
        this.isDrawing = false;
        if (this.shape) {
            this.shape.stopDrawing();
            this.unregisterDrawing();
            this.shape = null;
        }
    }
    getVertexTargets(vertex: Vertex) {
        return this.vertices.find((v) => v != vertex && v.isBeingHovered);
    }
    private registerDrawing() {
        this.map.registerScope();
        this.map.contentEl.addClass("drawing");
        this.map.leafletInstance.on(
            "mousemove touchmove",
            this.shape.onMousemove,
            this.shape
        );
        this.map.leafletInstance.on("click", this.shape.onClick, this.shape);
    }
    private unregisterDrawing() {
        this.map.unregisterScope();
        this.map.contentEl.removeClass("drawing");
        this.map.leafletInstance.off(
            "mousemove touchmove",
            this.shape.onMousemove,
            this.shape
        );
        this.map.leafletInstance.off("click", this.shape.onClick, this.shape);
    }

    toProperties() {
        return this.flatShapes.map((shape) => shape.toProperties());
    }
}



================================================
FILE: src/draw/controls.ts
================================================
import { BaseMapType } from "../types";
import {
    FontAwesomeControl,
    FontAwesomeControlOptions
} from "src/controls/controls";
import t from "src/l10n/locale";

import { LeafletSymbol } from "src/utils/leaflet-import";
import { BaseDrawControl } from "./base";
import { ColorControl } from "./color";
import { GeoJSONControl } from "./geojson";
import { PolygonControl } from "./polygon";
import { PolylineControl } from "./polyline";
import { RectangleControl } from "./rectangle";
import { TextControl } from "./text";

const L = window[LeafletSymbol];

export class DrawControl extends FontAwesomeControl {
    //draw tools
    section: HTMLElement;
    //context tools
    context: HTMLElement;

    //Controls
    polygon = new PolygonControl(this);
    rectangle = new RectangleControl(this);
    polyline = new PolylineControl(this);
    color = new ColorControl(this);
    drag = new DragControl(this);
    delete = new DeleteControl(this);
    geoJson = new GeoJSONControl(this);
    done = new DoneControl(this);

    /* free: FreeControl; */
    /* text: TextControl = new TextControl(this); */

    get controller() {
        return this.map.controller;
    }

    expanded: boolean;

    constructor(opts: FontAwesomeControlOptions, public map: BaseMapType) {
        super(opts, map.leafletInstance);
    }
    onClick(evt: MouseEvent) {}
    added() {
        //add hidden filter objects
        this.controlEl.addClass("leaflet-control-draw");

        this.section = this.controlEl.createEl("section", {
            cls: this.cls + "-list"
        });

        this.context = this.controlEl.createEl("section", {
            cls: this.cls + "-list"
        });

        this.draw();

        L.DomEvent.disableClickPropagation(this.controlEl);
        L.DomEvent.disableScrollPropagation(this.controlEl);

        this.iconEl.dataset["draggable"] = "false";

        this.map.on("click", this.collapse, this);

        L.DomEvent.on(this.controlEl, "click", () => this.expand());
    }
    complete() {
        this.stopDrawingContext();
        this.controller.hideVertices();
        this.collapse();
    }
    private collapse() {
        L.DomUtil.removeClass(this.controlEl, "expanded");
        this.enabled = false;
        return this;
    }
    draw() {
        this.section.appendChild(this.polygon.controlEl);
        this.section.appendChild(this.rectangle.controlEl);

        this.section.appendChild(this.polyline.controlEl);
        /* this.section.appendChild(this.text.controlEl); */

        this.section.appendChild(this.color.controlEl);
        this.section.appendChild(this.drag.controlEl);

        this.section.appendChild(this.delete.controlEl);
        this.section.appendChild(this.geoJson.controlEl);
        this.section.appendChild(this.done.controlEl);
    }
    private expand() {
        this.enabled = true;
        this.startDrawingContext();
        L.DomUtil.addClass(this.controlEl, "expanded");

        this.section.style.height = null;
        const acceptableHeight =
            this.leafletInstance.getSize().y - (this.controlEl.offsetTop + 50);

        if (acceptableHeight < this.section.clientHeight) {
            L.DomUtil.addClass(
                this.section,
                "leaflet-control-layers-scrollbar"
            );
            this.section.style.height = acceptableHeight + "px";
        } else {
            L.DomUtil.removeClass(
                this.section,
                "leaflet-control-layers-scrollbar"
            );
        }

        return this;
    }
    startDrawingContext() {
        this.controller.showVertices();
    }
    stopDrawingContext() {
        this.controller.saveShape();

        this.polygon.closeActions();
        this.rectangle.closeActions();
        this.polyline.closeActions();

        this.color.closeActions();
        this.controller.isColoring = false;

        this.drag.closeActions();
        this.controller.stopDragging();

        this.delete.closeActions();
        this.controller.isDeleting = false;
    }
}

class DragControl extends BaseDrawControl {
    get map() {
        return this.parent.map;
    }
    constructor(public parent: DrawControl) {
        super(
            {
                icon: "arrows-alt",
                cls: "leaflet-control-has-actions leaflet-control-draw-drag",
                tooltip: t("Move Shapes")
            },
            parent
        );
        this.complete.onClick = (evt) => {
            evt.stopPropagation();
            this.parent.stopDrawingContext();
        };
    }
    onClick() {
        this.parent.stopDrawingContext();
        this.openActions();
        this.parent.controller.startDragging();
    }
    draw() {
        this.actionsEl.appendChild(this.complete.controlEl);
    }
}
class DeleteControl extends BaseDrawControl {
    get map() {
        return this.parent.map;
    }
    constructor(public parent: DrawControl) {
        super(
            {
                icon: "trash",
                cls: "leaflet-control-has-actions leaflet-control-draw-trash",
                tooltip: t("Delete Shapes")
            },
            parent
        );
        this.complete.onClick = (evt) => {
            evt.stopPropagation();
            this.parent.stopDrawingContext();
        };
    }
    onClick() {
        this.parent.stopDrawingContext();
        this.openActions();
        this.parent.controller.isDeleting = true;
    }
    draw() {
        this.actionsEl.appendChild(this.complete.controlEl);
    }
}
class DoneControl extends FontAwesomeControl {
    get map() {
        return this.parent.map;
    }
    constructor(private parent: DrawControl) {
        super(
            {
                icon: "check",
                cls: "leaflet-control-draw-done",
                tooltip: t("Done")
            },
            parent.map.leafletInstance
        );
    }
    onClick(evt: MouseEvent) {
        evt.stopPropagation();
        this.parent.complete();
        this.parent.map.trigger('should-save');
    }
}

export function drawControl(opts: L.ControlOptions, map: BaseMapType) {
    const options: FontAwesomeControlOptions = {
        ...opts,
        icon: "shapes",
        cls: "leaflet-control-expandable",
        tooltip: t("Draw")
    };
    return new DrawControl(options, map);
}



================================================
FILE: src/draw/geojson.ts
================================================
import t from "src/l10n/locale";
import { BaseMapType } from "../types";
import { DrawControl } from "./controls";
import { FontAwesomeControl, FontAwesomeControlOptions } from "src/controls/controls";
import { LayerGroup, Polyline } from "leaflet";
import { GeoJSONModal } from "src/modals/geojson";

export class GeoJSONControl extends FontAwesomeControl {
    get map() {
        return this.parent.map;
    }
    constructor(private parent: DrawControl) {
        super(
            {
                icon: "save",
                cls: "leaflet-control-has-actions leaflet-control-save",
                tooltip: t("Export Drawing to GeoJSON")
            },
            parent.map.leafletInstance
        );
    }
    onClick(evt: MouseEvent) {
        evt.stopPropagation();

        const { plugin } = this.map;
        
        const features: Array<Polyline> = [];
        
        this.map.controller.flatShapes.forEach(shape => {
            if (shape.leafletInstance instanceof Polyline) {
                features.push(shape.leafletInstance);
            }
        });

        const result = JSON.stringify(features.map(feature => feature.toGeoJSON()));
        const newFilePath = plugin.app.fileManager.getNewFileParent(plugin.app.workspace.getActiveFile().path);

        new GeoJSONModal(plugin.app, (fileName) => {
            plugin.app.vault.adapter.write(`${newFilePath.path}/${fileName}.json`, result);
        }).open();
    }
}


================================================
FILE: src/draw/polygon.ts
================================================
import { BaseMapType } from "../types";
import t from "src/l10n/locale";
import { Marker } from "src/layer";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { BaseDrawControl } from "./base";
import { DrawControl } from "./controls";
import { Shape } from "./shape";
import { Vertex } from "./vertex";

const L = window[LeafletSymbol];

export class Polygon extends Shape<L.Polygon> {
    popup: null;

    extensions = {
        forward: {
            line: L.polyline([], {
                ...this.options,
                dashArray: "5,10",
                weight: 1,
                interactive: false,
                color: this.controller.color
            }),
            added: false
        },
        backward: {
            line: L.polyline([], {
                ...this.options,
                dashArray: "5,10",
                weight: 1,
                interactive: false,
                color: this.controller.color
            }),
            added: false
        }
    };
    leafletInstance = L.polygon([], this.options).addTo(
        this.map.leafletInstance
    );
    get canSave() {
        return this.vertices.length >= 3;
    }
    hideExtensions() {
        this.extensions.forward.line.remove();
        this.extensions.forward.added = false;
        this.extensions.backward.line.remove();
        this.extensions.backward.added = false;
    }

    _onClick(
        evt: L.LeafletMouseEvent,
        targets?: {
            marker?: Marker;
            vertices?: Vertex[];
        }
    ) {
        this.vertices.push(
            new Vertex(this.mouseLoc ?? evt.latlng, this, targets)
        );
        this.redraw();
    }

    _onMousemove(latlng: L.LatLng, modifier: boolean) {
        if (this.vertices.length) {
            this.mouseLoc = this.getMousemoveDelta(latlng, null, modifier);
            this.showExtensions(this.mouseLoc);
        }
    }

    redraw() {
        this.leafletInstance.setLatLngs(this.latlngs);
        this.leafletInstance.redraw();
        this.showExtensions(this.latlngs[this.vertices.length - 1]);
    }

    showExtensions(latlng: L.LatLng) {
        if (this.vertices.length >= 1) {
            this.extensions.forward.line.setLatLngs([
                this.latlngs[this.vertices.length - 1],
                latlng
            ]);
            if (this.extensions.forward.added) {
                this.extensions.forward.line.redraw();
            } else {
                this.extensions.forward.line.addTo(this.map.leafletInstance);
                this.extensions.forward.added = true;
            }
        }
        if (this.vertices.length > 1) {
            this.extensions.backward.line.setLatLngs([this.latlngs[0], latlng]);
            if (this.extensions.backward.added) {
                this.extensions.backward.line.redraw();
            } else {
                this.extensions.backward.line.addTo(this.map.leafletInstance);
                this.extensions.backward.added = true;
            }
        }
    }

    stopDrawing() {
        this.extensions.forward.line.remove();
        this.extensions.backward.line.remove();
        if (this.vertices.length < 3) {
            this.remove();
        }
    }

    undo() {
        this.vertices.pop();

        this.hideExtensions();
        this.redraw();
    }

    newInstance() {
        this.stopDrawing();
        return new Polygon(this.controller);
    }  

    initialize() {
        this.hideVertices();
        this.redraw();
    }

    type = "polygon";
}

export class PolygonControl extends BaseDrawControl {
    constructor(public parent: DrawControl) {
        super(
            {
                icon: "draw-polygon",
                cls: "leaflet-control-has-actions leaflet-control-draw-polygon",
                tooltip: t("Polygon")
            },
            parent
        );
    }
    draw() {
        this.actionsEl.appendChild(this.complete.controlEl);
        this.actionsEl.appendChild(this.undo.controlEl);
        this.actionsEl.appendChild(this.cancel.controlEl);
    }
    onClick() {
        this.parent.stopDrawingContext();
        this.openActions();
        this.controller.newShape(new Polygon(this.controller));
    }
}



================================================
FILE: src/draw/polyline.ts
================================================
import { FontAwesomeControl } from "src/controls/controls";
import t from "src/l10n/locale";
import { Marker } from "src/layer";
import { MODIFIER_KEY, getId } from "src/utils";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { BaseDrawControl } from "./base";
import { DrawingController } from "./controller";
import { DrawControl } from "./controls";
import { Shape, ShapeProperties } from "./shape";
import { Vertex, VertexProperties } from "./vertex";
import { popup } from "src/map";
import { Notice } from "obsidian";

const L = window[LeafletSymbol];

export interface PolylineProperties extends ShapeProperties {
    arrows: boolean;
    reversed: boolean;
}
export class Polyline extends Shape<L.Polyline> {
    triangleID = getId();
    constructor(
        controller: DrawingController,
        vertices: VertexProperties[] = [],
        color: string = controller.color,
        public arrows = controller.isAddingArrows,
        public reversed = false
    ) {
        super(controller, vertices, color);
        this.triangleEl.setAttrs({
            id: `${this.triangleID}`,
            viewBox: "0 0 10 10",
            refX: "5",
            refY: "5",
            markerUnits: "strokeWidth",
            markerWidth: "5",
            markerHeight: "5",
            orient: "auto",
            fill: color
        });
        this.pathEl.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
        this.triangleEl.appendChild(this.pathEl);
        this.checkAndAddDef();
        if (this.arrows) {
            this.addArrows();
            if (this.reversed) this.reverseArrows();
            this.redraw();
        }
        this.leafletInstance.on("click", (evt: L.LeafletMouseEvent) => {
            if (
                evt.originalEvent.getModifierState(MODIFIER_KEY) &&
                this.vertices.length > 1
            ) {
                const notice = [];
                let total = 0;
                for (let i = 1; i < this.vertices.length; i++) {
                    let dist = this.map.distance(
                        this.vertices[i - 1].latlng,
                        this.vertices[i].latlng
                    );
                    notice.push(dist);
                    total += Number(dist.replace(/[^\d\.]/g, ""));
                }
                if (notice.length) {
                    new Notice(
                        `${notice.join("\n")}\n\nTotal: ${total} ${
                            this.map.unit
                        }`
                    );
                }
                //wtf??
                //@ts-ignore
                this.map.distanceDisplay.setText(`${total} ${this.map.unit}`);
            }
        });
    }
    triangleEl = L.SVG.create("marker");
    pathEl = L.SVG.create("path");
    popup: null;
    setColor(color: string) {
        super.setColor(color);
        this.triangleEl.setAttribute("fill", color);
    }
    toggleArrows() {
        this.redraw();
        if (!this.arrows) {
            this.addArrows();
        } else if (!this.reversed) {
            this.reverseArrows();
        } else {
            this.removeArrows();
        }
        this.redraw();
        this.map.trigger("should-save");
    }
    reverseArrows() {
        this.reversed = true;
        this.pathEl.setAttribute("transform", "rotate(180 5 5)");
    }
    addArrows() {
        this.arrows = true;
        if (this.element) {
            this.element.setAttribute("marker-mid", `url(#${this.triangleID})`);
        } else {
            this.leafletInstance.on("add", () => {
                this.element.setAttribute(
                    "marker-mid",
                    `url(#${this.triangleID})`
                );
            });
        }
        this.leafletInstance.options.smoothFactor = 0;
    }
    get element() {
        return this.leafletInstance.getElement();
    }
    removeArrows() {
        this.arrows = false;
        this.reversed = false;
        this.element.removeAttribute("marker-mid");
        this.pathEl.removeAttribute("transform");
        this.leafletInstance.options.smoothFactor = 1;
    }
    toProperties(): PolylineProperties {
        return {
            type: this.type,
            color: this.color,
            vertices: this.vertices.map((v) => v.toProperties()),
            arrows: this.arrows,
            reversed: this.reversed
        };
    }
    extensions = {
        forward: {
            line: L.polyline([], {
                ...this.options,
                dashArray: "5,10",
                weight: 1,
                interactive: false
            }),
            added: false
        }
    };
    leafletInstance = L.polyline([], this.options).addTo(
        this.map.leafletInstance
    );
    mouseLoc: any;
    get canSave() {
        return this.vertices.length >= 1;
    }
    addLatLng(latlng: L.LatLng) {
        this.vertices.push(new Vertex(latlng, this));
    }

    hideExtensions() {
        this.extensions.forward.line.remove();
        this.extensions.forward.added = false;
    }
    _onClick(
        evt: L.LeafletMouseEvent,
        targets?: {
            marker?: Marker;
            vertices?: Vertex[];
        }
    ) {
        if (this.vertices.length == 0) {
            this.checkAndAddDef();
        }
        this.vertices.push(
            new Vertex(this.mouseLoc ?? evt.latlng, this, targets)
        );
        this.redraw();
    }

    _onMousemove(latlng: L.LatLng, modifier: boolean) {
        if (this.vertices.length) {
            this.mouseLoc = this.getMousemoveDelta(latlng, null, modifier);
            this.showExtensions(this.mouseLoc);
        }
    }

    get coordinates() {
        if (!this.arrows) return this.latlngs;
        //return 1 extra coordinate per latlng
        if (!this.latlngs.length) return [];
        return [
            this.latlngs[0],
            ...this.latlngs
                .slice(1)
                .map((latlng, index) => [
                    L.latLngBounds(this.latlngs[index], latlng).getCenter(),
                    latlng
                ])
                .flat()
        ];
    }

    redraw() {
        this.leafletInstance.setLatLngs(this.coordinates);
        this.leafletInstance.redraw();
        this.showExtensions(this.latlngs[this.vertices.length - 1]);
    }

    showExtensions(latlng: L.LatLng) {
        if (this.vertices.length >= 1) {
            this.extensions.forward.line.setLatLngs([
                this.latlngs[this.vertices.length - 1],
                latlng
            ]);
            if (this.extensions.forward.added) {
                this.extensions.forward.line.redraw();
            } else {
                this.extensions.forward.line.addTo(this.map.leafletInstance);
                this.extensions.forward.added = true;
            }
        }
    }

    stopDrawing() {
        this.extensions.forward.line.remove();
        if (this.vertices.length === 1) {
            this.remove();
        }
    }

    undo() {
        this.vertices.pop();

        this.hideExtensions();
        this.redraw();
    }

    initialize() {
        this.hideVertices();
        this.redraw();
    }

    newInstance() {
        this.stopDrawing();
        return new Polyline(this.controller);
    }
    type = "polyline";
    get pane() {
        return this.map.leafletInstance.getPane("drawing");
    }
    checkAndAddDef() {
        if (!this.pane) return;
        const svg = this.pane.firstElementChild;
        if (!svg) {
            this.registerAddDef();
        } else {
            this.addDef();
        }
    }
    registerAddDef() {
        const observer = new MutationObserver((list) => {
            for (const mutation of list) {
                if (mutation.type === "childList") {
                    this.addDef();
                    observer.disconnect();
                    return;
                }
            }
        });
        observer.observe(this.pane, {
            childList: true,
            attributes: false,
            subtree: false
        });
    }

    addDef() {
        let def = this.pane.firstElementChild.querySelector("defs");
        if (!def) {
            def = L.SVG.create("defs") as SVGDefsElement;
            this.pane.firstElementChild.prepend(def);
        }
        def.appendChild(this.triangleEl);
    }
    onShow() {
        this.checkAndAddDef();
        if (this.arrows) {
            this.addArrows();
            if (this.reversed) this.reverseArrows();
            this.redraw();
        }
    }
    remove() {
        this.hideExtensions();
        this.removeArrows();
        super.remove();
    }
}

export class PolylineControl extends BaseDrawControl {
    arrow = new ArrowControl(this);

    constructor(public parent: DrawControl) {
        super(
            {
                icon: "project-diagram",
                cls: "leaflet-control-has-actions leaflet-control-draw-polyline",
                tooltip: t("Polyline")
            },
            parent
        );

        this.actionsEl.appendChild(this.arrow.controlEl);
        this.actionsEl.appendChild(this.undo.controlEl);
        this.actionsEl.appendChild(this.cancel.controlEl);
    }
    draw() {
        this.actionsEl.appendChild(this.complete.controlEl);
    }
    onClick() {
        this.parent.stopDrawingContext();
        this.openActions();
        this.controller.newShape(new Polyline(this.controller));
    }
}

export class ArrowControl extends FontAwesomeControl {
    get active() {
        return this.drawControl.controller.isAddingArrows;
    }
    constructor(public drawControl: BaseDrawControl) {
        super(
            {
                icon: "arrow-up",
                cls: "leaflet-control-arrow",
                tooltip: "Add Arrows to Line"
            },
            drawControl.map.leafletInstance
        );
    }
    //Complete and save
    onClick(evt: MouseEvent) {
        evt.stopPropagation();

        if (this.active) {
            this.controlEl.removeClass("active");
            this.drawControl.controller.setArrowContext(false);
        } else {
            this.controlEl.addClass("active");
            this.drawControl.controller.setArrowContext(true);
        }

        /* this.drawControl.controller.newShape(
            this.drawControl.controller.shape.newInstance()
        ); */
    }
}



================================================
FILE: src/draw/rectangle.ts
================================================
import { LatLng } from "leaflet";
import { Marker } from "src/layer/marker";
import t from "src/l10n/locale";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { BaseDrawControl } from "./base";
import { DrawControl } from "./controls";
import { Shape } from "./shape";
import { Vertex } from "./vertex";

const L = window[LeafletSymbol];

export class Rectangle extends Shape<L.Rectangle> {
    popup: null;

    leafletInstance = L.rectangle(
        [
            [0, 0],
            [0, 0]
        ],
        this.options
    ).addTo(this.map.leafletInstance);
    bounds: L.LatLngBounds;
    get canSave() {
        return this.vertices.length == 4;
    }
    ghost: L.Rectangle;

    _onClick(
        evt: L.LeafletMouseEvent,
        targets?: {
            marker?: Marker;
            vertices?: Vertex[];
        }
    ) {
        if (this.vertices.length == 0) {
            this.vertices.push(new Vertex(evt.latlng, this, targets));
            this.bounds = L.latLngBounds(evt.latlng, evt.latlng);
            this.redraw();
        } else if (this.vertices.length == 1) {
            this.bounds = L.latLngBounds(this.latlngs[0], evt.latlng);

            this.vertices.push(new Vertex(evt.latlng, this, targets));

            //get corners
            this.syncVerticesToCorners();

            this.registerVertexDrags();

            this.redraw();
            this.ghost.remove();
            this.ghost = null;
            this.controller.newShape(this.newInstance());
            return;
        }
    }
    syncVerticesToCorners() {
        const northWest =
            this.vertices.find((v) =>
                v.latlng.equals(this.bounds.getNorthWest())
            ) ?? new Vertex(this.bounds.getNorthWest(), this);

        const northEast =
            this.vertices.find((v) =>
                v.latlng.equals(this.bounds.getNorthEast())
            ) ?? new Vertex(this.bounds.getNorthEast(), this);

        const southEast =
            this.vertices.find((v) =>
                v.latlng.equals(this.bounds.getSouthEast())
            ) ?? new Vertex(this.bounds.getSouthEast(), this);

        const southWest =
            this.vertices.find((v) =>
                v.latlng.equals(this.bounds.getSouthWest())
            ) ?? new Vertex(this.bounds.getSouthWest(), this);

        this.vertices = [northWest, northEast, southEast, southWest];
    }

    _onMousemove(latlng: L.LatLng, modifier: boolean) {
        if (this.vertices.length) {
            this.showGhost(latlng);
        }
    }
    showGhost(latlng: LatLng) {
        if (this.vertices.length == 2) return;
        if (!this.ghost) {
            this.ghost = L.rectangle(L.latLngBounds(this.latlngs[0], latlng), {
                dashArray: "5,10",
                weight: 1,
                interactive: false,
                fillOpacity: 0.5,
                color: this.controller.color,
                fillColor: this.controller.color
            }).addTo(this.map.leafletInstance);
        }
        this.ghost.setBounds(L.latLngBounds(this.latlngs[0], latlng));
    }
    get boundsArray() {
        return [
            this.bounds.getNorthWest(),
            this.bounds.getNorthEast(),
            this.bounds.getSouthEast(),
            this.bounds.getSouthWest()
        ];
    }
    registerVertexDrags() {
        this.vertices[0].on("drag", () => {
            this.vertices[3].setLatLng(
                L.latLng([
                    this.vertices[3].getLatLng().lat,
                    this.vertices[0].getLatLng().lng
                ])
            );
            this.vertices[1].setLatLng(
                L.latLng([
                    this.vertices[0].getLatLng().lat,
                    this.vertices[1].getLatLng().lng
                ])
            );
        });
        this.vertices[1].on("drag", () => {
            this.vertices[2].setLatLng(
                L.latLng([
                    this.vertices[2].getLatLng().lat,
                    this.vertices[1].getLatLng().lng
                ])
            );
            this.vertices[0].setLatLng(
                L.latLng([
                    this.vertices[1].getLatLng().lat,
                    this.vertices[0].getLatLng().lng
                ])
            );
        });
        this.vertices[2].on("drag", () => {
            this.vertices[1].setLatLng(
                L.latLng([
                    this.vertices[1].getLatLng().lat,
                    this.vertices[2].getLatLng().lng
                ])
            );
            this.vertices[3].setLatLng(
                L.latLng([
                    this.vertices[2].getLatLng().lat,
                    this.vertices[3].getLatLng().lng
                ])
            );
        });
        this.vertices[3].on("drag", () => {
            this.vertices[0].setLatLng(
                L.latLng([
                    this.vertices[0].getLatLng().lat,
                    this.vertices[3].getLatLng().lng
                ])
            );
            this.vertices[2].setLatLng(
                L.latLng([
                    this.vertices[3].getLatLng().lat,
                    this.vertices[2].getLatLng().lng
                ])
            );
        });
    }
    updateBounds() {
        if (this.vertices.length != 4) {
            return;
        }
        this.bounds = L.latLngBounds(this.latlngs);
    }

    redraw() {
        this.updateBounds();
        this.leafletInstance.setBounds(this.bounds);
        this.leafletInstance.redraw();
    }

    showExtensions(latlng: L.LatLng) {}

    stopDrawing() {
        if (this.vertices.length === 1) {
            this.remove();
        }
        if (this.ghost) {
            this.ghost.remove();
            this.ghost = null;
        }
    }

    undo() {
        if (this.controller.shapes.length)
            this.controller.shapes.rectangle.pop().remove();
    }

    newInstance() {
        this.stopDrawing();
        return new Rectangle(this.controller);
    }

    initialize() {
        this.redraw();
        this.hideVertices();
        this.syncVerticesToCorners();
        this.registerVertexDrags();
    }

    type = "rectangle";
}

export class RectangleControl extends BaseDrawControl {
    constructor(public parent: DrawControl) {
        super(
            {
                icon: "vector-square",
                cls: "leaflet-control-has-actions leaflet-control-draw-rectangle",
                tooltip: t("Rectangle")
            },
            parent
        );
    }
    draw() {
        this.actionsEl.appendChild(this.undo.controlEl);
        this.actionsEl.appendChild(this.cancel.controlEl);
    }
    onClick() {
        this.parent.stopDrawingContext();
        this.openActions();
        this.controller.newShape(new Rectangle(this.controller));
    }
}



================================================
FILE: src/draw/shape.ts
================================================
import { Layer } from "src/layer/layer";
import { DrawingController } from "./controller";
import { Vertex, VertexProperties } from "./vertex";
import { Marker } from "src/layer";

import { LeafletSymbol } from "src/utils/leaflet-import";
import { Polyline } from "./polyline";

const L = window[LeafletSymbol];
export interface ShapeProperties {
    type: string;
    color: string;
    vertices: VertexProperties[];
}

export abstract class Shape<T extends L.Path> extends Layer<T> {
    layer = "INTERNAL_SHAPE_LAYER";
    dragStart: L.LatLng;
    toProperties(): ShapeProperties {
        return {
            type: this.type,
            color: this.color,
            vertices: this.vertices.map((v) => v.toProperties())
        };
    }
    registerEvents() {
        this.leafletInstance.on("click", (evt: L.LeafletMouseEvent) => {
            L.DomEvent.stopPropagation(evt);
            if (this.controller.isDeleting) {
                this.hideVertices();
                this.controller.removeShape(this);
            }
            if (this.controller.isColoring) {
                this.setColor(this.controller.color);
            }

            if (this.controller.isAddingArrows && this.type == "polyline") {
                (this as unknown as Polyline).toggleArrows();
            }
        });
        this.leafletInstance.on("mousedown", (evt: L.LeafletMouseEvent) => {
            if (!this.controller.isDragging) return;
            this.map.leafletInstance.dragging.disable();
            this.dragStart = evt.latlng;
            this.controller.draggingShape = this;
        });
        this.leafletInstance.on("mouseup", (evt: L.LeafletMouseEvent) => {
            if (!this.controller.isDragging) return;
            this.map.leafletInstance.dragging.enable();
            this.controller.draggingShape = null;

            this.map.trigger("should-save");
        });
    }
    options: L.PathOptions = {
        pane: "drawing",
        color: this.color,
        fillColor: this.color
    };
    constructor(
        public controller: DrawingController,
        vertices: VertexProperties[] = [],
        public color: string = controller.color
    ) {
        super();
        this.map = this.controller.map;
        this.vertices = vertices.map((props) =>
            Vertex.fromProperties(props, this)
        );
        this.hideVertices();
    }

    get group() {
        return this.map.drawingLayer;
    }

    vertices: Vertex[] = [];

    get latlngs() {
        return this.vertices.map((v) => v.getLatLng());
    }
    mouseLoc: L.LatLng;

    abstract get canSave(): boolean;
    abstract newInstance(): Shape<T>;
    abstract _onMousemove(latlng: L.LatLng, modifier: boolean): void;
    onClick(
        evt: L.LeafletMouseEvent,
        targets?: {
            marker?: Marker;
            vertices?: Vertex[];
        }
    ) {
        let vertex = this.controller.getSelectedVertex();
        if (vertex) {
            vertex.selected = false;
            return;
        }
        this._onClick(evt, targets);
    }
    abstract _onClick(
        evt: L.LeafletMouseEvent,
        targets?: {
            marker?: Marker;
            vertices?: Vertex[];
        }
    ): void;
    abstract redraw(): void;
    abstract stopDrawing(): void;
    abstract undo(): void;

    abstract type: string;

    onMousemove(evt: L.LeafletMouseEvent) {
        let latlng = evt.latlng;
        if (!evt.originalEvent.getModifierState("Shift")) {
            if (this.controller.vertices.find((v) => v.isBeingHovered)) {
                const vertex = this.controller.vertices.find(
                    (v) => v.isBeingHovered
                );
                latlng = vertex.getLatLng();
            } else if (this.map.markers.find((m) => m.isBeingHovered)) {
                const marker = this.map.markers.find(
                    (m) => m.isBeingHovered
                ).leafletInstance;
                latlng = marker.getLatLng();
            }
        }
        this._onMousemove(latlng, evt.originalEvent.getModifierState("Shift"));
    }

    onDrag(evt: L.LeafletMouseEvent, propagate: boolean = true) {
        L.DomEvent.stop(evt);
        if (!this.dragStart) this.dragStart = evt.latlng;
        const latlng = this.getMousemoveDelta(
            evt.latlng,
            this.dragStart,
            evt.originalEvent.getModifierState("Shift")
        );
        const delta = L.latLng(
            latlng.lat - this.dragStart.lat,
            latlng.lng - this.dragStart.lng
        );
        this.vertices.forEach((v) => v.incrementLatLng(delta));
        this.redraw();

        if (propagate) {
            const otherShapes: Set<Shape<L.Path>> = new Set();
            this.vertices.forEach((v) =>
                v.vertices.forEach(
                    (vertex) => vertex && otherShapes.add(vertex.parent)
                )
            );

            otherShapes.forEach((shape) => {
                shape.dragStart = this.dragStart;
                shape.onDrag(evt, false);
            });
        }
        this.dragStart = evt.latlng;
    }

    checkAndAddToMap() {
        if (this.map.readyForDrawings) {
            this.show();
        } else {
            this.map.on("ready-for-drawings", () => this.show());
        }
    }

    abstract initialize(): void;

    show() {
        if (this.vertices.length) {
            this.initialize();
            this.registerEvents();
        }
        this.onShow();
    }

    showVertices() {
        this.vertices.forEach((vertex) => {
            vertex.show();
        });
    }
    hideVertices() {
        this.vertices.forEach((vertex) => {
            vertex.hide();
        });
    }

    getMousemoveDelta(
        latlng: L.LatLng,
        previous?: L.LatLng,
        modifier?: boolean
    ) {
        if (modifier) {
            const delta = [
                Math.abs(
                    latlng.lat -
                        (previous ?? this.latlngs[this.vertices.length - 1]).lat
                ),
                Math.abs(
                    latlng.lng -
                        (previous ?? this.latlngs[this.vertices.length - 1]).lng
                )
            ];
            if (delta[0] > delta[1]) {
                latlng.lng = (
                    previous ?? this.latlngs[this.vertices.length - 1]
                ).lng;
            } else {
                latlng.lat = (
                    previous ?? this.latlngs[this.vertices.length - 1]
                ).lat;
            }
        }
        return latlng;
    }

    setColor(color: string) {
        this.color = color;
        this.leafletInstance.setStyle({ fillColor: color, color: color });
        this.map.trigger("should-save");
    }

    remove() {
        this.leafletInstance.remove();
        this.hideVertices();
        this.vertices.forEach((v) => v.delete());
        this.vertices = [];
        this.map.trigger("should-save");
    }
}



================================================
FILE: src/draw/text.ts
================================================
import { TextComponent } from "obsidian";
import t from "src/l10n/locale";
import { DrawControl } from "./controls";

import { LeafletSymbol } from "src/utils/leaflet-import";
import { BaseDrawControl } from "./base";
const L = window[LeafletSymbol];

// Not currently in use.
export class TextControl extends BaseDrawControl {
    get map() {
        return this.parent.map;
    }
    contextEnabled: any;
    constructor(public parent: DrawControl) {
        super(
            {
                icon: "font",
                cls: "leaflet-control-draw-text leaflet-control-has-actions",
                tooltip: t("Text")
            },

            parent
        );
    }
    draw() {
        this.actionsEl.appendChild(this.complete.controlEl);
        this.actionsEl.appendChild(this.cancel.controlEl);
    }
    onClick() {
        this.openActions();
        this.parent.stopDrawingContext();
        if (!this.contextEnabled) {
            this.enableTextContext();
        } else {
            this.disableTextContext();
        }
    }
    disableTextContext() {
        this.closeActions();
        this.contextEnabled = false;
        this.map.leafletInstance.off("click", this.createTextComponent, this);
        this.map.contentEl.removeClass("adding-text");
    }
    enableTextContext() {
        this.contextEnabled = true;
        this.map.contentEl.addClass("adding-text");
        this.map.leafletInstance.on("click", this.createTextComponent, this);
    }
    createTextComponent(e: L.LeafletMouseEvent) {
        const editable = new TextMarker(e.latlng).addTo(this.map.drawingLayer);

        this.disableTextContext();
    }
}

class TextMarker extends L.Marker {
    containerEl: HTMLDivElement;

    input: TextComponent;
    icon: L.DivIcon;
    text: SVGTextElement;
    svg: SVGElement;

    /* box: L.Rectangle = L.rectangle([], {
        pane: "drawing",
        fillColor: "transparent",
        dashArray: "5,10",
        weight: 1
    }); */

    constructor(latlng: L.LatLng) {
        super(latlng);
        this.containerEl = createDiv("leaflet-text-entry");

        this.svg = this.createEl("svg");
        this.text = this.createEl("text", this.svg);

        this.input = new TextComponent(this.containerEl).setPlaceholder("Text");
        this.icon = new L.DivIcon({ html: this.svg.outerHTML });
        this.setIcon(this.icon);

        /* this.input.inputEl.onblur = () => {
            this.input.inputEl.replaceWith(
                createSpan({
                    text: this.text
                })
            );
        }; */
    }

    createEl<K extends keyof SVGElementTagNameMap>(
        name: K,
        parent?: SVGElement
    ): SVGElementTagNameMap[K] {
        const el = document.createElementNS("http://www.w3.org/2000/svg", name);
        if (parent) {
            parent.appendChild(el);
        }
        return el;
    }
}



================================================
FILE: src/draw/vertex.ts
================================================
import { LatLng } from "leaflet";
import { Events } from "obsidian";
import { Marker } from "src/layer";
import { MarkerDivIcon } from "src/map";
import { getId } from "src/utils";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { Shape } from "./shape";
const L = window[LeafletSymbol];

class VertexIcon extends MarkerDivIcon {
    constructor() {
        super({
            iconSize: new L.Point(8, 8),
            className: "leaflet-div-icon leaflet-vertex-icon"
        });
    }
}

declare module "leaflet" {
    interface Marker {
        _icon: HTMLElement;
    }
}

export class VertexProperties {
    lat: number;
    lng: number;
    id: string;
    targets: {
        vertexIds?: string[];
        markerId?: string;
    };
}

export class Vertex extends Events {
    incrementLatLng(delta: LatLng): void {
        const lat = this.latlng.lat + delta.lat;
        const lng = this.latlng.lng + delta.lng;

        this.leafletInstance.setLatLng(L.latLng(lat, lng));
        if (this.marker) {
            this.marker.setLatLng(L.latLng(lat, lng))
        }
    }
    leafletInstance: L.Marker;
    selected: boolean = false;
    isBeingHovered: boolean = false;
    marker: Marker;
    vertices: Set<Vertex> = new Set();
    modifierState: boolean = false;
    getLatLng() {
        return this.leafletInstance.getLatLng();
    }
    setLatLng(latlng: L.LatLng) {
        this.leafletInstance.setLatLng(latlng);
        this.parent.redraw();
        if (this.marker && this.marker.leafletInstance) {
            this.marker.leafletInstance.setLatLng(latlng);
        }
        this.vertices.forEach((v) => v.updateLatLng(latlng));
    }
    updateLatLng(latlng: LatLng): void {
        this.leafletInstance.setLatLng(latlng);

        this.trigger("drag");

        this.parent.redraw();
    }
    get latlng() {
        return this.getLatLng();
    }
    constructor(
        latlng: L.LatLng,
        public parent: Shape<L.Path>,
        public targets?: {
            marker?: Marker;
            vertices?: Vertex[];
            markerId?: string;
            vertexIds?: string[];
        },
        public id = getId()
    ) {
        super();

        this.addMarkerTarget(targets?.marker);
        this.addVertexTargets(...(targets?.vertices ?? []));

        this.addTargetsById();

        this.leafletInstance = new L.Marker(latlng, {
            icon: new VertexIcon(),
            draggable: true,
            pane: "drawing-markers"
        }).addTo(this.parent.map.leafletInstance);

        this.registerDragEvents();

        if (this.vertices.size) {
            this.vertices.forEach((v) => {
                v.addVertexTargets(this);
                v.marker = this.marker;
            });
        }
    }

    addTargetsById() {
        if (this.targets && this.targets.vertexIds) {
            let vertices = this.parent.controller.vertices;

            for (let id of this.targets.vertexIds) {
                let vertex = vertices.find((v) => v.id == id);
                if (!vertex) continue;
                this.addVertexTargets(vertex);
            }
        }
        if (this.targets && this.targets.markerId) {
            const marker = this.parent.map.markers.find(
                (m) => m.id == this.targets.markerId
            );
            if (!marker) return;
            this.addMarkerTarget(marker as Marker);
        }
    }

    addMarkerTarget(marker: Marker, propagate: boolean = true) {
        if (!marker) return;
        this.marker = marker;
        if (propagate)
            this.vertices.forEach((v) => v.addMarkerTarget(this.marker, false));
        this.registerMarkerEvents();
    }
    addVertexTargets(...vertices: Vertex[]) {
        for (let vertex of vertices) {
            if (vertex == this) continue;
            this.vertices.add(vertex);
            vertex.vertices.forEach(
                (v) => this.vertices.add(v) && v.vertices.add(this)
            );
            vertex.vertices.add(this);

            if (vertex.marker) {
                this.addMarkerTarget(vertex.marker);
            } else if (this.marker) {
                vertex.addMarkerTarget(this.marker);
                vertex.vertices.forEach((v) => v.addMarkerTarget(this.marker));
            }
            vertex.on("delete", () => {
                this.vertices.delete(vertex);
            });
        }
        this.vertices.delete(this);
    }

    registerDragEvents() {
        this.leafletInstance.on(
            "drag",
            (evt: L.LeafletMouseEvent, data?: any) => {
                L.DomEvent.stopPropagation(evt);

                this.modifierState =
                    evt.originalEvent?.getModifierState("Shift") ?? false;
                let latlng = this.parent.getMousemoveDelta(
                    evt.latlng,
                    this.latlng,
                    this.modifierState
                );

                if (!this.modifierState) {
                    if (this.parent.controller.getVertexTargets(this)) {
                        const vertex =
                            this.parent.controller.getVertexTargets(this);
                        latlng = vertex.getLatLng();
                    }
                    if (this.parent.map.markers.find((m) => m.isBeingHovered)) {
                        const marker = this.parent.map.markers.find(
                            (m) => m.isBeingHovered
                        ).leafletInstance;
                        latlng = marker.getLatLng();
                    }
                }

                this.setLatLng(latlng);

                this.trigger("drag");
            }
        );
        this.leafletInstance.on("mouseover", () => {
            this.isBeingHovered = true;
        });
        this.leafletInstance.on("mouseout", () => {
            this.isBeingHovered = false;
        });
        this.leafletInstance.on("mousedown", (evt: L.LeafletMouseEvent) => {
            L.DomEvent.stopPropagation(evt);
            this.selected = true;
        });
        this.leafletInstance.on("mouseup", (evt) => {
            L.DomEvent.stopPropagation(evt);
            this.selected = false;
        });
        this.leafletInstance.on("dragstart", () => {
            this.selected = true;
            this.leafletInstance.setZIndexOffset(-1);
        });
        this.leafletInstance.on("dragend", (evt) => {
            L.DomEvent.stopPropagation(evt);
            this.leafletInstance.setZIndexOffset(0);
            if (!this.modifierState) {
                if (this.parent.controller.getVertexTargets(this)) {
                    const vertex =
                        this.parent.controller.getVertexTargets(this);
                    this.addVertexTargets(vertex);
                }
                if (
                    this.parent.map.markers.find(
                        (marker) => marker.isBeingHovered
                    )
                ) {
                    this.marker = this.parent.map.markers.find(
                        (marker) => marker.isBeingHovered
                    ) as Marker;
                    this.registerMarkerEvents();
                }
            }
            this.modifierState = false;
            this.parent.redraw();
            this.parent.map.trigger("should-save");
        });
        this.leafletInstance.on("click", (evt: L.LeafletMouseEvent) => {
            L.DomEvent.stopPropagation(evt);
            if (this.parent.controller.isDrawing) {
                this.selected = false;
                this.parent.controller.shape.onClick(evt, { vertices: [this] });
            }
        });
        this.registerMarkerEvents();
    }
    unregisterMarkerEvents() {
        if (this.marker) {
            this.marker.leafletInstance.off("drag", this.onTargetDrag, this);
        }
    }
    onTargetDrag(evt: L.LeafletMouseEvent) {
        this.leafletInstance.fire("drag", evt);
    }
    registerMarkerEvents() {
        if (this.marker) {
            this.marker.leafletInstance.on("drag", this.onTargetDrag, this);
            this.marker.leafletInstance.on("remove", () => {
                this.unregisterMarkerEvents();
                this.marker = null;
            });
        }
    }
    delete() {
        this.trigger("delete");
        this.unregisterMarkerEvents();
        this.hide();
    }
    hide() {
        this.leafletInstance.remove();
    }
    show() {
        this.leafletInstance.addTo(this.parent.map.leafletInstance);
    }
    toProperties(): VertexProperties {
        return {
            lat: this.latlng.lat,
            lng: this.latlng.lng,
            id: this.id,
            targets: {
                vertexIds: Array.from(this.vertices).map((v) => v.id),
                markerId: this.marker?.id
            }
        };
    }
    static fromProperties(properties: VertexProperties, shape: Shape<L.Path>) {
        const vertex = new Vertex(
            L.latLng(properties.lat, properties.lng),
            shape,
            properties.targets,
            properties.id
        );
        return vertex;
    }
}
class MidIcon extends L.DivIcon {
    constructor() {
        super({
            iconSize: new L.Point(6, 6),
            className: "leaflet-div-icon leaflet-mid-icon"
        });
    }
}

export class MiddleVertex {
    leafletInstance: L.Marker;
    getLatLng() {
        return this.leafletInstance.getLatLng();
    }
    constructor(public latlng: L.LatLng, public parent: Shape<L.Path>) {
        this.leafletInstance = new L.Marker(latlng, {
            icon: new MidIcon(),
            draggable: true,
            pane: "drawing-markers"
        }).addTo(this.parent.map.leafletInstance);
    }
}



================================================
FILE: src/initiative/initiative.ts
================================================
import { Menu, Notice, WorkspaceLeaf } from "obsidian";
import {
    BaseMapType,
    ImageLayerData,
    MarkerDivIconOptions,
    
} from "../types";
import { FontAwesomeControl } from "src/controls/controls";
import t from "src/l10n/locale";
import { Marker } from "src/layer";
import { MarkerDivIcon } from "src/map";
import { LeafletRenderer } from "src/renderer/renderer";
import { DEFAULT_BLOCK_PARAMETERS, StatusMap } from "src/utils";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { Creature } from "../../../obsidian-initiative-tracker/src/utils/creature";
import { ImageMap } from "../map/map";
import { LeafletMapView } from "../map/view";
import type ObsidianLeaflet from "src/main";

const L = window[LeafletSymbol];

import GridImage from "./dawbulg-8ce3e4cd-e97c-458f-a1ed-50a7c4ad58e3.png";

export class InitiativeMapView extends LeafletMapView {
    constructor(
        public leaf: WorkspaceLeaf,
        public plugin: ObsidianLeaflet,
        public players: Creature[] = [],
        public creatures: Creature[] = []
    ) {
        super(leaf, plugin);
        this.registerEvent(
            this.plugin.app.workspace.on("initiative-tracker:closed", () => {
                this.removeChild(this.renderer);
                this.leaf.detach();
                this.unload();
            })
        );
    }
    get params() {
        return {
            ...DEFAULT_BLOCK_PARAMETERS,
            id: "initiative-tracker-map",
            height: "100%",
            isMapView: false,
            isInitiativeView: true,
            scale: 25.7,
            unit: "ft"
        };
    }

    async onOpen() {
        this.renderer = new InitiativeRenderer(this);

        this.context.addChild(this.renderer);
    }
    async onClose() {
        this.renderer.unload();
        super.onClose();
    }
    update() {
        this.renderer.unload();

        this.renderer = new InitiativeRenderer(this);
        this.context.addChild(this.renderer);
    }
    getDisplayText() {
        return "Initiative Tracker Map";
    }
    getViewType() {
        return "INITIATIVE_TRACKER_MAP_VIEW";
    }
    setPlayers(...players: Creature[]) {
        this.players = players;
    }

    addPlayers(...players: Creature[]) {
        this.players.push(...players);
    }

    setCreatures(...creatures: Creature[]) {
        this.creatures = creatures;
    }
    addCreatures(...creatures: Creature[]) {
        this.creatures.push(...creatures);
    }
}
export class InitiativeRenderer extends LeafletRenderer {
    map: InitiativeMap;

    constructor(public view: InitiativeMapView) {
        super(view.plugin, "", view.mapEl, view.params, "");

        this.registerEvent(
            this.plugin.app.workspace.on(
                "initiative-tracker:new-encounter",
                () => {
                    this.map.removeCreature(
                        ...this.view.players,
                        ...this.view.creatures
                    );
                    this.loadSavedData();
                }
            )
        );
    }

    async buildMap() {
        this.map = new InitiativeMap(this, this.options);

        const { h, w } = await this.loader.getImageDimensions(GridImage);
        this.map.gridLayer = {
            data: GridImage,
            h,
            w,
            id: "grid-layer",
            alias: null
        };
        this.map.registerLayerToBuild(this.map.gridLayer);

        this.map.on("removed", () => this.resize.disconnect());

        this.map.render({
            coords: [50, 50],
            zoomDistance: null,
            imageOverlayData: []
        });

        this.loadSavedData();
    }
    loadSavedData() {
        let center = this.map.leafletInstance.getCenter();
        let index = -1 * (this.view.players.length / 2) + 0.5;
        for (let player of this.view.players) {
            let latlng = L.latLng(center.lat - 1, center.lng + index);
            this.map.addCreature({ latlng, creature: player });
            index++;
        }
        index = -1 * (this.view.creatures.length / 2) + 0.5;
        for (let player of this.view.creatures) {
            let latlng = L.latLng(center.lat + 1, center.lng + index);
            this.map.addCreature({ latlng, creature: player });
            index++;
            index++;
        }
    }
}

class ImageControl extends FontAwesomeControl {
    constructor(public map: InitiativeMap) {
        super(
            {
                tooltip: "Replace Image",
                cls: "leaflet-image-control",
                icon: "image"
            },
            map.leafletInstance
        );
    }
    input = this.controlEl.createEl("input", {
        attr: {
            type: "file",
            name: "image",
            accept: "image/*",
            style: "display: none;"
        }
    });
    onClick() {
        this.input.onchange = async () => {
            const { files } = this.input;

            if (!files.length) return;

            const image = files[0];
            const reader = new FileReader();
            reader.onloadend = (evt) => {
                var image = new Image();
                image.onload = () => {
                    const { width: w, height: h } = image;
                    this.map.replaceLayer(0, {
                        data: evt.target.result.toString(),
                        h,
                        w,
                        id: "grid-layer",
                        alias: null
                    });
                    this.map.removeCreature(
                        ...this.map.renderer.view.players,
                        ...this.map.renderer.view.creatures
                    );
                    this.map.renderer.loadSavedData();
                };
                image.src = evt.target.result.toString();
            };
            reader.readAsDataURL(image);

            this.input.value = null;
        };
        this.input.click();
    }
}

class InitiativeMap extends ImageMap {
    renderer: InitiativeRenderer;
    currentLayer: L.ImageOverlay;
    markerMap: Map<string, InitiativeMarker> = new Map();
    creatureMap: Map<string, Creature> = new Map();
    gridLayer: ImageLayerData;
    GridLayer: L.GridLayer;
    /** Register an event to the Renderer that will be removed when the renderer unloads. */
    addEvent(name: any, callback: (...args: any[]) => any) {
        this.renderer.registerEvent(
            this.plugin.app.workspace.on(name, callback)
        );
    }
    replaceLayer(index: number, layer: ImageLayerData) {
        this.mapLayers[index].group.remove();
        this.mapLayers = [];
        this.registerLayerToBuild(layer);
    }
    isLayerRendered() {
        return true;
    }
    createMap() {
        super.createMap();

        this.leafletInstance.off("contextmenu");

        this.leafletInstance.on("contextmenu", (evt: L.LeafletMouseEvent) => {
            const context = new Menu(this.plugin.app);
            context.setNoIcon();
            context.addItem((item) => {
                item.setTitle("Add Creature Here");
                item.onClick((evt) => {
                    this.plugin.app.workspace.trigger(
                        "initiative-tracker:add-creature-here",
                        this.leafletInstance.mouseEventToLatLng(evt)
                    );
                });
            });
            context.showAtMouseEvent(evt.originalEvent);
        });

        this.on("first-layer-ready", () => {
            this.leafletInstance.fitBounds(this.currentLayer.getBounds());
        });

        this.addEvent(
            "initiative-tracker:creature-added-at-location",
            (creature: Creature, latlng: L.LatLng) => {
                this.addCreature({ latlng, creature });
            }
        );
        this.addEvent(
            "initiative-tracker:creatures-added",
            (creatures: Creature[]) => {
                this.addCreature(
                    ...creatures.map((c: Creature) => {
                        return {
                            creature: c
                        };
                    })
                );
            }
        );
        this.addEvent(
            "initiative-tracker:creatures-removed",
            (creatures: Creature[]) => {
                this.removeCreature(...creatures);
            }
        );
        this.addEvent(
            "initiative-tracker:creature-updated",
            (creature: Creature) => {
                if (!this.markerMap.has(creature.id)) {
                    this.addCreature({ creature });
                }
                const marker = this.markerMap.get(creature.id);
                marker.creature = creature;

                marker.updateCreature();
            }
        );
    }
    buildControls() {
        super.buildControls();

        this.leafletInstance.addControl(new ImageControl(this));
    }
    addCreature(...creatures: { latlng?: L.LatLng; creature: Creature }[]) {
        let toReturn: Marker[] = [];
        for (const { latlng, creature } of creatures) {
            let marker = new InitiativeMarker(
                this,
                latlng ?? this.leafletInstance.getCenter(),
                creature
            );
            toReturn.push(marker);

            this.markerMap.set(creature.id, marker);
        }
        return toReturn;
    }
    removeCreature(...creatures: Creature[]) {
        for (const creature of creatures) {
            if (this.markerMap.has(creature.id)) {
                const marker = this.markerMap.get(creature.id);
                marker.remove();
                this.markerMap.delete(creature.id);
            }
        }
    }
}

class InitiativeMarker extends Marker {
    creature: Creature;
    initIcon: InitiativeDivIcon;
    enabled: boolean;
    hp: number;
    status: Set<any>;
    constructor(map: BaseMapType, latlng: L.LatLng, creature: Creature) {
        if (!map.markerTypes.includes(creature.marker)) {
            creature.marker = "default";
        }
        const markerIcon = map.markerIcons.get(creature.marker);

        const initIcon = new InitiativeDivIcon(
            {
                html: (markerIcon ?? map.defaultIcon).html,
                className: "leaflet-div-icon"
            },
            creature
        );

        super(map, {
            id: creature.name,
            type: creature.marker,
            icon: initIcon,
            layer: null,
            mutable: true,
            command: false,
            zoom: null,
            percent: null,
            description: null,
            tooltip: "always",
            link: creature.name,
            loc: latlng
        });
        this.creature = creature;
        if (this.creature.enabled) {
            this.setEnabled();
        } else {
            this.setDisabled();
        }

        this.map.renderer.registerEvent(
            this.map.plugin.app.workspace.on(
                "initiative-tracker:active-change",
                (creature: Creature) => {
                    if (creature === this.creature) {
                        this.setActive();
                    } else {
                        this.setInactive();
                    }
                }
            )
        );

        this.status = this.creature.status;

        this.initIcon = initIcon;

        this.leafletInstance.off("contextmenu");
        this.leafletInstance.off("click");

        this.leafletInstance.on("click", async (evt: L.LeafletMouseEvent) => {
            if (this.map.isDrawing || this.map.controller.isDrawing) {
                this.map.onMarkerClick(this, evt);
                return;
            }
        });

        this.leafletInstance.on("contextmenu", (evt: L.LeafletMouseEvent) => {
            L.DomEvent.stopPropagation(evt);

            const menu = new Menu(this.map.plugin.app);

            menu.setNoIcon();
            menu.addItem((item) => {
                item.setTitle("Apply Damage/Healing").onClick(() => {
                    this.map.plugin.app.workspace.trigger(
                        "initiative-tracker:apply-damage",
                        this.creature
                    );
                });
            });
            menu.addItem((item) => {
                item.setTitle("Add Status").onClick(() => {
                    this.map.plugin.app.workspace.trigger(
                        "initiative-tracker:add-status",
                        this.creature
                    );
                });
            });
            menu.addItem((item) => {
                item.setTitle(
                    this.creature.enabled ? "Disable" : "Enable"
                ).onClick(() => {
                    this.map.plugin.app.workspace.trigger(
                        "initiative-tracker:enable-disable",
                        this.creature,
                        !this.creature.enabled
                    );
                });
            });
            menu.addItem((item) => {
                item.setTitle("Remove Creature").onClick(() => {
                    this.map.plugin.app.workspace.trigger(
                        "initiative-tracker:remove",
                        this.creature
                    );
                });
            });
            menu.showAtMouseEvent(evt.originalEvent);
        });
        this.leafletInstance.on("mouseover", () => {
            this.popup.leafletInstance.bringToFront();
        });
    }
    onShow() {
        if (this.tooltip === "always" && this.target) {
            this.popup.open(this.target.display);
        }
    }

    updateCreature() {
        if (this.enabled != this.creature.enabled) {
            if (!this.creature.enabled) {
                this.setDisabled();
            } else {
                this.setEnabled();
            }
        }
        if (!isNaN(Number(this.creature.hp)) && this.creature.hp != this.hp) {
            this.updateHP(this.creature.hp);
        }
        if (this.link != this.creature.name) {
            this.link = this.creature.name;
        }

        if (this.creature.marker != this.type) {
            if (!this.map.markerTypes.includes(this.creature.marker)) {
                new Notice(
                    t(
                        `Marker type "%1" does not exist, using default.`,
                        this.creature.marker
                    )
                );
                this.creature.marker = "default";
            }
            const markerIcon = this.map.markerIcons.get(this.creature.marker);

            const initIcon = new InitiativeDivIcon(
                {
                    html: (markerIcon ?? this.map.defaultIcon).html,
                    className: "leaflet-div-icon"
                },
                this.creature
            );

            this.icon = markerIcon;
            this.divIcon = initIcon;
        }

        this.initIcon.syncStatuses();
    }

    setDisabled() {
        this.enabled = false;
        this.leafletInstance
            ?.getElement()
            ?.addClass("initiative-marker-disabled");
    }
    setEnabled() {
        this.enabled = true;
        this.leafletInstance
            ?.getElement()
            ?.removeClass("initiative-marker-disabled");
    }
    updateHP(hp: number) {
        this.hp = hp;
        this.initIcon.updateHP(hp);
    }
    setActive() {
        this.leafletInstance
            ?.getElement()
            ?.addClass("initiative-marker-active");
    }
    setInactive() {
        this.leafletInstance
            ?.getElement()
            ?.removeClass("initiative-marker-active");
    }
}

class InitiativeDivIcon extends MarkerDivIcon {
    progress: HTMLProgressElement;
    status: HTMLDivElement;
    constructor(options: MarkerDivIconOptions, public creature: Creature) {
        super(options);
    }
    createIcon(oldIcon: HTMLElement) {
        const div = super.createIcon(oldIcon);
        if (this.creature.hp) {
            this.addHPBar();
            this.updateHP(this.creature.hp);

            this.status = this.div.createDiv(
                "initiative-marker-status-container"
            );
            this.syncStatuses();
        }
        return div;
    }
    addHPBar() {
        this.progress = this.div.createEl("progress", {
            attr: {
                min: 0,
                max: this.creature.max
            }
        });
    }
    updateHP(hp: number) {
        this.progress.setAttr("value", hp);
    }
    syncStatuses() {
        this.status.empty();
        for (let status of this.creature.status) {
            if (StatusMap.has(status.name)) {
                const node = StatusMap.get(status.name);
                node.setAttr("aria-label", status.name);
                node.setAttr("aria-label-position", "top");
                this.status.appendChild(node);
            }
        }
    }
}



================================================
FILE: src/l10n/README.md
================================================
## Localization

The plugin has full localization support, and will attempt to load the current Obsidian locale. If one does not exist, it will fall back to English.

### Adding a new Locale

New locales can be added by creating a pull request. Two things should be done in this pull request:

1. Create the locale in the `locales` folder by copying the `en.ts` file. This file should be given a name matching the string returned by `moment.locale()`.
2. Create the translation by editing the value of each property.
3. Add the import in `locales.ts`.
4. Add the language to the `localeMap` variable.

#### Wildcards

Some strings in the locale have wildcards in them, such as `%1`. This is used by the plugin to insert dynamic data into the translated string.

For example:

`Loading Obsidian Leaflet v%1`: The plugin will insert the version number for `%1`.

This allows control of plural syntaxes or placement of file names in the sentence.



================================================
FILE: src/l10n/locale.ts
================================================
import en from "./locales/en";
import zhCN from "./locales/zh_CN";

const lang = window.localStorage.getItem("language");

const localeMap: { [k: string]: Partial<typeof en> } = {
    en,
    zh: zhCN
};
const userLocale = localeMap[lang || "en"];

export default function t(str: keyof typeof en, ...inserts: string[]): string {
    let localeStr = (userLocale && userLocale[str]) ?? en[str] ?? str;

    for (let i = 0; i < inserts.length; i++) {
        localeStr = localeStr.replace(`%${i + 1}`, inserts[i]);
    }

    return localeStr;
}



================================================
FILE: src/l10n/locales/en.ts
================================================
export default {
    //main.ts
    "Loading Obsidian Leaflet v%1": "Loading Obsidian Leaflet v%1", //version number
    "Open Leaflet Map": "Open Leaflet Map",
    "Unloading Obsidian Leaflet": "Unloading Obsidian Leaflet",
    "Obsidian Leaflet maps must have an ID.":
        "Obsidian Leaflet maps must have an ID.",
    "ID required": "ID required",
    "There was an error saving into the configured directory.":
        "There was an error saving into the configured directory.",

    //renderer.ts
    "Could not parse GeoJSON file": "Could not parse GeoJSON file",
    "Could not parse overlay radius. Please make sure it is in the format `<length> <unit>`.":
        "Could not parse overlay radius. Please make sure it is in the format `<length> <unit>`.",
    "There was an error with the provided latitude. Using default.":
        "There was an error with the provided latitude. Using default.",
    "There was an error with the provided longitude. Using default.":
        "There was an error with the provided longitude. Using default.",

    //loader.ts
    "There was an issue getting the image dimensions.":
        "There was an issue getting the image dimensions.",

    //watcher.ts
    "There was an error updating the marker for %1.":
        "There was an error updating the marker for %1.", //file name
    "There was an error updating the marker type for %1.":
        "There was an error updating the marker type for %1.", //file name
    "There was an error updating the markers for %1.":
        "There was an error updating the markers for %1.", //file name

    //utils.ts
    "Coordinates copied to clipboard.": "Coordinates copied to clipboard.",
    "There was an error trying to copy coordinates to clipboard.":
        "There was an error trying to copy coordinates to clipboard.",
    "There was an error rendering the map":
        "There was an error rendering the map",
    "Unparseable height provided.": "Unparseable height provided.",
    "There was a problem with the provided height. Using 500px.":
        "There was a problem with the provided height. Using 500px.",
    "Could not parse latitude": "Could not parse latitude",
    "Could not parse longitude": "Could not parse longitude",
    "No data for marker %1.": "No data for marker %1.", //marker code block definition
    "The `%1` field%2 can only be used with the Dataview plugin installed.":
        "The `%1` field%2 can only be used with the Dataview plugin installed.", //parameter name, plural
    "Could not parse location in %1": "Could not parse location in %1", //file name
    "Could not parse map overlay length in %1. Please ensure it is in the format: <distance> <unit>":
        "Could not parse map overlay length in %1. Please ensure it is in the format: <distance> <unit>", //file name
    "%1 overlay": "%1 overlay", //file name
    "Could not parse %1 in %2. Please ensure it is in the format: <distance> <unit>":
        "Could not parse %1 in %2. Please ensure it is in the format: <distance> <unit>", //overlayTag, file name

    //units.ts
    meters: "meters",
    petameters: "petameters",
    terameters: "terameters",
    gigameters: "gigameters",
    megameters: "megameters",
    kilometers: "kilometers",
    hectometers: "hectometers",
    decameters: "decameters",
    decimeters: "decimeters",
    centimeters: "centimeters",
    millimeters: "millimeters",
    micrometers: "micrometers",
    nanometers: "nanometers",
    picometers: "picometers",
    femtometers: "femtometers",
    feet: "feet",
    inches: "inches",
    yards: "yards",
    miles: "miles",
    "nautical miles": "nautical miles",

    //settings.ts
    "Obsidian Leaflet Settings": "Obsidian Leaflet Settings",
    "Default Map Marker": "Default Map Marker",
    "This marker is always available.": "This marker is always available.",
    "Icon Name": "Icon Name",
    "A default marker must be defined.": "A default marker must be defined",
    "The selected icon does not exist in Font Awesome Free.":
        "The selected icon does not exist in Font Awesome Free.",
    "Upload Image": "Upload Image",
    "Marker Color": "Marker Color",
    "Layer Base Marker": "Layer Base Marker",
    "Use as base layer for additional markers by default.":
        "Use as base layer for additional markers by default.",
    "Additional Map Markers": "Additional Map Markers",
    "Add Additional": "Add Additional",
    "These markers will be available in the right-click menu on the map.":
        "These markers will be available in the right-click menu on the map.",
    "Default Latitude": "Default Latitude",
    "Real-world maps will open to this latitude if not specified.":
        "Real-world maps will open to this latitude if not specified.",
    "Latitude must be a number.": "Latitude must be a number.",
    "Default Longitude": "Default Longitude",
    "Real-world maps will open to this longitude if not specified.":
        "Real-world maps will open to this longitude if not specified.",
    "Longitude must be a number.": "Longitude must be a number.",
    "Reset to Default": "Reset to Default",
    "Please back up your data before changing this setting.":
        "Please back up your data before changing this setting.",
    "Current directory": "Current directory",
    "Default Config Directory": "Default Config Directory",
    "Default Marker Tooltip Behavior": "Default Marker Tooltip Behavior",
    "New markers will be created to this setting by default. Can be overridden per-marker.":
        "New markers will be created to this setting by default. Can be overridden per-marker.",
    Always: "Always",
    Hover: "Hover",
    Never: "Never",
    "Display Note Preview": "Display Note Preview",
    "Markers linked to notes will show a note preview when hovered.":
        "Markers linked to notes will show a note preview when hovered.",
    "Display Overlay Tooltips": "Display Overlay Tooltips",
    "Overlay tooltips will display when hovered.":
        "Overlay tooltips will display when hovered.",
    "Copy Coordinates on Shift-Click": "Copy Coordinates on Shift-Click",
    "Map coordinates will be copied to the clipboard when shift-clicking.":
        "Map coordinates will be copied to the clipboard when shift-clicking.",
    "This setting is experimental and could cause marker data issues. Use at your own risk.":
        "This setting is experimental and could cause marker data issues. Use at your own risk.",
    "Import Marker CSV File": "Import Marker CSV File",
    "Choose File": "Choose File",
    "Upload CSV File": "Upload CSV File",
    "Map not specified for line %1": "Map not specified for line %1", //line number in csv
    "Could not parse latitude for line %1":
        "Could not parse latitude for line %1", //line number in csv
    "Could not parse longitude for line %1":
        "Could not parse longitude for line %1", //line number in csv
    "Marker file successfully imported.": "Marker file successfully imported.",
    "There was an error while importing %1":
        "There was an error while importing %1", //csv file name
    "Export Marker Data": "Export Marker Data",
    "Export all marker data to a CSV file.":
        "Export all marker data to a CSV file.",
    Export: "Export",
    "Enable Draw Mode by Default": "Enable Draw Mode by Default",
    "The draw control will be added to maps by default. Can be overridden with the draw map block parameter.":
        "The draw control will be added to maps by default. Can be overridden with the draw map block parameter.",
    "Default Units": "Default Units",
    "Select the default system of units for the map.":
        "Select the default system of units for the map.",
    "Default Tile Server": "Default Tile Server",
    "It is up to you to ensure you have proper access to this tile server.":
        "It is up to you to ensure you have proper access to this tile server.",
    "Default Tile Server Attribution": "Default Tile Server Attribution",
    "Please ensure your attribution meets all requirements set by the tile server.":
        "Please ensure your attribution meets all requirements set by the tile server.",
    "Default Tile Server (Dark Mode)": "Default Tile Server (Dark Mode)",

    Imperial: "Imperial",
    Metric: "Metric",
    "Only display when zooming out above this zoom.":
        "Only display when zooming out above this zoom.",
    "Only display when zooming in below this zoom.":
        "Only display when zooming in below this zoom.",
    "Reset": "Reset",
    "Default Tile Server Subdomains": "Default Tile Server Subdomains",
    "Available subdomains for this tile server concurrent requests.":
        "Available subdomains for this tile server concurrent requests. Spilt by ',', etc. 'a,b,c'",

    //modals/settings.ts
    "Marker Name": "Marker Name",
    "Marker name already exists.": "Marker name already exists.",
    "Marker name cannot be empty.": "Marker name cannot be empty.",
    "Font Awesome icon name (e.g. map-marker).":
        "Font Awesome icon name (e.g. map-marker).",
    "Use Image for Icon": "Use Image for Icon",
    "Layer Icon": "Layer Icon",
    "The icon will be layered on the base icon.":
        "The icon will be layered on the base icon.",
    "Override default icon color.": "Override default icon color.",
    Save: "Save",
    "Marker type already exists.": "Marker type already exists.",
    "Invalid icon name.": "Invalid icon name.",
    "Icon cannot be empty.": "Icon cannot be empty.",
    Cancel: "Cancel",

    //modals/path.ts
    Type: "Type",
    "to link heading": "to link heading",
    "to link blocks": "to link blocks",
    Note: "Note",
    "Blocks must have been created already":
        "Blocks must have been created already",

    //modals/mapview.ts
    "There was an error parsing the JSON.":
        "There was an error parsing the JSON.",

    //modals/context.ts
    "Execute Command": "Execute Command",
    "The marker will execute an Obsidian command on click":
        "The marker will execute an Obsidian command on click",
    "Command to Execute": "Command to Execute",
    "Name of Obsidian Command to execute":
        "Name of Obsidian Command to execute",
    Command: "Command",
    "Note to Open": "Note to Open",
    "Path of note to open": "Path of note to open",
    Path: "Path",
    "Marker Type": "Marker Type",
    Default: "Default",
    "Display Tooltip": "Display Tooltip",
    "Min Zoom": "Min Zoom",
    "Only display when zooming in below this zoom. Current map minimum":
        "Only display when zooming in below this zoom. Current map minimum",
    "Minimum zoom must be a number.": "Minimum zoom must be a number.",
    "Max Zoom": "Max Zoom",
    "Only display when zooming out above this zoom. Current map maximum":
        "Only display when zooming out above this zoom. Current map maximum",
    "Maximum zoom must be a number.": "Maximum zoom must be a number.",
    "Associate Tags": "Associate Tags",
    "Markers created from this tag using ": "Markers created from this tag using ",
    " will use this marker icon by default.": " will use this marker icon by default.",
    "Delete Marker": "Delete Marker",
    "Overlay Radius": "Overlay Radius",
    "Circle radius in": "Circle radius in",
    "Radius must be greater than 0.": "Radius must be greater than 0.",
    "Overlay Description": "Overlay Description",
    "Overlay Color": "Overlay Color",
    "Delete Overlay": "Delete Overlay",

    //modals/geojson.ts
    "File Name": "File Name",
    "Enter a file name.": "Enter a file name.",

    //map/view.ts
    "Leaflet Map": "Leaflet Map",

    //map/map.ts
    'Marker type "%1" does not exist, using default.':
        'Marker type "%1" does not exist, using default.', //marker type
    "There was an error saving the overlay.":
        "There was an error saving the overlay.",
    "There was an error adding GeoJSON to map":
        "There was an error adding GeoJSON to map",
    "There was an error adding GPX to map":
        "There was an error adding GPX to map",
    "Edit Overlay": "Edit Overlay",
    "Create Marker": "Create Marker",
    "OpenStreetMap has restricted the use of its tile server in Obsidian. Your map may break at any time. Please switch to a different tile server.":
        "OpenStreetMap has restricted the use of its tile server in Obsidian. Your map may break at any time. Please switch to a different tile server.",
    "There was an issue parsing the tile layer: %1":
        "There was an issue parsing the tile layer: %1",
    "OpenStreetMap cannot be turned off without specifying additional tile servers.":
        "OpenStreetMap cannot be turned off without specifying additional tile servers.",
    //layer/marker.ts
    "No command found!": "No command found!",
    "This marker cannot be edited because it was defined in the code block.":
        "This marker cannot be edited because it was defined in the code block.",
    "This overlay cannot be edited because it was defined in the code block.":
        "This overlay cannot be edited because it was defined in the code block.",
    "Edit Marker": "Edit Marker",
    "Convert to Code Block": "Convert to Code Block",
    "Leaflet: Could not create icon for %1 - does this type exist in settings?":
        "Leaflet: Could not create icon for %1 - does this type exist in settings?",

    //layer/gpx.ts
    Lat: "Lat",
    Lng: "Lng",
    Time: "Time",
    Elevation: "Elevation",
    Speed: "Speed",
    Pace: "Pace",
    Temperature: "Temperature",
    "Heart Rate": "Heart Rate",
    Cadence: "Cadence",
    spm: "spm",

    //controls/zoom.ts
    "Show All Markers": "Show All Markers",

    //controls/reset.ts
    "Reset View": "Reset View",

    //controls/mapview.ts
    "Edit View Parameters": "Edit View Parameters",
    "Save Parameters to View": "Save Parameters to View",

    //controls/gpx.ts
    "Zoom to %1 GPX Track%2": "Zoom to %1 GPX Track%2", //number of tracks, plural
    Heatlines: "Heatlines",
    "Zoom to GPX": "Zoom to GPX",
    Deselect: "Deselect",

    //controls/filter.ts
    All: "All",
    None: "None",
    "Filter Markers": "Filter Markers",

    //control/edit.ts
    "Bulk Edit Markers": "Bulk Edit Markers",
    "Delete All": "Delete All",
    marker: "marker",
    markers: "markers",
    "Add New": "Add New",
    "There was an issue with the provided latitude.":
        "There was an issue with the provided latitude.",
    "There was an issue with the provided longitude.":
        "There was an issue with the provided longitude.",
    //draw
    Draw: "Draw",
    Polygon: "Polygon",
    Polyline: "Polyline",
    Rectangle: "Rectangle",
    "Free Draw": "Free Draw",
    "Delete Shapes": "Delete Shapes",
    Done: "Done",
    Text: "Text",
    Color: "Color",
    "Fill Color": "Fill Color",
    "Move Shapes": "Move Shapes",
    "Export Drawing to GeoJSON": "Export Drawing to GeoJSON",
};



================================================
FILE: src/l10n/locales/zh_CN.ts
================================================
export default {
    //main.ts
    "Loading Obsidian Leaflet v%1": "加载Obsidian Leaflet版本 v%1", //version number
    "Open Leaflet Map": "打开 Leaflet 地图",
    "Unloading Obsidian Leaflet": "卸载 Obsidian Leaflet 中",
    "Obsidian Leaflet maps must have an ID.":
        "Obsidian Leaflet 地图必须包含 ID.",
    "ID required": "ID 必填",
    "There was an error saving into the configured directory.":
        "保存到配置的目录时出错.",

    //renderer.ts
    "Could not parse GeoJSON file": "无法解析 GeoJSON 文件",
    "Could not parse overlay radius. Please make sure it is in the format `<length> <unit>`.":
        "无法解析覆盖半径. 请确保格式为 `<长度> <单位>`.",
    "There was an error with the provided latitude. Using default.":
        "提供的纬度有误. 使用默认值.",
    "There was an error with the provided longitude. Using default.":
        "提供的经度有误. 使用默认值.",

    //loader.ts
    "There was an issue getting the image dimensions.":
        "获取图片尺寸时出错.",

    //watcher.ts
    "There was an error updating the marker for %1.":
        "更新 %1 的标记(marker)时出错", //file name
    "There was an error updating the marker type for %1.":
        "更新 %1 的标记类型(marker type)出现了错误", //file name
    "There was an error updating the markers for %1.":
        "更新 %1 的标记(markers)出现了错误", //file name

    //utils.ts
    "Coordinates copied to clipboard.": "坐标已复制到剪贴板.",
    "There was an error trying to copy coordinates to clipboard.":
        "尝试复制坐标到剪贴板时出错.",
    "There was an error rendering the map":
        "渲染地图时出错",
    "Unparseable height provided.": "无法解析的高度(height).",
    "There was a problem with the provided height. Using 500px.":
        "提供的显示高度(height)有误. 使用 500px.",
    "Could not parse latitude": "无法解析纬度(latitude)",
    "Could not parse longitude": "无法解析经度(longitude)",
    "No data for marker %1.": "标记(marker) %1 没有数据", //marker code block definition
    "The `%1` field%2 can only be used with the Dataview plugin installed.":
        "只有安装了 Dataview 插件，才能使用`%1`字段`%2`", //parameter name, plural
    "Could not parse location in %1": "无法解析 %1 中的位置", //file name
    "Could not parse map overlay length in %1. Please ensure it is in the format: <distance> <unit>":
        "无法解析 %1 中的地图叠加层长度，请确保其格式为：<距离> <单位>", //file name
    "%1 overlay": "%1 叠加层", //file name
    "Could not parse %1 in %2. Please ensure it is in the format: <distance> <unit>":
        "无法解析 %2 中的 %1，请确保其格式为：<距离> <单位>", //overlayTag, file name

    //units.ts
    meters: "米",
    petameters: "拍米",
    terameters: "太米",
    gigameters: "吉米",
    megameters: "兆米",
    kilometers: "千米",
    hectometers: "百米",
    decameters: "十米",
    decimeters: "分米",
    centimeters: "厘米",
    millimeters: "毫米",
    micrometers: "微米",
    nanometers: "纳米",
    picometers: "皮米",
    femtometers: "飞米",
    feet: "英尺",
    inches: "英寸",
    yards: "码",
    miles: "英里",
    "nautical miles": "海里",

    //settings.ts

    "Obsidian Leaflet Settings": "Obsidian Leaflet 设置",
    "Default Map Marker": "默认地图标记",
    "This marker is always available.": "此标记始终可用",
    "Icon Name": "图标名称",
    "A default marker must be defined.": "必须定义默认标记",
    "The selected icon does not exist in Font Awesome Free.":
        "所选图标不存在于 Font Awesome Free 中",
    "Upload Image": "上传图片",
    "Marker Color": "标记颜色",
    "Layer Base Marker": "图层基本标记",
    "Use as base layer for additional markers by default.":
        "默认情况下，将其用作附加标记的基本图层",
    "Additional Map Markers": "附加地图标记",
    "Add Additional": "添加附加",
    "These markers will be available in the right-click menu on the map.":
        "这些标记将在地图上的右键菜单可选",
    "Default Latitude": "默认纬度",
    "Real-world maps will open to this latitude if not specified.":
        "如果未指定，则使用此纬度作为默认值",
    "Latitude must be a number.": "纬度必须是数字",
    "Default Longitude": "默认经度",
    "Real-world maps will open to this longitude if not specified.":
        "如果未指定，则使用此经度作为默认值",
    "Longitude must be a number.": "经度必须是数字",
    "Reset to Default": "重置为默认值",
    "Please back up your data before changing this setting.":
        "在更改此设置之前，请先备份您的数据",
    "Current directory": "当前目录",
    "Default Config Directory": "默认配置目录",
    "Default Marker Tooltip Behavior": "何时显示默认标记提示",
    "New markers will be created to this setting by default. Can be overridden per-marker.":
        "新创建的标记将会加入到下面，在此处对不同的标记进行自定义设置提示方式", //TODO not understand this feature
    Always: "始终",
    Hover: "悬停",
    Never: "从不",
    "Display Note Preview": "显示笔记预览",
    "Markers linked to notes will show a note preview when hovered.":
        "当鼠标悬停在已经关联笔记的标记上时，会显示关联笔记的预览界面",
    "Display Overlay Tooltips": "显示叠加层提示",
    "Overlay tooltips will display when hovered.":
        "当鼠标悬停在叠加层上时显示提示",
    "Copy Coordinates on Shift-Click": "Shift-单击鼠标左键 时复制坐标",
    "Map coordinates will be copied to the clipboard when shift-clicking.":
        "当按下 Shift 并单击鼠标左键时，地图坐标将被复制到剪贴板",
    "This setting is experimental and could cause marker data issues. Use at your own risk.":
        "此设置是实验性的，可能会导致标记数据出现问题，请自行承担风险。",
    "Import Marker CSV File": "导入标记 CSV 文件",
    "Choose File": "选择文件",
    "Upload CSV File": "上传 CSV 文件",
    "Map not specified for line %1": "第 %1 行未指定地图", //line number in csv
    "Could not parse latitude for line %1":
        "无法解析第 %1 行的纬度1", //line number in csv
    "Could not parse longitude for line %1":
        "无法解析第 %1 行的经度", //line number in csv
    "Marker file successfully imported.": "标记文件已成功导入",
    "There was an error while importing %1":
        "导入 %1 时出错", //csv file name
    "Export Marker Data": "导出标记数据",
    "Export all marker data to a CSV file.":
        "将所有标记数据导出到 CSV 文件",
    Export: "导出",
    "Enable Draw Mode by Default": "默认启用绘制模式",
    "The draw control will be added to maps by default. Can be overridden with the draw map block parameter.":
        "默认情况下，地图会显示绘制控件，可以使用在地图参数配置中自定义关闭控件显示",//TODO not undderstand this feature
    "Default Units": "默认单位",
    "Select the default system of units for the map.":
        "选择地图的默认单位制",
    "Default Tile Server": "默认瓦片服务器(Tile Server)",
    "It is up to you to ensure you have proper access to this tile server.":
        "请确保您有权访问此瓦片服务器",
    "Default Tile Server Attribution": "默认瓦片服务器版权描述",
    "Please ensure your attribution meets all requirements set by the tile server.":
        "请确保您的版权符合瓦片服务器的所有要求，此段将显示在地图右下角",
    "Default Tile Server (Dark Mode)": "默认瓦片服务器（暗黑主题模式）",
    Imperial: "英制",
    Metric: "公制",
    "Only display when zooming out above this zoom.": "仅当缩放级别大于此缩放级别时显示",
    "Only display when zooming in below this zoom.": "仅当缩放级别小于此缩放级别时显示",
    "Reset": "重置为默认",
    "Default Tile Server Subdomains": "默认瓦片服务器子域",
    "Available subdomains for this tile server concurrent requests.":
        "瓦片服务器的子域列表，逗号','作为分隔符，如'a,b,c'，主要用来并发请求瓦片服务器,将会替换在瓦片服务器的's'参数",
    //modals/settings.ts
    "Marker Name": "标记名称",
    "Marker name already exists.": "标记名称已存在",
    "Marker name cannot be empty.": "标记名称不能为空",
    "Font Awesome icon name (e.g. map-marker).": "Font Awesome 图标名称（例如 map-marker）",
    "Use Image for Icon": "使用图片作为图标",
    "Layer Icon": "图标层",
    "The icon will be layered on the base icon.": "图标将叠加在基础图标上",
    "Override default icon color.": "覆盖默认图标颜色",
    Save: "保存",
    "Marker type already exists.": "标记类型已存在",
    "Invalid icon name.": "无效的图标名称",
    "Icon cannot be empty.": "图标不能为空",
    Cancel: "取消",

    //modals/path.ts
    Type: "类型",
    "to link heading": "链接标题",
    "to link blocks": "链接块",
    Note: "注意",
    "Blocks must have been created already": "块必须已经创建。",
//modals/mapview.ts
    "There was an error parsing the JSON.":
    "解析JSON时出错",

    //modals/context.ts
    "Execute Command": "执行命令",
    "The marker will execute an Obsidian command on click":
"点击标记将执行Obsidian命令",
    "Command to Execute": "要执行的命令",
    "Name of Obsidian Command to execute":
"要执行的Obsidian命令名称",
    Command: "命令",
    "Note to Open": "要打开的笔记",
    "Path of note to open": "要打开的笔记的路径",
    Path: "路径",
    "Marker Type": "标记类型",
    Default: "默认",
    "Display Tooltip": "显示提示信息",
    "Min Zoom": "最小缩放级别",
    "Only display when zooming in below this zoom. Current map minimum":
"只有在缩放级别低于此级别时才显示。当前地图最小级别",
    "Minimum zoom must be a number.": "最小缩放级别必须为数字",
    "Max Zoom": "最大缩放级别",
    "Only display when zooming out above this zoom. Current map maximum":
"只有在缩放级别高于此级别时才显示，当前地图最大级别",
    "Maximum zoom must be a number.": "最大缩放级别必须为数字",
    "Associate Tags": "关联标签",
    "Markers created from this tag using ": "属性",
    " will use this marker icon by default.":"指定tag中包含此处填写的tag，则从这个tag创建的地图标记将会使用当前标记图标",
    "Delete Marker": "删除标记",
    "Overlay Radius": "覆盖半径",
    "Circle radius in": "圆的半径为",
    "Radius must be greater than 0.": "半径必须大于0",
    "Overlay Description": "覆盖说明",
    "Overlay Color": "覆盖颜色",
    "Delete Overlay": "删除覆盖",

    //modals/geojson.ts
    "File Name": "文件名",
    "Enter a file name.": "输入文件名。",

    //map/view.ts
    "Leaflet Map": "Leaflet 地图",

//map/map.ts
    'Marker type "%1" does not exist, using default.': '标记类型 "%1" 不存在，使用默认值', //标记类型
    "There was an error saving the overlay.": "保存覆盖层时发生错误",
    "There was an error adding GeoJSON to map": "将 GeoJSON 添加到地图时出错",
    "There was an error adding GPX to map": "将 GPX 添加到地图时出错",
    "Edit Overlay": "编辑覆盖层",
    "Create Marker": "创建标记",
    "OpenStreetMap has restricted the use of its tile server in Obsidian. Your map may break at any time. Please switch to a different tile server.":
        "OpenStreetMap已经限制了在Obsidian中使用其瓦片服务器。您的地图随时可能会出现问题。请切换到其他的瓦片服务器。",
    "There was an issue parsing the tile layer: %1":
        "解析瓦片图层时出现问题：%1。",
    "OpenStreetMap cannot be turned off without specifying additional tile servers.":
        "没有指定其他瓦片服务器的情况下，无法关闭OpenStreetMap。",
//layer/marker.ts
    "No command found!": "未找到命令！",
    "This marker cannot be edited because it was defined in the code block.": "此标记无法编辑，因为它已经在代码块中被使用",
    "This overlay cannot be edited because it was defined in the code block.": "此覆盖层无法编辑，因为它已经在代码块中被使用",
    "Edit Marker": "编辑标记",
    "Convert to Code Block": "转换成代码块",
    "Leaflet: Could not create icon for %1 - does this type exist in settings?":
        "Leaflet：无法为%1创建图标-在设置中是否存在此类型？",

//layer/gpx.ts
    Lat: "纬度",
    Lng: "经度",
    Time: "时间",
    Elevation: "海拔高度",
    Speed: "速度",
    Pace: "配速",
    Temperature: "温度",
    "Heart Rate": "心率",
    Cadence: "步频",
    spm: "spm",

    //controls/zoom.ts
    "Show All Markers": "显示所有标记",

    //controls/reset.ts
    "Reset View": "重置视图",

    //controls/mapview.ts
    "Edit View Parameters": "编辑视图参数",
    "Save Parameters to View": "保存参数到视图",

    //controls/gpx.ts
    "Zoom to %1 GPX Track%2": "缩放到 %1 条 GPX 轨迹%2", //number of tracks, plural
    Heatlines: "热力线",
    "Zoom to GPX": "缩放到 GPX",
    Deselect: "取消选择",

    //controls/filter.ts
    All: "全部",
    None: "无",
    "Filter Markers": "筛选标记",

    //control/edit.ts
    "Bulk Edit Markers": "批量编辑标记",
    "Delete All": "全部删除",
    marker: "标记",
    markers: "标记",
    "Add New": "添加新的",
    "There was an issue with the provided latitude.": "提供的纬度存在问题",
    "There was an issue with the provided longitude.": "提供的经度存在问题",

    //draw
    Draw: "绘制",
    Polygon: "多边形",
    Polyline: "折线",
    Rectangle: "矩形",
    "Free Draw": "自由绘制",
    "Delete Shapes": "删除形状",
    Done: "完成",
    Text: "文本",
    Color: "颜色",
    "Fill Color": "填充颜色",
    "Move Shapes": "移动形状",
    "Export Drawing to GeoJSON": "导出绘制的GeoJSON",
};



================================================
FILE: src/layer/geojson.ts
================================================
import type { BaseMapType } from "../types";
import type geojson from "geojson";

import { Marker } from "./marker";

import {
    DESCRIPTION_ICON,
    MAP_OVERLAY_STROKE_OPACITY,
    MAP_OVERLAY_STROKE_WIDTH,
    MODIFIER_KEY
} from "src/utils";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { Layer } from "./layer";
import { formatLatLng } from "src/utils";
import { popup } from "src/map/popup";
import { LeafletMouseEvent } from "leaflet";
import { setIcon } from "obsidian";
let L = window[LeafletSymbol];

export class GeoJSON extends Layer<L.GeoJSON> {
    leafletInstance: L.GeoJSON;
    private _display: HTMLDivElement;
    popup = popup(this.map, this);
    markers: GeoJSONMarker[] = [];
    features: GeoJSONFeature[] = [];
    get group() {
        return this.map.featureLayer;
    }
    constructor(
        public map: BaseMapType,
        public parent: L.LayerGroup,
        public options: {
            color: string;
            pane?: string;
        },
        data: geojson.GeoJsonObject,
        public note?: string
    ) {
        super();
        this.leafletInstance = L.geoJSON(data, {
            pane: this.options.pane ?? "geojson",
            pointToLayer: (geojsonPoint, latlng) => {
                const marker = new GeoJSONMarker(this, geojsonPoint, latlng, {
                    /* icon: "default", */
                    pane: this.options.pane ?? "geojson"
                });
                this.markers.push(marker);
                return marker.leafletInstance;
            },
            style: (feature) => {
                if (!feature || !feature.properties) return {};

                const {
                    stroke: color = this.options.color,
                    "stroke-opacity": opacity = MAP_OVERLAY_STROKE_OPACITY,
                    "stroke-width": weight = MAP_OVERLAY_STROKE_WIDTH,
                    fill: fillColor = null,
                    "fill-opacity": fillOpacity = 0.2
                } = feature.properties;
                return {
                    color,
                    opacity,
                    weight,
                    fillColor,
                    fillOpacity
                };
            },
            onEachFeature: (feature, layer: L.GeoJSON) => {
                /** Propogate click */
                if (feature.geometry?.type == "Point") {
                    return;
                }
                const geo = new GeoJSONFeature(this, feature, layer);
                this.features.push(geo);
            }
        });

        if (note) {
            this.leafletInstance.on("click", async (evt: LeafletMouseEvent) => {
                await this.map.plugin.app.workspace.openLinkText(
                    this.note.replace("^", "#^").split(/\|/).shift(),
                    this.map.plugin.app.workspace.getActiveFile()?.path ?? "",
                    true
                );
            });
        }
    }
    get display() {
        if (!this._display) {
            this._display = createDiv();
        }
        return this._display;
    }
    addMarker(latlng: L.LatLng, icon?: string, pane?: string) {
        const marker = new GeoJSONMarker(this, null, latlng, {
            pane: pane ?? this.options.pane
        });
        this.markers.push(marker);
        return marker.leafletInstance;
    }
    toProperties() {}
    buildTooltip(
        title: string,
        { icon, description }: { icon?: boolean; description?: string }
    ) {
        let display: HTMLDivElement = createDiv({
            attr: { style: "text-align: left;" }
        });
        const titleEl = display.createDiv({
            attr: {
                style: "display: flex; justify-content: space-between;"
            }
        });
        const labelEl = titleEl.createEl("label", {
            text: title,
            attr: {
                style: "text-align: left;"
            }
        });
        if (icon) {
            setIcon(
                titleEl.createDiv({
                    attr: {
                        style: "margin-left: 0.5rem;"
                    }
                }),
                DESCRIPTION_ICON
            );
        }
        if (this.note && this.note.length) {
            setIcon(
                titleEl.createDiv({
                    attr: {
                        style: "margin-left: 0.5rem;"
                    }
                }),
                "note-glyph"
            );
        }
        if (description) {
            labelEl.setAttr("style", "font-weight: bolder; text-align: left;");
            display.createEl("p", {
                attr: {
                    style: "margin: 0.25rem 0; text-align: left;"
                },
                text: description
            });
        }
        return display;
    }
}

class GeoJSONMarker {
    marker: Marker;
    leafletInstance: L.Marker;
    title: string;
    description: string;
    iconDisplay: HTMLDivElement;
    descriptionDisplay: HTMLDivElement;
    get map() {
        return this.parent.map;
    }
    constructor(
        private parent: GeoJSON,
        feature: geojson.Feature<geojson.Point, any>,
        latlng: L.LatLng,
        options: { pane: string }
    ) {
        const type = feature?.properties["marker-symbol"] ?? "default";
        const icon =
            this.map.markerIcons.get(type) ??
            this.map.markerIcons.get("default");
        this.title =
            feature?.properties.title ?? feature?.properties.name ?? null;
        this.description = feature?.properties.description ?? null;
        if (this.title || this.parent.note) {
            this.iconDisplay = this.parent.buildTooltip(
                this.title ?? this.parent.note,
                {
                    icon: this.description != null
                }
            );
            this.descriptionDisplay = this.parent.buildTooltip(
                this.title ?? this.parent.note,
                {
                    description: this.description
                }
            );
        }

        this.leafletInstance = L.marker(latlng, {
            pane: options.pane,
            icon: icon.icon,
            draggable: false
        });

        //seems hacky but works :shrug:
        this.leafletInstance.setZIndexOffset(1000);

        this.leafletInstance.on("click", (evt: L.LeafletMouseEvent) => {
            if (
                (!evt.originalEvent.getModifierState("Shift") ||
                    !evt.originalEvent.getModifierState("Alt")) &&
                this.description
            ) {
                L.DomEvent.stop(evt);
                this.parent.popup
                    .setTarget(this.leafletInstance)
                    .open(this.descriptionDisplay);
                return;
            }
        });
        this.leafletInstance.on("mouseover", (evt: L.LeafletMouseEvent) => {
            if (this.map.isDrawing || !this.title) return;
            L.DomEvent.stop(evt);
            this.parent.popup
                .setTarget(this.leafletInstance)
                .open(this.iconDisplay);
        });
    }
}

class GeoJSONFeature {
    title: string;
    description: string;
    iconDisplay: HTMLDivElement;
    descriptionDisplay: HTMLDivElement;
    get map() {
        return this.parent.map;
    }
    getLatLngs() {
        if (this.leafletInstance instanceof L.Polyline)
            return this.leafletInstance.getLatLngs().flat(2);
    }
    constructor(
        private parent: GeoJSON,
        public feature: geojson.Feature<geojson.Geometry, any>,
        public leafletInstance: L.GeoJSON
    ) {
        this.title =
            feature.properties.title ?? feature.properties.name ?? null;
        this.description = feature.properties.description ?? null;
        if (this.title) {
            this.iconDisplay = this.parent.buildTooltip(this.title, {
                icon: this.description != null
            });
            this.descriptionDisplay = this.parent.buildTooltip(this.title, {
                description: this.description
            });
        }
        this.leafletInstance.on("mouseover", () => this.onLayerMouseover());
        this.leafletInstance.on("click", (evt: L.LeafletMouseEvent) =>
            this.onLayerClick(evt)
        );
    }
    onLayerMouseover() {
        if (!this.title && !this.description) return;
        if (this.map.isDrawing) return;
        this.parent.popup
            .setTarget(this.leafletInstance.getBounds().getCenter())
            .open(this.iconDisplay, this.leafletInstance);
    }
    onLayerClick(evt: L.LeafletMouseEvent) {
        if (evt.originalEvent.getModifierState(MODIFIER_KEY)) {
            this._focus();
            return;
        }
        if (
            (!evt.originalEvent.getModifierState("Shift") ||
                !evt.originalEvent.getModifierState("Alt")) &&
            this.title
        ) {
            this.parent.popup
                .setTarget(evt.latlng)
                .open(this.descriptionDisplay, this.leafletInstance);
            L.DomEvent.stopPropagation(evt);
            return;
        }
        this.map.leafletInstance.fire("click", evt, true);
    }

    private _focus() {
        const { lat, lng } = formatLatLng(
            this.leafletInstance.getBounds().getCenter()
        );

        this.map.log(
            `Feature was Control clicked. Moving to bounds [${lat}, ${lng}]`
        );

        this.map.leafletInstance.fitBounds(this.leafletInstance.getBounds());
    }
}



================================================
FILE: src/layer/gpx.ts
================================================
import type { BaseMapType } from "../types";
import { Layer } from "../layer/layer";

import { LeafletSymbol } from "src/utils/leaflet-import";
import { gpx as gpxtoGeoJSON } from "@tmcw/togeojson";

import gpxWorker from "../worker/gpx.worker";
import type { HotlineOptions } from "leaflet";
import { popup } from "src/map/popup";
import { GPXPoint } from "../types/layers";

import { GeoJSON } from "./geojson";
import { formatLatLng, formatNumber, getIcon, icon } from "src/utils";
import t from "src/l10n/locale";

import { GPX_Data } from "../types/gpx";
import { Position } from "geojson";
import convert from "convert";

let L = window[LeafletSymbol];

const locale = window.moment.locale;

const HOTLINE_OPTIONS: HotlineOptions = {
    weight: 3,
    outlineWidth: 1
};

interface NestedArray<T> extends Array<T | NestedArray<T>> {}

function getArrayDepth(value: NestedArray<number>): number {
    if (!value.length) return 0;
    if (!(value[0] instanceof Array)) return 0;
    return 1 + getArrayDepth(value[0]);
}

export class GPX extends Layer<L.GeoJSON> {
    geojson: GeoJSON;
    get leafletInstance() {
        return this.geojson.leafletInstance;
    }
    style: { opacity: string; color: string };
    hotline: L.Polyline;
    popup = popup(this.map, this, { permanent: true });
    gpx: GeoJSON.FeatureCollection;
    domObject: Record<any, any>;
    data: GPX_Data = {
        flags: {
            elevation: false,
            speed: false,
            hr: false,
            duration: false,
            atemp: false,
            cad: false
        }
    };
    worker: Worker;

    parsed: boolean;
    displaying: string;

    targeted: boolean = false;

    get group() {
        return this.map.featureLayer;
    }
    get renderer() {
        return this.map.canvas;
    }
    constructor(
        public map: BaseMapType,
        gpx: string,
        /* options: GPXOptions, */
        private icons: {
            start?: string;
            end?: string;
            waypoint?: string;
        }
    ) {
        super();

        this.map.log("Parsing GPX Data.");
        this.worker = new gpxWorker();

        if (this.icons.start && !this.map.markerIcons.has(this.icons.start)) {
            this.icons.start = "default";
        }
        if (this.icons.end && !this.map.markerIcons.has(this.icons.end)) {
            this.icons.end = "default";
        }
        if (
            this.icons.waypoint &&
            !this.map.markerIcons.has(this.icons.waypoint)
        ) {
            this.icons.waypoint = "default";
        }

        this.worker.postMessage({ string: gpx });

        this.worker.onmessage = (event) => {
            this.worker.terminate();
            if (event.data.error) {
                this.map.log("There was an error parsing GPX Data.");
                return;
            }
            this.map.log("GPX Data parsed.");
            this.data = event.data.data;
            this.parsed = true;
        };

        this.gpx = gpxtoGeoJSON(
            new DOMParser().parseFromString(gpx, "text/xml")
        );

        //add point types
        const coords: Position[] = [];
        this.gpx.features = this.gpx.features.map((feature) => {
            if (feature?.geometry?.type === "Point") {
                feature.properties = {
                    ...(feature.properties ?? {}),
                    "marker-symbol": this.icons.waypoint
                };
            } else if (feature?.geometry && "coordinates" in feature.geometry) {
                const coordinates = feature.geometry.coordinates;
                coords.push(
                    ...(coordinates.flat(
                        getArrayDepth(coordinates) - 1
                    ) as Position[])
                );
            }

            return feature;
        });
        if (this.icons.start) {
            this.gpx.features.push({
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: coords[0]
                },
                properties: {
                    "marker-symbol": this.icons.start
                }
            });
        }
        if (this.icons.end) {
            this.gpx.features.push({
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: coords[coords.length - 1]
                },
                properties: {
                    "marker-symbol": this.icons.end
                }
            });
        }
        this.geojson = new GeoJSON(
            this.map,
            this.group,
            {
                color: this.map.options.gpxColor,
                pane: "gpx"
            },
            this.gpx
        );

        this.leafletInstance.on("mouseover", (evt: L.LeafletMouseEvent) => {
            L.DomEvent.stop(evt);
            if (
                !this.map.leafletInstance.hasLayer(this.hotline) &&
                !this.targeted
            ) {
                this.leafletInstance
                    .getLayers()[0]
                    //@ts-expect-error
                    .getElement()
                    .addClass("leaflet-layer-targeted");
            }
        });
        this.leafletInstance.on("mouseout", (evt: L.LeafletMouseEvent) => {
            if (
                this.map.leafletInstance.hasLayer(this.hotline) ||
                this.targeted
            ) {
                this.popup.close();
            } else {
                this.deselect();
            }
        });
        this.leafletInstance.on("click", (evt: L.LeafletMouseEvent) => {
            if (!this.parsed) return;
            this.map.gpxControl.setTarget(this);
        });
        this.leafletInstance.on("mousemove", (evt: L.LeafletMouseEvent) => {
            if (!this.parsed) return;
            if (
                this.map.leafletInstance.hasLayer(this.hotline) ||
                this.targeted
            ) {
                const closest = this.findClosestPoint(evt.latlng);
                const content = this.popupContent(closest);
                this.popup.setTarget(evt.latlng).open(content);
            }
        });
    }
    switch(which: "cad" | "ele" | "hr" | "speed" | "default") {
        if (this.map.leafletInstance.hasLayer(this.hotline))
            this.hotline.remove();
        this.displaying = which;
        this.hide();
        switch (which) {
            case "cad": {
                this.hotline = L.hotline(this.cad.points, {
                    min: this.cad.min,
                    max: this.cad.max,
                    ...HOTLINE_OPTIONS,
                    renderer: this.renderer
                }).addTo(this.map.leafletInstance);
                break;
            }
            case "ele": {
                this.hotline = L.hotline(this.elevation.points, {
                    min: this.elevation.min,
                    max: this.elevation.max,
                    ...HOTLINE_OPTIONS,
                    renderer: this.renderer
                }).addTo(this.map.leafletInstance);
                break;
            }
            case "hr": {
                this.hotline = L.hotline(this.hr.points, {
                    min: this.hr.min,
                    max: this.hr.max,
                    ...HOTLINE_OPTIONS,
                    renderer: this.renderer
                }).addTo(this.map.leafletInstance);
                break;
            }
            case "speed": {
                this.hotline = L.hotline(this.speed.points, {
                    min: this.speed.min,
                    max: this.speed.max,
                    ...HOTLINE_OPTIONS,
                    renderer: this.renderer
                }).addTo(this.map.leafletInstance);
                break;
            }
            default: {
                this.show();
            }
        }
    }
    findClosestPoint(latlng: L.LatLng): GPXPoint {
        const sort = [...this.points];
        sort.sort(
            (a, b) =>
                this.map.leafletInstance.distance(a, latlng) -
                this.map.leafletInstance.distance(b, latlng)
        );
        return sort[0];
    }
    get flags(): Record<string, boolean> {
        return this.data.flags;
    }
    get points(): GPXPoint[] {
        return this.data?.coords.flat();
    }
    get duration() {
        return this.data.duration;
    }
    get speed() {
        return this.data.speed;
    }
    get cad() {
        return this.data.cad;
    }
    get elevation() {
        return this.data.elevation;
    }
    get hr() {
        return this.data.hr;
    }
    get atemp() {
        return this.data.atemp;
    }
    deselect() {
        this.switch("default");
        this.leafletInstance
            .getLayers()[0]
            //@ts-expect-error
            .getElement()
            .removeClass("leaflet-layer-targeted");
        this.targeted = false;
    }
    hide() {
        if (this.leafletInstance) {
            this.leafletInstance.setStyle({
                color: "transparent",
                weight: 10
            });
        }
    }
    show() {
        if (this.leafletInstance) {
            this.leafletInstance.setStyle({
                color: this.map.options.gpxColor,
                weight: 2
            });
        }
    }

    hotlines: Record<string, L.Polyline> = {};

    featureGroup: L.FeatureGroup;
    get polyline() {
        return this.featureGroup
            ?.getLayers()
            ?.filter((l) => l instanceof L.Polyline)
            ?.shift() as L.Polyline;
    }
    popupContent(point: GPXPoint): HTMLElement {
        const { lat, lng } = formatLatLng(point);

        const el = createDiv("gpx-popup");
        el.createSpan({ text: `${t("Lat")}: ${lat}, ${t("Lng")}: ${lng}` });
        if (point.meta.time) {
            el.createSpan({
                text: `${t("Time")}: ${point.meta.time.toLocaleString(
                    locale()
                )}`
            });
        }

        if (point.meta.elevation && !isNaN(point.meta.elevation)) {
            const unit =
                this.map.plugin.unitSystemForUnit(this.map.unit) === "imperial"
                    ? "ft"
                    : "m";
            const previous = this.points[this.points.indexOf(point) - 1];
            let delta =
                point.meta.elevation -
                (previous?.meta?.elevation ?? point.meta.elevation);

            const elevation = convert(point.meta.elevation).from("m").to(unit);
            const elevationEl = el.createDiv("elevation gpx-elevation");
            elevationEl.createSpan({
                text: `${t("Elevation")}: ${formatNumber(
                    elevation,
                    2
                )} ${unit} (`
            });

            let iconEl: Element;
            let cls: string;
            const converted = formatNumber(
                convert(delta).from("m").to(unit),
                1
            );
            if (Number(converted) > 0) {
                iconEl = icon(getIcon("angle-up")).node[0];
                cls = "elevation-gain";
            } else if (Number(converted) < 0) {
                iconEl = icon(getIcon("angle-down")).node[0];
                cls = "elevation-loss";
            } else {
                iconEl = createSpan();
                cls = "";
            }
            const gainLoss = elevationEl.createSpan(cls);
            gainLoss.appendChild(iconEl);
            gainLoss.createSpan({
                text: `${Math.abs(Number(converted))}${unit}`
            });
            elevationEl.createSpan({ text: ")" });
        }
        if (point.meta.speed && !isNaN(point.meta.speed)) {
            let speed = point.meta.speed,
                unit: string,
                pace: string;
            switch (this.map.plugin.unitSystemForUnit(this.map.unit)) {
                case "metric": {
                    //kmh
                    speed = convert(speed).from("m").to("km") * 60 * 60;
                    unit = "km/h";
                    pace = "km";
                    break;
                }
                case "imperial": {
                    //mph
                    speed = convert(speed).from("m").to("mi") * 60 * 60;
                    unit = "mph";
                    pace = "mi";
                    break;
                }
            }
            el.createSpan({
                text: `${t("Speed")}: ${formatNumber(speed, 2)} ${unit}`
            });
            el.createSpan({
                text: `${t("Pace")}: ${formatNumber(60 / speed, 2)}"/${pace}`
            });
        }
        if (point.meta.atemp && !isNaN(point.meta.atemp))
            el.createSpan({
                text: `${t("Temperature")}: ${formatNumber(
                    point.meta.atemp,
                    2
                )} °C`
            });
        if (point.meta.hr && !isNaN(point.meta.hr))
            el.createSpan({
                text: `${t("Heart Rate")}: ${formatNumber(point.meta.hr, 2)}`
            });
        if (point.meta.cad && !isNaN(point.meta.cad))
            el.createSpan({
                text: `${t("Cadence")}: ${formatNumber(point.meta.cad, 2)} ${t(
                    "spm"
                )}`
            });
        return el;
    }
    toProperties() {}
}



================================================
FILE: src/layer/index.ts
================================================
export * from "./marker";
export * from "./overlay";
export * from "../layer/geojson";
export * from "./gpx";



================================================
FILE: src/layer/layer.ts
================================================
import { BaseMapType, LayerGroup, Popup } from "../../types";

export abstract class Layer<T extends L.Layer> {
    map: BaseMapType;
    layer: string;

    abstract popup: Popup;

    get mapLayer() {
        if (!this.layer) {
            return this.map.mapLayers[0];
        }
        return (
            this.map.mapLayers?.find(({ id }) => id === this.layer) ??
            this.map.mapLayers[0]
        );
    }

    abstract leafletInstance: T;
    abstract get group(): L.LayerGroup;

    onShow() {}
    show() {
        if (this.group) {
            this.group.addLayer(this.leafletInstance);
        }
        this.onShow();
    }
    onHide() {}
    hide() {
        this.group && this.group.removeLayer(this.leafletInstance);
    }

    registerForShow(cb: (...args: any[]) => any) {
        if (this.map.isLayerRendered(this.layer)) {
            cb();
        } else if (this.layer) {
            this.map.on(`layer-ready-for-features`, (layer) => {
                if (this.layer === layer) {
                    cb();
                }
            });
        } else {
            this.map.on("first-layer-ready", (layer) => {
                this.layer = layer;
                cb();
            });
        }
    }

    checkAndAddToMap() {
        this.registerForShow(this.show.bind(this));
    }
    remove() {
        this.group && this.group.removeLayer(this.leafletInstance);
    }

    abstract toProperties(): any;
}



================================================
FILE: src/layer/marker.ts
================================================
import { App, Menu, Notice, setIcon } from "obsidian";
import type {
    MarkerIcon,
    DivIconMarker,
    MarkerDivIcon,
    TooltipDisplay,
    MarkerProperties,
    SavedMarkerProperties,
    BaseMapType
} from "../../types";
import { MarkerContextModal } from "src/modals";
import { divIconMarker, markerDivIcon } from "src/map";
import { Layer } from "../layer/layer";
import { popup } from "src/map/popup";
import { MODIFIER_KEY, OBSIDIAN_LEAFLET_POPOVER_SOURCE } from "src/utils";
import { copyToClipboard, formatLatLng } from "src/utils";

import { LeafletSymbol } from "../utils/leaflet-import";
import t from "src/l10n/locale";
let L = window[LeafletSymbol];

abstract class MarkerTarget {
    abstract text: string;
    abstract display: HTMLElement;
    abstract run(evt: L.LeafletMouseEvent): void;
}

class Text extends MarkerTarget {
    constructor(public text: string) {
        super();
    }
    get display() {
        return createSpan({ text: this.text });
    }
    async run() {}
}

class Link extends MarkerTarget {
    display: HTMLElement;
    get isInternal() {
        return (
            this.app.metadataCache.getFirstLinkpathDest(
                this.text.split(/(\^|\||#)/).shift(),
                ""
            ) != null
        );
    }
    constructor(
        private _text: string,
        private app: App,
        public description?: string
    ) {
        super();
        this.display = this._getDisplay();
    }
    get text() {
        return this._text;
    }
    set text(text: string) {
        this._text = text;
        this.display = this._getDisplay();
    }
    private _getDisplay() {
        if (!this.text) return;
        if (this.external)
            return createEl("a", {
                text: this.text,
                href: this.text,
                cls: "external-link"
            });
        if (this.description?.length) {
            const holder = createDiv();
            holder.createSpan({ text: this.description });
            if (this.text?.length) {
                holder.createEl("br");
                holder.createEl("br");
                holder.createSpan({
                    text: this.text
                        .replace(/(\^)/, " > ^")
                        .replace(/#/, " > ")
                        .split("|")
                        .pop(),
                    cls: "internal-link"
                });
            }
            return holder;
        } else {
            return createSpan({
                text: this.text
                    .replace(/(\^)/, " > ^")
                    .replace(/#/, " > ")
                    .split("|")
                    .pop()
            });
        }
    }
    get external() {
        return (
            !this.isInternal &&
            /((?:https?:\/\/)?(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b(?:[-a-zA-Z0-9@:%_\+.~#?&//=]*))/.test(
                this.text
            )
        );
    }
    async run(evt: L.LeafletMouseEvent) {
        /* if (!this.external) { */
        await this.app.workspace.openLinkText(
            this._text.replace("^", "#^").split(/\|/).shift(),
            this.app.workspace.getActiveFile()?.path ?? "",
            evt.originalEvent.getModifierState(MODIFIER_KEY)
        );
        /* } */
    }
}
class Command extends MarkerTarget {
    display: HTMLElement;
    constructor(private _text: string, private app: App) {
        super();
        this.display = this._getDisplay();
    }
    get text() {
        return this._text;
    }
    set text(text: string) {
        this._text = text;
        this.display = this._getDisplay();
    }
    get exists() {
        return this.app.commands.findCommand(this._text) != null;
    }
    get command() {
        return this.app.commands.findCommand(this._text);
    }
    private _getDisplay() {
        const div = createDiv({
            attr: {
                style: "display: flex; align-items: center;"
            }
        });
        if (this.exists) {
            setIcon(
                div.createSpan({
                    attr: {
                        style: "margin-right: 0.5em; display: flex; align-items: center;"
                    }
                }),
                "run-command"
            );
            div.createSpan({ text: this.command.name });
        } else {
            setIcon(
                div.createSpan({
                    attr: {
                        style: "margin-right: 0.5em; display: flex; align-items: center;"
                    }
                }),
                "cross"
            );
            div.createSpan({ text: t("No command found!") });
        }
        return div;
    }
    run(evt: L.LeafletMouseEvent) {
        if (this.exists) this.app.commands.executeCommandById(this._text);
    }
}

export class Marker extends Layer<DivIconMarker> {
    target: MarkerTarget;
    private _mutable: boolean;
    private _type: string;
    private _command: boolean;
    leafletInstance: DivIconMarker;
    loc: L.LatLng;
    percent: [number, number];
    id: string;
    layer: string;
    minZoom: number;
    maxZoom: number;
    description: string;
    divIcon: MarkerDivIcon;
    displayed: boolean;
    tooltip?: TooltipDisplay;
    popup = popup(this.map, this);
    private _icon: MarkerIcon;
    isBeingHovered: boolean = false;
    private _link: string;
    constructor(
        public map: BaseMapType,
        {
            id,
            type,
            loc,
            link,
            layer,
            mutable,
            command,
            percent,
            description,
            minZoom,
            maxZoom,
            tooltip
        }: MarkerProperties
    ) {
        super();

        const markerIcon =
            this.map.markerIcons.get(type) ??
            this.map.markerIcons.get("default");
        if (!markerIcon) {
            new Notice(
                t(
                    "Leaflet: Could not create icon for %1 - does this type exist in settings?",
                    type
                )
            );
            return;
        }
        const marker = markerIcon.markerIcon;
        const icon = markerDivIcon(this.map.plugin.parseIcon(marker));
        this.leafletInstance = divIconMarker(
            loc,
            {
                icon,
                keyboard: mutable && !this.map.options.lock,
                draggable: mutable && !this.map.options.lock,
                bubblingMouseEvents: true
            },
            {
                link: link,
                mutable: `${mutable}`,
                type: type
            }
        );

        this.id = id;
        this.type = type;
        this.loc = loc;
        this.description = description;
        this.layer = layer;
        this.mutable = mutable;
        this.command = command;
        this.divIcon = icon;
        this.percent = percent;
        this.tooltip = tooltip;

        if (command) {
            this.target = new Command(link, this.map.plugin.app);
        } else if (link) {
            this.target = new Link(link, this.map.plugin.app, this.description);
        } else if (description) {
            this.target = new Text(this.description);
        }

        this.link = link;

        this.minZoom = minZoom ?? marker?.minZoom ?? null;
        this.maxZoom = maxZoom ?? marker?.maxZoom ?? null;

        this.checkAndAddToMap();

        this.bindEvents();
    }

    get group() {
        return this.mapLayer?.markers[this.type];
    }
    private bindEvents() {
        this.leafletInstance
            .on("contextmenu", (evt: L.LeafletMouseEvent) => {
                L.DomEvent.stopPropagation(evt);
                if (evt.originalEvent.getModifierState("Shift")) {
                    this.map.beginOverlayDrawingContext(evt, this);
                    return;
                }
                if (!this.mutable) {
                    new Notice(
                        t(
                            "This marker cannot be edited because it was defined in the code block."
                        )
                    );
                    return;
                }

                const menu = new Menu();
                menu.setNoIcon();

                menu.addItem((item) => {
                    item.setTitle(t("Edit Marker")).onClick(() =>
                        this.editMarker()
                    );
                });
                menu.addItem((item) => {
                    item.setTitle(t("Convert to Code Block")).onClick(
                        async () => {
                            this.mutable = false;

                            this.map.trigger("create-immutable-layer", this);

                            this.map.trigger("should-save");
                        }
                    );
                });
                menu.addItem((item) => {
                    item.setTitle(t("Delete Marker")).onClick(() => {
                        this.map.removeMarker(this);
                    });
                });
                menu.showAtMouseEvent(evt.originalEvent);
            })
            .on("dblclick", (evt) => {
                if (!this.mutable) {
                    new Notice(
                        t(
                            "This marker cannot be edited because it was defined in the code block."
                        )
                    );
                    return;
                }
                L.DomEvent.stopPropagation(evt);
                this.editMarker();
            })
            .on("click", async (evt: L.LeafletMouseEvent) => {
                if (this.map.isDrawing || this.map.controller.isDrawing) {
                    this.map.onMarkerClick(this, evt);
                    return;
                }

                L.DomEvent.stopPropagation(evt);

                if (
                    evt.originalEvent.getModifierState("Alt") ||
                    evt.originalEvent.getModifierState("Shift")
                ) {
                    this.map.onMarkerClick(this, evt);
                    const latlng = formatLatLng(this.latLng);
                    this.popup.open(`[${latlng.lat}, ${latlng.lng}]`);

                    if (
                        this.map.data.copyOnClick &&
                        evt.originalEvent.getModifierState(MODIFIER_KEY)
                    ) {
                        await copyToClipboard(this.loc);
                    }

                    return;
                }
                if (this.target) {
                    this.target.run(evt);
                }
            })
            .on("dragstart", (evt: L.LeafletMouseEvent) => {
                L.DomEvent.stopPropagation(evt);
            })
            .on("drag", (evt: L.LeafletMouseEvent) => {
                this.map.trigger("marker-dragging", this);
                if (this.tooltip === "always" && this.popup) {
                    this.popup.setLatLng(evt.latlng);
                } else if (this.popup.isOpen()) {
                    this.popup.setLatLng(evt.latlng);
                }
            })
            .on("dragend", (evt: L.LeafletMouseEvent) => {
                const old = this.loc;
                this.setLatLng(this.leafletInstance.getLatLng());
                this.map.trigger("marker-data-updated", this, old);
            })
            .on("mouseover", (evt: L.LeafletMouseEvent) => {
                L.DomEvent.stopPropagation(evt);
                this.isBeingHovered = true;

                if (this.target) {
                    this.popup.open(this.target.display);
                }
                if (this.map.data.notePreview && this.link) {
                    this.map.plugin.app.workspace.trigger("hover-link", {
                        event: evt.originalEvent,
                        source: this.map.plugin.manifest.id,
                        hoverParent: {
                            state: { source: OBSIDIAN_LEAFLET_POPOVER_SOURCE }
                        },
                        targetEl: this.leafletInstance.getElement(),
                        linktext: this.link
                            .replace("^", "#^")
                            .split("|")
                            .shift(),
                        state: { source: OBSIDIAN_LEAFLET_POPOVER_SOURCE }
                    });
                }
            })
            .on("mouseout", (evt: L.LeafletMouseEvent) => {
                this.leafletInstance.closeTooltip();
                this.isBeingHovered = false;
            });
        this.map.leafletInstance.on("zoomanim", (evt: L.ZoomAnimEvent) => {
            //check markers
            if (this.shouldShow(evt.zoom)) {
                this.map.leafletInstance.once("zoomend", () => this.show());
            } else if (this.shouldHide(evt.zoom)) {
                this.hide();
            }
        });
        this.map.on("lock", () => {
            if (!this.mutable) return;
            this.registerForShow(() => {
                if (!this.leafletInstance.dragging) return;
                if (this.map.options.lock) {
                    this.leafletInstance.dragging.disable();
                } else {
                    this.leafletInstance.dragging.enable();
                }
                this.leafletInstance.options.keyboard = !this.map.options.lock;
            });
        });

        this.map.leafletInstance.on(
            "baselayerchange",
            (layer: L.LayersControlEvent) => {
                if (!(layer.layer as L.LayerGroup).hasLayer(this.group)) {
                    this.hide();
                } else {
                    this.show();
                }
            }
        );
    }
    editMarker() {
        let markerSettingsModal = new MarkerContextModal(this, this.map);

        markerSettingsModal.onClose = async () => {
            if (markerSettingsModal.deleted) {
                this.map.removeMarker(this);
                this.map.trigger("marker-deleted", this);
            } else {
                this.map.displaying.delete(this.type);
                this.map.displaying.set(
                    markerSettingsModal.tempMarker.type,
                    true
                );
                this.description = markerSettingsModal.tempMarker.description;
                this.link = markerSettingsModal.tempMarker.link;
                this.icon = this.map.markerIcons.get(
                    markerSettingsModal.tempMarker.type
                );
                this.tooltip = markerSettingsModal.tempMarker.tooltip;
                this.minZoom = markerSettingsModal.tempMarker.minZoom;
                this.maxZoom = markerSettingsModal.tempMarker.maxZoom;
                this.command = markerSettingsModal.tempMarker.command;

                if (
                    this.shouldShow(this.map.leafletInstance.getZoom()) &&
                    !this.displayed
                ) {
                    this.show();
                } else if (
                    this.shouldHide(this.map.leafletInstance.getZoom()) &&
                    this.displayed
                ) {
                    this.hide();
                }

                if (this.tooltip === "always") {
                    this.popup.open(this.target.display);
                } else {
                    this.popup.close();
                }

                this.map.trigger("marker-updated", this);
                this.map.trigger("should-save");
            }
        };
        markerSettingsModal.open();
    }
    get link() {
        return this._link;
    }
    set link(x: string) {
        if (this.leafletInstance.options?.icon) {
            this.leafletInstance.options.icon.setData({
                link: `${x}`
            });
        }
        if (!x || !x.length) {
            if (this.description && this.description.length)
                this.target = new Text(this.description);
            return;
        }
        if (!this.target || this.target instanceof Text) {
            if (this.command) {
                this.target = new Command(x, this.map.plugin.app);
            } else {
                this.target = new Link(
                    x,
                    this.map.plugin.app,
                    this.description
                );
            }
        }
        this._link = x.startsWith("#") ? this.map.options.context + x : x;
        if (this.target) this.target.text = x;
        if (this.popup && this.displayed && this.tooltip === "always")
            this.popup.open(this.target.display);
    }
    get command() {
        return this._command;
    }
    set command(b: boolean) {
        this._command = b;
        if (!this.link) return;
        if (b) {
            this.target = new Command(this.link, this.map.plugin.app);
        } else if (this.link) {
            this.target = new Link(
                this.link,
                this.map.plugin.app,
                this.description
            );
        } else if (this.description) {
            this.target = new Text(this.description);
        }
    }
    get mutable() {
        return this._mutable;
    }
    set mutable(x: boolean) {
        this._mutable = x;
        if (this.leafletInstance.options?.icon) {
            this.leafletInstance.options.icon.setData({
                mutable: `${x}`
            });
        }
    }

    get type() {
        return this._type;
    }
    set type(x: string) {
        this._type = x;
        if (this.leafletInstance.options?.icon) {
            this.leafletInstance.options.icon.setData({
                type: `${x}`
            });
        }
    }
    set icon(x: MarkerIcon) {
        this.type = x.type;
        this._icon = x;
        this.leafletInstance.setIcon(x.icon);
    }
    get latLng() {
        return this.loc;
    }

    get display() {
        const ret = [this.link];
        if (this.description) {
            ret.unshift(`${this.description} `, "(");
            ret.push(")");
        }
        return ret.join("");
    }

    setLatLng(latlng: L.LatLng) {
        this.loc = latlng;

        if (this.map.rendered && this.map.type === "image") {
            let { x, y } = this.map.leafletInstance.project(
                this.loc,
                this.map.zoom.max - 1
            );
            this.percent = [
                x / this.map.currentGroup.dimensions[0],
                y / this.map.currentGroup.dimensions[1]
            ];
        }
        this.leafletInstance.fire("drag", { latlng });
        this.leafletInstance.setLatLng(latlng);
    }

    show() {
        if (
            this.shouldShow(this.map.getZoom()) &&
            this.group &&
            !this.displayed
        ) {
            this.group.addLayer(this.leafletInstance);
            this.displayed = true;
            if (this.tooltip === "always" && this.target) {
                this.leafletInstance.on("add", () => {
                    this.popup.open(this.target.display);
                });
            }
        }
        this.onShow();
    }
    onShow() {}
    shouldShow(zoom: number) {
        if (this.minZoom == this.maxZoom && this.minZoom == null) return true;
        if (!this.displayed) {
            const min = this.minZoom ?? this.map.zoom.min;
            const max = this.maxZoom ?? this.map.zoom.max;
            if (min <= zoom && zoom <= max) {
                return this.map.displaying.get(this.type) ?? true;
            }
        }
        return false;
    }

    hide() {
        if (this.group && this.displayed) {
            this.remove();
            this.displayed = false;
            this.popup.close();
        }
    }
    shouldHide(zoom: number) {
        if (this.displayed) {
            const min = this.minZoom ?? this.map.zoom.min;
            const max = this.maxZoom ?? this.map.zoom.max;
            if (min > zoom || zoom > max) {
                return true;
            }
        }
    }

    static from(map: BaseMapType, properties: MarkerProperties) {
        return new Marker(map, properties);
    }

    toProperties(): SavedMarkerProperties {
        return {
            id: this.id,
            type: this.type,
            loc: [
                this.leafletInstance.getLatLng().lat,
                this.leafletInstance.getLatLng().lng
            ],
            link: this.link,
            layer: this.layer,
            mutable: this.mutable,
            command: this.command,
            percent: this.percent,
            description: this.description,
            minZoom: this.minZoom,
            maxZoom: this.maxZoom,
            tooltip: this.tooltip
        };
    }

    toCodeBlockProperties() {
        return [
            this.type,
            this.latLng.lat,
            this.latLng.lng,
            this.link,
            this.description,
            this.minZoom,
            this.maxZoom
        ];
    }

    remove() {
        this.group && this.group.removeLayer(this.leafletInstance);
        if (this.tooltip == "always") {
            this.popup.leafletInstance?.remove();
        }
    }
}



================================================
FILE: src/layer/overlay.ts
================================================
import convert from "convert";
import { Notice } from "obsidian";

import { BaseMapType, SavedOverlayData } from "../types";
import t from "src/l10n/locale";
import { popup } from "src/map/popup";
import { formatLatLng, formatNumber } from "src/utils";
import { DISTANCE_DECIMALS, MODIFIER_KEY } from "src/utils";
import { LeafletSymbol } from "src/utils/leaflet-import";
import { Layer } from "../layer/layer";

let L = window[LeafletSymbol];
export class Overlay extends Layer<L.Circle> {
    leafletInstance: L.Circle;

    popup = popup(this.map, this);

    get radius() {
        let radius = this.radiusInMeters;
        if (this.map.type == "image") {
            radius = convert(radius).from("m").to(this.map.unit);
            radius = radius / this.map.scale;
        }
        return radius;
    }
    setRadius(radius: number) {
        this.data.radius = radius;
        this.leafletInstance.setRadius(this.radius);
    }

    get radiusInMeters() {
        return convert(this.data.radius)
            .from(this.data.unit ?? "m")
            .to("m");
    }

    get mutable() {
        return this.data.mutable;
    }
    set mutable(b: boolean) {
        this.data.mutable = b;
    }
    setMutable(mutable: boolean) {
        this.data.mutable = mutable;
    }
    get color() {
        return this.data.color;
    }
    setColor(color: string) {
        this.data.color = color;
    }

    get id() {
        return this.data.id;
    }

    get latlng() {
        return this.leafletInstance.getLatLng();
    }

    get loc(): [number, number] {
        return [this.latlng.lat, this.latlng.lng];
    }

    get type() {
        if (this.data.id) {
            const marker = this.map.markers.find(
                ({ id }) => id === this.data.id
            );
            if (marker) return marker.type;
        }
        return "none";
    }

    get description() {
        let radius = convert(this.data.radius)
            .from(this.data.unit)
            .to(this.map.unit);
        if (this.type == "image") {
            radius = radius * this.map.scale;
        }
        if (this.data.desc) {
            return (
                this.data.desc +
                ` (${formatNumber(radius, DISTANCE_DECIMALS)} ${this.map.unit})`
            );
        } else {
            return `${formatNumber(radius, DISTANCE_DECIMALS)} ${
                this.map.unit
            }`;
        }
    }

    get group() {
        return this.mapLayer?.overlays[this.type];
    }

    get marker() {
        return this.data.marker;
    }

    constructor(public map: BaseMapType, public data: SavedOverlayData) {
        super();
        this.leafletInstance = L.circle(L.latLng(this.data.loc), {
            radius: this.radiusInMeters,
            color: this.color
        });

        this.layer = data.layer;

        this.checkAndAddToMap();

        this.bindEvents();
    }

    show() {
        if (this.group) {
            this.group.addLayer(this.leafletInstance);
        }
    }

    private bindEvents() {
        this.leafletInstance
            .on("contextmenu", (evt: L.LeafletMouseEvent) => {
                L.DomEvent.stopPropagation(evt);

                this.map.handleMapContext(evt, this);
            })
            .on("mouseover", (evt: L.LeafletMouseEvent) => {
                L.DomEvent.stopPropagation(evt);
                this.popup.open(this.description);
            })
            .on("click", (evt: L.LeafletMouseEvent) => {
                if (evt.originalEvent.getModifierState(MODIFIER_KEY)) {
                    this.focus();
                    return;
                }
                this.popup.open(this.description);
            });

        if (this.marker) {
            const markers = this.map.getMarkersById(this.marker);

            if (!markers || !markers.length) return;
            markers[0].leafletInstance.on(
                "drag",
                (evt: L.LeafletMouseEvent) => {
                    this.leafletInstance.setLatLng(
                        markers[0].leafletInstance.getLatLng()
                    );
                }
            );
        }
    }
    public isUnder(evt: L.LeafletMouseEvent) {
        const element = this.leafletInstance.getElement();
        if (!element) return false;
        const { clientX, clientY } = evt.originalEvent;
        const { x, y, width, height } = element.getBoundingClientRect();
        const radius = width / 2;
        const center = [x + width / 2, y + height / 2];

        return (
            this.mutable &&
            Math.pow(clientX - center[0], 2) +
                Math.pow(clientY - center[1], 2) <
                Math.pow(radius, 2)
        );
    }
    focus() {
        const { lat, lng } = formatLatLng(
            this.leafletInstance.getBounds().getCenter()
        );

        this.map.log(
            `Feature was Control clicked. Moving to bounds [${lat}, ${lng}]`
        );

        this.map.leafletInstance.fitBounds(this.leafletInstance.getBounds());
    }

    static from(map: BaseMapType, data: SavedOverlayData) {
        return new Overlay(map, data);
    }

    toProperties(): SavedOverlayData {
        return {
            radius: this.data.radius,
            loc: this.loc,
            color: this.color,
            layer: this.data.layer,
            id: this.data.id,
            unit: this.data.unit,
            desc: this.data.desc,
            mutable: this.mutable,
            tooltip: this.data.tooltip,
            marker: this.marker
        };
    }

    toCodeBlockProperties() {
        return [
            `[${this.color}`,
            `[${this.latlng.lat},${this.latlng.lng}]`,
            `${formatNumber(this.data.radius, DISTANCE_DECIMALS)} ${
                this.data.unit
            }`,
            `${this.description}]`
        ];
    }
}



================================================
FILE: src/map/divicon.ts
================================================
import { LeafletSymbol } from "src/utils/leaflet-import";
import { DivIconMarkerOptions, MarkerDivIconOptions } from "../../types";

const L = window[LeafletSymbol];
export class MarkerDivIcon extends L.DivIcon {
    options: MarkerDivIconOptions;
    div: HTMLElement;
    constructor(options: MarkerDivIconOptions) {
        super(options);
    }
    createIcon(oldIcon: HTMLElement) {
        const div = super.createIcon(oldIcon);
        for (let item in this.options.data) {
            div.dataset[item] = this.options.data[item];
        }
        this.div = div;
        return div;
    }
    setData(data: { [key: string]: string }) {
        this.options.data = {
            ...this.options.data,
            ...data
        };
        if (this.div) {
            for (let item in data) {
                this.div.dataset[item] = this.options.data[item];
            }
        }
    }
}

export const markerDivIcon = function (options: MarkerDivIconOptions) {
    return new MarkerDivIcon(options);
};

class DivIconMarker extends L.Marker {
    options: DivIconMarkerOptions;
    constructor(
        latlng: L.LatLng,
        options: L.MarkerOptions,
        data: { [key: string]: string }
    ) {
        super(latlng, options);
        this.options.icon.setData(data);
    }
}

export const divIconMarker = function (
    latlng: L.LatLng,
    options: DivIconMarkerOptions,
    data: { [key: string]: string }
) {
    return new DivIconMarker(latlng, options, data);
};



================================================
FILE: src/map/index.ts
================================================
export * from "./divicon";
export * from "./map";
export * from "./popup";
export * from "./view";



================================================
FILE: src/map/popup.ts
================================================
import type { BaseMapType, LeafletOverlay, TooltipDisplay } from "../types";
import { Marker, Overlay } from "src/layer";
import { Layer } from "src/layer/layer";
import { BASE_POPUP_OPTIONS } from "src/utils";
import { LeafletSymbol } from "../utils/leaflet-import";
let L = window[LeafletSymbol];

class Popup {
    leafletInstance: L.Popup;
    private _timeoutHandler: ReturnType<typeof setTimeout>;

    handlerTarget: any;
    options: Options;
    get displayMarkerTooltips() {
        return this.map.plugin.data.displayMarkerTooltips;
    }
    get displayOverlayTooltips() {
        return this.map.plugin.data.displayOverlayTooltips;
    }
    constructor(
        private map: BaseMapType,
        private target: Layer<any> | L.LatLng | L.Marker | L.Polyline,
        options?: Options
    ) {
        this.options = { ...BASE_POPUP_OPTIONS, ...options };
        this.map.on("should-close-popup", (source) => {
            if (this.options.permanent) return;
            if (source != this) this.close();
        });
    }
    private canShowTooltip(
        target: Marker | LeafletOverlay,
        tooltip?: TooltipDisplay
    ) {
        const global =
            target instanceof Marker
                ? this.displayMarkerTooltips
                : this.displayOverlayTooltips;
        if (tooltip === "always") return true;
        if (tooltip === "hover" && global) return true;
        if (tooltip === "never") return false;
        return global;
    }
    private onZoomAnim() {
        if (this.target instanceof L.Circle) {
            this.leafletInstance.options.offset = new L.Point(
                0,
                (-1 * this.target.getElement().getBoundingClientRect().height) /
                    2 +
                    10 // not sure why circles have this extra padding..........
            );
            this.leafletInstance.update();
        }
    }

    private onTimeOut() {
        if (
            !(
                this.handlerTarget instanceof L.LatLng ||
                this.handlerTarget instanceof L.Layer
            )
        ) {
            this.handlerTarget.leafletInstance.off(
                "mouseenter",
                this.onMouseOver
            );
            this.handlerTarget.leafletInstance.off("mouseout", this.onMouseOut);
        }
        if (this.handlerTarget instanceof L.Layer) {
            this.handlerTarget
                .off("mouseout", this.onMouseOut)
                .off("mouseenter", this.onMouseOver);
        }

        this.leafletInstance
            .getElement()
            .removeEventListener("mouseenter", this.onMouseOver);
        this.leafletInstance
            .getElement()
            .removeEventListener("mouseleave", this.onMouseOut);

        this.map.leafletInstance.off("zoom", this.onZoomAnim);
        if (this.options.permanent) return;
        this.close();
    }
    private onMouseOut() {
        clearTimeout(this._timeoutHandler);

        if (this.options.permanent) return;

        this._timeoutHandler = setTimeout(() => this.onTimeOut(), 500);
    }
    private onMouseOver() {
        clearTimeout(this._timeoutHandler);
    }

    setTarget(target: Layer<any> | L.Marker | L.LatLng | L.Polyline) {
        this.target = target;
        this.leafletInstance = this.getPopup();
        return this;
    }

    open(
        content: ((source: L.Layer) => L.Content) | L.Content,
        handler?: L.Layer
    ) {
        if ("tooltip" in this.target && !this.canShowTooltip(this.target))
            return;

        if (!this.leafletInstance) this.leafletInstance = this.getPopup();

        if (this._timeoutHandler) {
            clearTimeout(this._timeoutHandler);
        }
        if (this.leafletInstance.isOpen()) {
            this.leafletInstance.setContent(content);
            if (this.target instanceof L.Polyline) {
                this.leafletInstance.setLatLng(
                    this.target.getLatLngs()[1] as L.LatLng
                );
            }
            return;
        }

        this.map.trigger("should-close-popup", this);

        if (this.target instanceof L.Polyline) {
            this.target.on("remove", () => this.close());
        }

        this.handlerTarget = handler ?? this.target;

        if (this.leafletInstance && this.leafletInstance.isOpen()) {
            this.close();
            if (this.target instanceof L.Layer) this.target.closePopup();
        }

        this.leafletInstance.setContent(content);

        let popupElement: HTMLElement;
        this.map.leafletInstance.on("popupopen", () => {
            if (this.options.permanent) return;
            popupElement = this.leafletInstance.getElement();
            popupElement.addEventListener(
                "mouseenter",
                this.onMouseOver.bind(this)
            );
            popupElement.addEventListener(
                "mouseleave",
                this.onMouseOut.bind(this)
            );
        });

        this.map.leafletInstance.addLayer(this.leafletInstance);

        if (this.handlerTarget instanceof Overlay) {
            this.map.leafletInstance.on("zoom", this.onZoomAnim.bind(this));
        }

        if (this.options.permanent) return;
        if (this.handlerTarget instanceof L.LatLng) {
            this._timeoutHandler = setTimeout(() => {
                popupElement.removeEventListener(
                    "mouseenter",
                    this.onMouseOver
                );
                popupElement.removeEventListener("mouseleave", this.onMouseOut);

                this.close();
            }, 1000);
        } else if (this.handlerTarget instanceof L.Layer) {
            this.handlerTarget
                .on("mouseout", this.onMouseOut.bind(this))
                .on("mouseenter", this.onMouseOver.bind(this));
        } else {
            this.handlerTarget.leafletInstance
                .on("mouseout", this.onMouseOut.bind(this))
                .on("mouseenter", this.onMouseOver.bind(this));
        }
    }

    close() {
        if (!this.leafletInstance) return;
        if (this.target instanceof Marker && this.target.tooltip === "always")
            return;
        this.leafletInstance.removeFrom(this.map.leafletInstance);
    }

    private getPopup(): L.Popup {
        if (this.leafletInstance && this.leafletInstance.isOpen()) {
            this.close();
        }

        return this.buildPopup();
    }

    private buildPopup(): L.Popup {
        if (this.target instanceof L.LatLng) {
            return L.popup(this.options).setLatLng(this.target);
        } else if (this.target instanceof L.Polyline) {
            return L.popup(this.options).setLatLng(
                this.target.getLatLngs()[1] as L.LatLng
            );
        } else if (this.target instanceof L.Marker) {
            return L.popup({
                ...this.options,
                offset: new L.Point(
                    0,
                    (-1 *
                        this.target.getElement().getBoundingClientRect()
                            .height) /
                        2
                )
            }).setLatLng(this.target.getLatLng() as L.LatLng);
        } else if (this.target instanceof Overlay) {
            return L.popup({
                ...this.options,
                offset: new L.Point(
                    0,
                    (-1 *
                        this.target.leafletInstance
                            .getElement()
                            .getBoundingClientRect().height) /
                        2 +
                        10 // not sure why circles have this extra padding..........
                )
            }).setLatLng(this.target.leafletInstance.getLatLng());
        } else {
            return L.popup({
                ...this.options,
                offset: new L.Point(
                    0,
                    (-1 *
                        this.target.leafletInstance
                            .getElement()
                            .getBoundingClientRect().height) /
                        2
                )
            }).setLatLng(this.target.leafletInstance.getLatLng());
        }
    }
    isOpen() {
        return this.leafletInstance && this.leafletInstance.isOpen();
    }
    setContent(content: ((source: L.Layer) => L.Content) | L.Content) {
        if (!this.leafletInstance) this.leafletInstance = this.getPopup();
        this.leafletInstance.setContent(content);
    }
    setLatLng(latlng: L.LatLng) {
        if (!this.leafletInstance) this.leafletInstance = this.getPopup();
        this.leafletInstance.setLatLng(latlng);
    }
}
interface Options extends L.PopupOptions {
    permanent?: boolean;
}
export function popup(
    map: BaseMapType,
    target: Layer<any> | L.LatLng | L.Polyline,
    options?: Options
): Popup {
    return new Popup(map, target, options);
}



================================================
FILE: src/map/view.ts
================================================
import { ItemView, MarkdownRenderChild, Menu, WorkspaceLeaf } from "obsidian";
import { BaseMapType,  } from "../types";
import t from "src/l10n/locale";
import { EditParametersModal } from "src/modals/mapview";
import { LeafletRenderer } from "src/renderer/renderer";
import { DEFAULT_BLOCK_PARAMETERS, VIEW_TYPE } from "src/utils";
import type ObsidianLeaflet from "src/main";

export class LeafletMapView extends ItemView {
    map: BaseMapType;
    mapEl: HTMLDivElement;
    innerContentEl: HTMLDivElement;
    context: MarkdownRenderChild;
    renderer: LeafletRenderer;
    get params() {
        return {
            ...DEFAULT_BLOCK_PARAMETERS,
            ...(this.plugin.data.mapViewParameters ?? {}),
            height: "100%",
            isMapView: true
        };
    }
    constructor(public leaf: WorkspaceLeaf, public plugin: ObsidianLeaflet) {
        super(leaf);
        this.innerContentEl = this.contentEl.createDiv({
            cls: "markdown-preview-view",
            attr: { style: "height: 100%;" }
        });
        this.mapEl = this.innerContentEl.createDiv("block-language-leaflet");

        this.context = new MarkdownRenderChild(this.mapEl);
        this.context.load();
    }
    async onOpen() {
        this.renderer = new LeafletRenderer(
            this.plugin,
            "",
            this.mapEl,
            this.params,
            ""
        );

        this.context.addChild(this.renderer);
    }
    update() {
        this.renderer.unload();

        this.renderer = new LeafletRenderer(
            this.plugin,
            "",
            this.mapEl,
            this.params,
            ""
        );
        this.context.addChild(this.renderer);
    }

    getDisplayText() {
        return t("Leaflet Map");
    }
    getViewType() {
        return VIEW_TYPE;
    }
    onResize() {
        if (!this.renderer) return;
        this.renderer.setHeight(
            `${
                this.contentEl.firstElementChild.getBoundingClientRect().height
            }px`
        );
    }
    onMoreOptionsMenu(menu: Menu): void {
        menu.addItem((item) => {
            item.setIcon("pencil")
                .setTitle("Edit Map Parameters")
                .onClick(() => {
                    const modal = new EditParametersModal(this.plugin);
                    modal.onClose = () => {};
                    modal.open();
                });
        });
    }
}



================================================
FILE: src/modals/command.ts
================================================
import { App, Command, FuzzyMatch, TextComponent } from "obsidian";
import { SuggestionModal } from "./suggester";

export class CommandSuggestionModal extends SuggestionModal<Command> {
    commands: Command[];
    command: Command;
    text: TextComponent;
    constructor(app: App, input: TextComponent, items: Command[]) {
        super(app, input.inputEl, items);
        this.commands = [...items];
        this.text = input;
        //this.getItem();

        this.createPrompts();

        this.inputEl.addEventListener("input", this.getItem.bind(this));
    }
    createPrompts() {}
    getItem() {
        const v = this.inputEl.value,
            command = this.commands.find(
                (c) => c.name === v.trim() || c.id === v.trim()
            );
        if (command == this.command) return;
        this.command = command;
        if (this.command) this.onInputChanged();
    }
    getItemText(item: Command) {
        return item.name + item.id;
    }
    onChooseItem(item: Command) {
        this.text.setValue(item.name);
        this.command = item;
    }
    selectSuggestion({ item }: FuzzyMatch<Command>) {
        let link = item.id;

        this.text.setValue(item.name);
        this.onClose(item);

        this.close();
    }
    renderSuggestion(result: FuzzyMatch<Command>, el: HTMLElement) {
        let { item, match: matches } = result || {};

        let content = el.createDiv({
            cls: "suggestion-content"
        });
        if (!item) {
            content.setText(this.emptyStateText);
            content.parentElement.addClass("is-selected");
            return;
        }

        const matchElements = matches.matches.map((m) => {
            return createSpan("suggestion-highlight");
        });

        for (let i = 0; i < item.name.length; i++) {
            let match = matches.matches.find((m) => m[0] === i);
            if (match) {
                let element = matchElements[matches.matches.indexOf(match)];
                content.appendChild(element);
                element.appendText(item.name.substring(match[0], match[1]));

                i += match[1] - match[0] - 1;
                continue;
            }

            content.appendText(item.name[i]);
        }
        let note = el.createDiv({
            cls: "suggestion-note"
        });
        for (
            let i = item.name.length;
            i < item.name.length + item.id.length;
            i++
        ) {
            let match = matches.matches.find((m) => m[0] === i);
            if (match) {
                let element = matchElements[matches.matches.indexOf(match)];
                note.appendChild(element);
                element.appendText(
                    item.id.substring(
                        match[0] - item.name.length,
                        match[1] - item.name.length
                    )
                );

                i += match[1] - match[0] - 1;
                continue;
            }

            note.appendText(item.id[i - item.name.length]);
        }
    }
    getItems() {
        return this.commands;
    }
    onClose(item?: Command) {}
}



================================================
FILE: src/modals/context.ts
================================================
import { Modal, Notice, Setting, TextComponent } from "obsidian";

import type {
    SavedOverlayData,
    Marker,
    TooltipDisplay,
    BaseMapType
} from "../../types";

import { PathSuggestionModal } from "./path";
import { CommandSuggestionModal } from "./command";
import {
    DISTANCE_DECIMALS,
    getGroupSeparator,
    removeValidationError,
    setValidationError
} from "src/utils";

import { UNIT_NAME_ALIASES } from "src/utils";

import { Overlay } from "src/layer";

import { formatNumber } from "src/utils";
import t from "src/l10n/locale";

const locale = window.moment.locale;

export class MarkerContextModal extends Modal {
    deleted: boolean = false;
    tempMarker: Marker;
    modal: CommandSuggestionModal | PathSuggestionModal;
    limit: number = 100;
    advanced = false;
    constructor(public marker: Marker, public map: BaseMapType) {
        super(map.plugin.app);
        this.marker = marker;
        this.map = map;

        this.tempMarker = Object.assign(
            Object.create(Object.getPrototypeOf(this.marker)),
            this.marker
        );
        if (this.modal) this.modal.close();
    }
    async display() {
        this.contentEl.empty();

        new Setting(this.contentEl)
            .setName(t("Marker Type"))
            .addDropdown((drop) => {
                drop.addOption("default", t("Default"));
                this.map.markerIcons.forEach((marker) => {
                    drop.addOption(
                        marker.type,
                        marker.type[0].toUpperCase() +
                            marker.type.slice(1).toLowerCase()
                    );
                });
                drop.setValue(this.marker.type).onChange(async (value) => {
                    let newMarker =
                        value == "default"
                            ? this.map.data.defaultMarker
                            : this.map.markerIcons.get(value);
                    this.tempMarker.type = newMarker.type;
                });
            });
        if (this.tempMarker.command) {
            new Setting(this.contentEl)
                .setName(t("Command to Execute"))
                .setDesc(t("Name of Obsidian Command to execute"))
                .addText((text) => {
                    let commands = this.app.commands.listCommands();

                    let value =
                        commands.find(({ id }) => id == this.marker.link)
                            ?.name ?? this.marker.link;

                    text.setPlaceholder(t("Command")).setValue(value);
                    this.modal = new CommandSuggestionModal(this.app, text, [
                        ...commands
                    ]);

                    this.modal.onClose = (item) => {
                        this.tempMarker.link = item.id;
                    };

                    text.inputEl.onblur = async () => {
                        this.tempMarker.link =
                            commands.find(
                                ({ name, id }) =>
                                    name == text.inputEl.value ||
                                    id == text.inputEl.value
                            )?.id ?? text.inputEl.value;
                    };
                });
        } else {
            new Setting(this.contentEl)
                .setName(t("Note to Open"))
                .setDesc(t("Path of note to open"))
                .addText((text) => {
                    let files = this.app.vault.getFiles();

                    text.setPlaceholder(t("Path")).setValue(this.marker.link);
                    this.modal = new PathSuggestionModal(this.app, text, [
                        ...files
                    ]);

                    this.modal.onClose = async () => {
                        this.tempMarker.link = text.inputEl.value;
                    };

                    text.inputEl.onblur = async () => {
                        this.tempMarker.link = text.inputEl.value;
                    };
                });
        }
        new Setting(this.contentEl)
            .setName("Description")
            .addTextArea((t) =>
                t
                    .setValue(this.tempMarker.description)
                    .onChange((v) => (this.tempMarker.description = v))
            );
        new Setting(this.contentEl)
            .setName("Show Advanced Options")
            .addToggle((t) =>
                t.setValue(this.advanced).onChange((v) => {
                    this.advanced = v;
                    this.display();
                })
            );
        if (this.advanced) {
            new Setting(this.contentEl)
                .setName(t("Execute Command"))
                .setDesc(
                    t("The marker will execute an Obsidian command on click")
                )
                .addToggle((t) => {
                    t.setValue(this.tempMarker.command || false).onChange(
                        (v) => {
                            this.tempMarker.command = v;
                            this.tempMarker.link = "";
                            this.display();
                        }
                    );
                });
            new Setting(this.contentEl)
                .setName(t("Display Tooltip"))
                .addDropdown((drop) => {
                    drop.addOption("hover", t("Hover"));
                    drop.addOption("always", t("Always"));
                    drop.addOption("never", t("Never"));
                    drop.setValue(this.tempMarker.tooltip ?? "hover").onChange(
                        async (value: TooltipDisplay) => {
                            this.tempMarker.tooltip = value;
                        }
                    );
                });

            new Setting(this.contentEl)
                .setName(t("Min Zoom"))
                .setDesc(
                    t(
                        "Only display when zooming in below this zoom. Current map minimum"
                    ) +
                        ": " +
                        this.map.zoom.min
                )
                .addText((text) => {
                    let warned = false;
                    text.inputEl.onkeydown = (evt) => {
                        if (
                            !/^(\d*\.?\d*|Backspace|Delete|Arrow\w+|\-|Tab)$/.test(
                                evt.key
                            )
                        ) {
                            if (!warned) {
                                warned = true;
                                new Notice(t("Minimum zoom must be a number."));
                            }
                            evt.preventDefault();
                            return false;
                        }
                    };
                    if (this.tempMarker.minZoom != null)
                        text.setValue(`${this.tempMarker.minZoom}`);
                    text.onChange((v) => {
                        this.tempMarker.minZoom = Number(v);
                    });
                });
            new Setting(this.contentEl)
                .setName(t("Max Zoom"))
                .setDesc(
                    t(
                        "Only display when zooming out above this zoom. Current map maximum"
                    ) +
                        ": " +
                        this.map.zoom.max
                )
                .addText((text) => {
                    let warned = false;
                    text.inputEl.onkeydown = (evt) => {
                        if (
                            !/^(\d*\.?\d*|Backspace|Delete|Arrow\w+|\-|Tab)$/.test(
                                evt.key
                            )
                        ) {
                            if (!warned) {
                                warned = true;
                                new Notice(t("Maximum zoom must be a number."));
                            }
                            evt.preventDefault();
                            return false;
                        }
                    };
                    text.onChange((v) => {
                        this.tempMarker.maxZoom = Number(v);
                    });
                    if (this.tempMarker.maxZoom != null)
                        text.setValue(`${this.tempMarker.maxZoom}`);
                });
        }

        new Setting(this.contentEl).addButton((b) => {
            b.setIcon("trash")
                .setWarning()
                .setTooltip(t("Delete Marker"))
                .onClick(() => {
                    this.deleted = true;
                    this.close();
                });
            return b;
        });
    }
    onOpen() {
        this.display();
    }
}

export class OverlayContextModal extends Modal {
    deleted: boolean = false;
    tempOverlay: SavedOverlayData;
    modal: CommandSuggestionModal | PathSuggestionModal;
    limit: number = 100;
    constructor(overlay: Overlay, public map: BaseMapType) {
        super(map.plugin.app);
        this.map = map;

        this.tempOverlay = Object.assign({}, overlay.data);
        if (this.modal) this.modal.close();
    }
    async display() {
        this.contentEl.empty();

        let radiusInput: TextComponent;
        let radius = this.tempOverlay.radius;
        if (this.map.type == "image") {
            radius = radius * this.map.scale;
        }
        new Setting(this.contentEl)
            .setName(t("Overlay Radius"))
            .setDesc(
                `${t("Circle radius in")} ${
                    UNIT_NAME_ALIASES[this.tempOverlay.unit] ?? t("meters")
                }.`
            )
            .addText((text) => {
                radiusInput = text;
                const regex = new RegExp(
                    `\\${getGroupSeparator(locale()) ?? ","}`,
                    "g"
                );
                text.setValue(
                    `${formatNumber(radius, DISTANCE_DECIMALS)
                        .toString()
                        .replace(regex, "")}`
                );
                text.inputEl.onblur = () => {
                    if (
                        isNaN(Number(text.inputEl.value)) &&
                        Number(text.inputEl.value) > 0
                    ) {
                        setValidationError(
                            radiusInput,
                            t("Radius must be greater than 0.")
                        );
                        text.inputEl.value = `${radius}`;
                        return;
                    }
                    removeValidationError(radiusInput);

                    this.tempOverlay.radius = Number(text.inputEl.value);
                };
            });

        const desc = new Setting(this.contentEl)
            .setName(t("Overlay Description"))
            .addText((t) => {
                t.setValue(this.tempOverlay.desc).onChange((v) => {
                    this.tempOverlay.desc = v;
                });
            });

        const color = new Setting(this.contentEl).setName(t("Overlay Color"));
        /** convert color to hex */
        let colorOfOverlay = this.tempOverlay.color;
        if (!/#\w{3,6}/.test(colorOfOverlay)) {
            const canvas = createEl("canvas");
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = colorOfOverlay;
            colorOfOverlay = ctx.fillStyle;
        }
        let colorInputNode = color.controlEl.createEl("input", {
            attr: {
                type: "color",
                value: colorOfOverlay
            }
        });
        colorInputNode.oninput = (evt) => {
            this.tempOverlay.color = (evt.target as HTMLInputElement).value;
        };
        colorInputNode.onchange = async (evt) => {
            this.tempOverlay.color = (evt.target as HTMLInputElement).value;

            this.display();
        };

        new Setting(this.contentEl)
            .setName(t("Display Tooltip"))
            .addDropdown((drop) => {
                drop.addOption("hover", t("Hover"));
                drop.addOption("never", t("Never"));
                drop.setValue(this.tempOverlay.tooltip ?? "hover").onChange(
                    (value: TooltipDisplay) => {
                        this.tempOverlay.tooltip = value;
                    }
                );
            });

        new Setting(this.contentEl).addButton((b) => {
            b.setIcon("trash")
                .setWarning()
                .setTooltip(t("Delete Overlay"))
                .onClick(() => {
                    this.deleted = true;

                    this.close();
                });
            return b;
        });
    }
    onOpen() {
        this.display();
    }
}



================================================
FILE: src/modals/geojson.ts
================================================
import { App, Modal, Setting } from "obsidian";
import t from "src/l10n/locale";

export class GeoJSONModal extends Modal {
  result: string;

  onSubmit: (result: string) => void;

  constructor(app: App, onSubmit: (result: string) => void) {
    super(app);
    this.onSubmit = onSubmit;
  }

  onOpen() {
    const { contentEl } = this;

    contentEl.createEl("h1", { text: t("Enter a file name.") });

    new Setting(contentEl)
      .setName(t("File Name"))
      .addText((text) => {
        text.onChange(value => this.result = value);
      });

    new Setting(contentEl)
      .addButton(button => {
        button.setButtonText(t("Save"))
          .setCta()
          .onClick(() => {
            this.close();
            this.onSubmit(this.result);
          });
      });
  }

  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
}


================================================
FILE: src/modals/icon.ts
================================================
import { TextComponent, App, FuzzyMatch } from "obsidian";
import { findIconDefinition, icon, IconName } from "src/utils";
import { SuggestionModal } from "./suggester";

export class IconSuggestionModal extends SuggestionModal<IconName> {
    icons: IconName[];
    icon: IconName;
    text: TextComponent;
    constructor(app: App, input: TextComponent, items: IconName[]) {
        super(app, input.inputEl, items);
        this.icons = [...items];
        this.text = input;
        //this.getItem();

        this.createPrompts();

        this.inputEl.addEventListener("input", this.getItem.bind(this));
    }
    createPrompts() {}
    getItem() {
        const v = this.inputEl.value,
            icon = this.icons.find((iconName) => iconName === v.trim());
        if (icon == this.icon) return;
        this.icon = icon;
        if (this.icons) this.onInputChanged();
    }
    getItemText(item: IconName) {
        return item;
    }
    onChooseItem(item: IconName) {
        this.text.setValue(item);
        this.icon = item;
    }
    selectSuggestion({ item }: FuzzyMatch<IconName>) {
        this.text.setValue(item);
        this.onClose();

        this.close();
    }
    renderSuggestion(result: FuzzyMatch<IconName>, el: HTMLElement) {
        let { item, match: matches } = result || {};
        let content = el.createDiv({
            cls: "suggestion-content icon"
        });
        if (!item) {
            content.setText(this.emptyStateText);
            content.parentElement.addClass("is-selected");
            return;
        }

        const matchElements = matches.matches.map((m) => {
            return createSpan("suggestion-highlight");
        });
        for (let i = 0; i < item.length; i++) {
            let match = matches.matches.find((m) => m[0] === i);
            if (match) {
                let element = matchElements[matches.matches.indexOf(match)];
                content.appendChild(element);
                element.appendText(item.substring(match[0], match[1]));

                i += match[1] - match[0] - 1;
                continue;
            }

            content.appendText(item[i]);
        }

        const iconDiv = createDiv({
            cls: "suggestion-flair"
        });
        iconDiv.appendChild(
            icon(
                findIconDefinition({
                    iconName: item,
                    prefix: "fas"
                })
            ).node[0]
        );

        content.prepend(iconDiv);
    }
    getItems() {
        return this.icons;
    }
}



================================================
FILE: src/modals/index.ts
================================================
export { PathSuggestionModal } from "./path";
export { IconSuggestionModal } from "./icon";
export { CommandSuggestionModal } from "./command";
export { MarkerContextModal } from "./context";
export { CreateMarkerModal } from "./settings";



================================================
FILE: src/modals/mapview.ts
================================================
import {
    ButtonComponent,
    ExtraButtonComponent,
    Modal,
    Notice,
    TextAreaComponent
} from "obsidian";
import type ObsidianLeaflet from "src/main";

import t from "src/l10n/locale";

export class EditParametersModal extends Modal {
    constructor(private plugin: ObsidianLeaflet) {
        super(plugin.app);
    }

    onOpen() {
        this.containerEl.addClass("leaflet-edit-parameters");
        const text = new TextAreaComponent(this.contentEl);
        text.setValue(
            JSON.stringify(this.plugin.data.mapViewParameters, null, 4)
        );
        text.inputEl.setAttr("style", "width: 100%; min-height: 500px;");

        const buttons = this.contentEl.createDiv("context-buttons");
        new ButtonComponent(buttons)
            .setIcon("checkmark")
            .setTooltip(t("Save"))
            .onClick(async () => {
                try {
                    this.plugin.data.mapViewParameters = JSON.parse(
                        text.inputEl.value
                    );
                    await this.plugin.saveSettings();

                    if (this.plugin.view) {
                        this.plugin.view.update();
                    }
                    this.close();
                } catch (e) {
                    new Notice(
                        t(`There was an error parsing the JSON.`) +
                            `\n\n${e.message}`
                    );
                }
            });
        new ExtraButtonComponent(buttons)
            .setIcon("cross")
            .setTooltip(t("Cancel"))
            .onClick(() => this.close());
    }
    onClose() {}
}



================================================
FILE: src/modals/path.ts
================================================
import { SuggestionModal } from "./suggester";
import {
    FuzzyMatch,
    TFile,
    BlockCache,
    HeadingCache,
    CachedMetadata,
    TextComponent,
    App,
    TFolder
} from "obsidian";
import t from "src/l10n/locale";

export class PathSuggestionModal extends SuggestionModal<
    TFile | BlockCache | HeadingCache
> {
    file: TFile;
    files: TFile[];
    text: TextComponent;
    cache: CachedMetadata;
    constructor(app: App, input: TextComponent, items: TFile[]) {
        super(app, input.inputEl, items);
        this.files = [...items];
        this.text = input;
        //this.getFile();

        this.createPrompts();

        this.inputEl.addEventListener("input", this.getFile.bind(this));
    }
    createPrompts() {
        this.createPrompt([
            createSpan({
                cls: "prompt-instruction-command",
                text: t("Type") + " #"
            }),
            createSpan({ text: "to link heading" })
        ]);
        this.createPrompt([
            createSpan({
                cls: "prompt-instruction-command",
                text: t("Type") + " ^"
            }),
            createSpan({ text: "to link blocks" })
        ]);
        this.createPrompt([
            createSpan({
                cls: "prompt-instruction-command",
                text: t("Note") + ": "
            }),
            createSpan({
                text: t("Blocks must have been created already")
            })
        ]);
    }
    getFile() {
        const v = this.inputEl.value,
            file = this.app.metadataCache.getFirstLinkpathDest(
                v.split(/[\^#]/).shift() || "",
                ""
            );
        if (file == this.file) return;
        this.file = file;
        if (this.file)
            this.cache = this.app.metadataCache.getFileCache(this.file);
        this.onInputChanged();
    }
    getItemText(item: TFile | HeadingCache | BlockCache) {
        if (item instanceof TFile) return item.path;
        if (Object.prototype.hasOwnProperty.call(item, "heading")) {
            return (<HeadingCache>item).heading;
        }
        if (Object.prototype.hasOwnProperty.call(item, "id")) {
            return (<BlockCache>item).id;
        }
    }
    onChooseItem(item: TFile | HeadingCache | BlockCache) {
        if (item instanceof TFile) {
            this.text.setValue(item.basename);
            this.file = item;
            this.cache = this.app.metadataCache.getFileCache(this.file);
        } else if (Object.prototype.hasOwnProperty.call(item, "heading")) {
            this.text.setValue(
                this.file.basename + "#" + (<HeadingCache>item).heading
            );
        } else if (Object.prototype.hasOwnProperty.call(item, "id")) {
            this.text.setValue(
                this.file.basename + "^" + (<BlockCache>item).id
            );
        }
    }
    selectSuggestion({ item }: FuzzyMatch<TFile | BlockCache | HeadingCache>) {
        let link: string;
        if (item instanceof TFile) {
            link = item.basename;
        } else if (Object.prototype.hasOwnProperty.call(item, "heading")) {
            link = this.file.basename + "#" + (<HeadingCache>item).heading;
        } else if (Object.prototype.hasOwnProperty.call(item, "id")) {
            link = this.file.basename + "^" + (<BlockCache>item).id;
        }

        this.text.setValue(link);
        this.onClose();

        this.close();
    }
    renderSuggestion(
        result: FuzzyMatch<TFile | BlockCache | HeadingCache>,
        el: HTMLElement
    ) {
        let { item, match: matches } = result || {};
        let content = el.createDiv({
            cls: "suggestion-content"
        });
        if (!item) {
            content.setText(this.emptyStateText);
            content.parentElement.addClass("is-selected");
            return;
        }

        if (item instanceof TFile) {
            let pathLength = item.path.length - item.name.length;
            const matchElements = matches.matches.map((m) => {
                return createSpan("suggestion-highlight");
            });
            for (
                let i = pathLength;
                i < item.path.length - item.extension.length - 1;
                i++
            ) {
                let match = matches.matches.find((m) => m[0] === i);
                if (match) {
                    let element = matchElements[matches.matches.indexOf(match)];
                    content.appendChild(element);
                    element.appendText(item.path.substring(match[0], match[1]));

                    i += match[1] - match[0] - 1;
                    continue;
                }

                content.appendText(item.path[i]);
            }
            el.createDiv({
                cls: "suggestion-note",
                text: item.path
            });
        } else if (Object.prototype.hasOwnProperty.call(item, "heading")) {
            content.setText((<HeadingCache>item).heading);
            content.prepend(
                createSpan({
                    cls: "suggestion-flair",
                    text: `H${(<HeadingCache>item).level}`
                })
            );
        } else if (Object.prototype.hasOwnProperty.call(item, "id")) {
            content.setText((<BlockCache>item).id);
        }
    }
    get headings() {
        if (!this.file) return [];
        if (!this.cache) {
            this.cache = this.app.metadataCache.getFileCache(this.file);
        }
        return this.cache.headings || [];
    }
    get blocks() {
        if (!this.file) return [];
        if (!this.cache) {
            this.cache = this.app.metadataCache.getFileCache(this.file);
        }
        return Object.values(this.cache.blocks || {}) || [];
    }
    getItems() {
        const v = this.inputEl.value;
        if (/#/.test(v)) {
            this.modifyInput = (i) => i.split(/#/).pop();
            return this.headings;
        } else if (/\^/.test(v)) {
            this.modifyInput = (i) => i.split(/\^/).pop();
            return this.blocks;
        }
        return this.files;
    }
}

export class FolderSuggestionModal extends SuggestionModal<TFolder> {
    text: TextComponent;
    cache: CachedMetadata;
    folders: TFolder[];
    folder: TFolder;
    constructor(app: App, input: TextComponent, items: TFolder[]) {
        super(app, input.inputEl, items);
        this.folders = [...items];
        this.text = input;

        this.inputEl.addEventListener("input", () => this.getFolder());
    }
    getFolder() {
        const v = this.inputEl.value,
            folder = this.app.vault.getAbstractFileByPath(v);
        if (folder == this.folder) return;
        if (!(folder instanceof TFolder)) return;
        this.folder = folder;

        this.onInputChanged();
    }
    getItemText(item: TFolder) {
        return item.path;
    }
    onChooseItem(item: TFolder) {
        this.text.setValue(item.path);
        this.folder = item;
    }
    selectSuggestion({ item }: FuzzyMatch<TFolder>) {
        let link = item.path;

        this.text.setValue(link);
        this.onClose();

        this.close();
    }
    renderSuggestion(result: FuzzyMatch<TFolder>, el: HTMLElement) {
        let { item, match: matches } = result || {};
        let content = el.createDiv({
            cls: "suggestion-content"
        });
        if (!item) {
            content.setText(this.emptyStateText);
            content.parentElement.addClass("is-selected");
            return;
        }

        let pathLength = item.path.length - item.name.length;
        const matchElements = matches.matches.map((m) => {
            return createSpan("suggestion-highlight");
        });
        for (let i = pathLength; i < item.path.length; i++) {
            let match = matches.matches.find((m) => m[0] === i);
            if (match) {
                let element = matchElements[matches.matches.indexOf(match)];
                content.appendChild(element);
                element.appendText(item.path.substring(match[0], match[1]));

                i += match[1] - match[0] - 1;
                continue;
            }

            content.appendText(item.path[i]);
        }
        el.createDiv({
            cls: "suggestion-note",
            text: item.path
        });
    }

    getItems() {
        return this.folders;
    }
}



================================================
FILE: src/modals/settings.ts
================================================
import {
    App,
    ButtonComponent,
    Modal,
    Notice,
    Setting,
    TextComponent
} from "obsidian";
import t from "src/l10n/locale";
import { Icon } from "../../types";
import type ObsidianLeaflet from "src/main";
import {
    findIconDefinition,
    getIcon,
    getMarkerIcon,
    icon,
    IconName,
    iconNames,
    removeValidationError,
    setValidationError
} from "../utils";
import { IconSuggestionModal } from "./icon";

export class CreateMarkerModal extends Modal {
    marker: Icon;
    tempMarker: Icon;
    plugin: ObsidianLeaflet;
    saved: boolean = false;
    canvas: HTMLCanvasElement;
    constructor(app: App, plugin: ObsidianLeaflet, marker: Icon) {
        super(app);
        this.marker = marker;
        this.plugin = plugin;

        this.tempMarker = { ...this.marker };
        if (!this.tempMarker.tags) this.tempMarker.tags = [];
        this.containerEl.addClass("leaflet-settings-modal");
    }
    get data() {
        return this.plugin.data;
    }

    async display(focusEl?: string): Promise<void> {
        let containerEl = this.contentEl;
        containerEl.empty();

        let createNewMarker = containerEl.createDiv();

        let iconDisplayAndSettings = createNewMarker.createDiv();
        iconDisplayAndSettings.addClass("marker-creation-modal");
        let iconSettings = iconDisplayAndSettings.createDiv();
        let iconDisplay = iconDisplayAndSettings.createDiv("icon-display");

        let typeTextInput: TextComponent;
        let markerName = new Setting(iconSettings)
            .setName(t("Marker Name"))
            .addText((text) => {
                typeTextInput = text
                    .setPlaceholder(t("Marker Name"))
                    .setValue(this.tempMarker.type);
                typeTextInput.onChange((new_value) => {
                    if (
                        this.data.markerIcons.find(
                            (marker) => marker.type == new_value
                        ) &&
                        this.tempMarker.type != this.marker.type
                    ) {
                        setValidationError(
                            typeTextInput,
                            t("Marker name already exists.")
                        );
                        return;
                    }

                    if (new_value.length == 0) {
                        setValidationError(
                            typeTextInput,
                            t("Marker name cannot be empty.")
                        );
                        return;
                    }

                    removeValidationError(typeTextInput);

                    this.tempMarker.type = new_value;
                });
            });

        let iconTextInput: TextComponent;
        let iconName = new Setting(iconSettings)
            .setName(t("Icon Name"))
            .setDesc(t("Font Awesome icon name (e.g. map-marker)."))
            .addText((text) => {
                text.setPlaceholder(t("Icon Name")).setValue(
                    !this.tempMarker.isImage ? this.tempMarker.iconName : ""
                );

                const validate = async () => {
                    const new_value = text.inputEl.value;

                    if (!new_value.length) {
                        setValidationError(
                            text,
                            t("A default marker must be defined.")
                        );
                        return;
                    }
                    if (
                        !findIconDefinition({
                            iconName: new_value as IconName,
                            prefix: "fas"
                        })
                    ) {
                        setValidationError(
                            text,
                            t(
                                "The selected icon does not exist in Font Awesome Free."
                            )
                        );
                        return;
                    }

                    removeValidationError(text);
                    this.tempMarker.iconName = new_value;
                    this.tempMarker.isImage = false;
                    delete this.tempMarker.imageUrl;

                    await this.plugin.saveSettings();

                    this.display();
                };

                const modal = new IconSuggestionModal(
                    this.app,
                    text,
                    iconNames
                );

                modal.onClose = validate;

                text.inputEl.onblur = validate;

                iconTextInput = text;
            });

        const input = createEl("input", {
            attr: {
                type: "file",
                name: "image",
                accept: "image/*"
            }
        });
        new Setting(iconSettings)
            .setName(t("Use Image for Icon"))
            .addButton((b) => {
                b.setButtonText(t("Upload Image")).setTooltip(
                    t("Upload Image")
                );
                b.buttonEl.addClass("leaflet-file-upload");
                b.buttonEl.appendChild(input);
                b.onClick(() => input.click());
            });

        /** Image Uploader */
        input.onchange = async () => {
            const { files } = input;

            if (!files.length) return;

            const image = files[0];
            const reader = new FileReader();
            reader.onloadend = (evt) => {
                var image = new Image();
                image.onload = () => {
                    this.canvas = iconDisplay.createEl("canvas");
                    const max_size = 24;
                    let width = image.width,
                        height = image.height;
                    if (width >= height && width > max_size) {
                        height *= max_size / width;
                        width = max_size;
                    } else if (height >= width && height > max_size) {
                        width *= max_size / height;
                        height = max_size;
                    }
                    this.canvas.width = width;
                    this.canvas.height = height;
                    this.canvas
                        .getContext("2d")
                        .drawImage(image, 0, 0, width, height);

                    this.tempMarker.isImage = true;
                    this.tempMarker.imageUrl =
                        this.canvas.toDataURL("image/png");

                    this.display();
                };
                image.src = evt.target.result.toString();
            };
            reader.readAsDataURL(image);

            input.value = null;
        };

        if (!this.tempMarker.isImage) {
            if (this.tempMarker.iconName) {
                const params =
                    this.tempMarker.layer && !this.data.defaultMarker.isImage
                        ? {
                              transform: this.tempMarker.transform,
                              mask: getIcon(this.data.defaultMarker.iconName),
                              classes: ["full-width-height"]
                          }
                        : { classes: ["full-width-height"] };
                let node = getMarkerIcon(this.tempMarker, params)
                    .node as HTMLElement;
                node.style.color = this.tempMarker.color
                    ? this.tempMarker.color
                    : this.data.defaultMarker.color;
                //let marker = iconDisplay;
                let iconDisplayHeight =
                    markerName.settingEl.getBoundingClientRect().height +
                    iconName.settingEl.getBoundingClientRect().height;
                iconDisplay.setAttribute(
                    "style",
                    `height: ${iconDisplayHeight}px; padding: 1rem; position: relative;`
                );
                iconDisplay.appendChild(node);

                if (this.tempMarker.layer) {
                    let iconOverlay = icon(getIcon(this.tempMarker.iconName), {
                        transform: this.tempMarker.transform
                    }).node[0].children[0] as SVGGraphicsElement;
                    let iconPath = iconOverlay.getElementsByTagName("path")[0];

                    let fill = this.getFillColor(this.modalEl);

                    iconPath.setAttribute("fill", fill[0]);
                    iconPath.setAttribute("fill-opacity", `1`);
                    iconPath.setAttribute("stroke-width", "1px");
                    iconPath.setAttribute("stroke", "black");
                    iconPath.setAttribute("stroke-dasharray", "50,50");

                    let transformSource = iconOverlay
                        .children[0] as SVGGraphicsElement;
                    let svgElement = iconDisplay.getElementsByTagName("svg")[0],
                        xPath = document.createElementNS(
                            "http://www.w3.org/2000/svg",
                            "path"
                        ),
                        yPath = document.createElementNS(
                            "http://www.w3.org/2000/svg",
                            "path"
                        );

                    xPath.setAttribute("stroke", "red");
                    xPath.setAttribute("stroke-width", "0");
                    xPath.setAttribute("d", "M192,0 L192,512");

                    yPath.setAttribute("stroke", "red");
                    yPath.setAttribute("stroke-width", "0");
                    yPath.setAttribute("d", "M0,256 L384,256");

                    svgElement.appendChild(xPath);
                    svgElement.appendChild(yPath);
                    let units = {
                        width: 512 / 16,
                        height: 512 / 16
                    };

                    svgElement.appendChild(iconOverlay);

                    /** Fix x/y positioning due to different icon sizes */
                    iconOverlay.transform.baseVal
                        .getItem(0)
                        .setTranslate(192, 256);

                    let clickedOn: boolean = false,
                        offset: { x: number; y: number } = { x: 0, y: 0 },
                        transform: SVGTransform;

                    this.plugin.registerDomEvent(
                        iconOverlay as unknown as HTMLElement,
                        "mousedown",
                        (evt) => {
                            let CTM = svgElement.getScreenCTM();
                            offset = {
                                x: (evt.clientX - CTM.e) / CTM.a,
                                y: (evt.clientY - CTM.f) / CTM.d
                            };

                            let transforms = transformSource.transform.baseVal;
                            if (
                                transforms.numberOfItems === 0 ||
                                transforms.getItem(0).type !=
                                    SVGTransform.SVG_TRANSFORM_TRANSLATE
                            ) {
                                let translate = svgElement.createSVGTransform();
                                translate.setTranslate(0, 0);
                                // Add the translation to the front of the transforms list
                                transformSource.transform.baseVal.insertItemBefore(
                                    translate,
                                    0
                                );
                            }

                            transform = transforms.getItem(0);
                            offset.x -= transform.matrix.e;
                            offset.y -= transform.matrix.f;

                            clickedOn = true;
                        }
                    );
                    this.plugin.registerDomEvent(
                        this.containerEl,
                        "mouseup",
                        (evt) => {
                            offset = { x: 0, y: 0 };
                            xPath.setAttribute("stroke-width", "0");
                            yPath.setAttribute("stroke-width", "0");
                            clickedOn = false;
                        }
                    );
                    this.plugin.registerDomEvent(
                        iconOverlay as unknown as HTMLElement,
                        "mousemove",
                        (evt) => {
                            if (clickedOn) {
                                evt.preventDefault();
                                let CTM = svgElement.getScreenCTM();
                                let coords = {
                                    x: (evt.clientX - CTM.e) / CTM.a,
                                    y: (evt.clientY - CTM.f) / CTM.d
                                };

                                //snap to x/y
                                let x = coords.x - offset.x,
                                    y = coords.y - offset.y;
                                if (Math.abs(x) <= 32 && evt.shiftKey) {
                                    xPath.setAttribute("stroke-width", "8");
                                    x = 0;
                                } else {
                                    xPath.setAttribute("stroke-width", "0");
                                }
                                if (Math.abs(y) <= 32 && evt.shiftKey) {
                                    yPath.setAttribute("stroke-width", "8");
                                    y = 0;
                                } else {
                                    yPath.setAttribute("stroke-width", "0");
                                }

                                transform.setTranslate(x, y);

                                this.tempMarker.transform.x =
                                    transform.matrix.e / units.width;
                                this.tempMarker.transform.y =
                                    transform.matrix.f / units.height;
                            }
                        }
                    );
                }
            }

            new Setting(createNewMarker)
                .setName(t("Layer Icon"))
                .setDesc(t("The icon will be layered on the base icon."))
                .addToggle((toggle) => {
                    toggle.setValue(this.tempMarker.layer).onChange((v) => {
                        this.tempMarker.layer = v;
                        this.display();
                    });
                });
            let colorInput = new Setting(createNewMarker)
                .setName(t("Marker Color"))
                .setDesc(t("Override default icon color."));
            let colorInputNode = colorInput.controlEl.createEl("input", {
                attr: {
                    type: "color",
                    value: this.tempMarker.color
                }
            });
            colorInputNode.oninput = (evt) => {
                this.tempMarker.color = (evt.target as HTMLInputElement).value;
                if (iconDisplay.children.length)
                    (
                        iconDisplay.children[0] as HTMLElement
                    ).style.color = `${this.tempMarker.color}`;
            };
            colorInputNode.onchange = async (evt) => {
                this.tempMarker.color = (evt.target as HTMLInputElement).value;

                this.display();
            };
            colorInput.addSlider((s) =>
                s
                    .setLimits(0, 1, 0.01)
                    .setValue(1)
                    .onChange((v) => {
                        this.tempMarker.alpha = v;
                        if (iconDisplay.children.length)
                            (
                                iconDisplay.children[0] as HTMLElement
                            ).style.opacity = `${this.tempMarker.alpha}`;
                    })
            );
        }

        new Setting(createNewMarker)
            .setName(t("Min Zoom"))
            .setDesc(t("Only display when zooming in below this zoom."))
            .addText((text) => {
                let warned = false;
                text.inputEl.onkeydown = (evt) => {
                    if (
                        !/^(\d*\.?\d*|Backspace|Delete|Arrow\w+|\-|Tab)$/.test(
                            evt.key
                        )
                    ) {
                        if (!warned) {
                            warned = true;
                            new Notice(t("Minimum zoom must be a number."));
                        }
                        evt.preventDefault();
                        return false;
                    }
                };
                if (this.tempMarker.minZoom != null)
                    text.setValue(`${this.tempMarker.minZoom}`);
                text.onChange((v) => {
                    this.tempMarker.minZoom = Number(v);
                });
            });
        new Setting(createNewMarker)
            .setName(t("Max Zoom"))
            .setDesc(t("Only display when zooming out above this zoom."))
            .addText((text) => {
                let warned = false;
                text.inputEl.onkeydown = (evt) => {
                    if (
                        !/^(\d*\.?\d*|Backspace|Delete|Arrow\w+|\-|Tab)$/.test(
                            evt.key
                        )
                    ) {
                        if (!warned) {
                            warned = true;
                            new Notice(t("Maximum zoom must be a number."));
                        }
                        evt.preventDefault();
                        return false;
                    }
                };
                text.onChange((v) => {
                    this.tempMarker.maxZoom = Number(v);
                });
                if (this.tempMarker.maxZoom != null)
                    text.setValue(`${this.tempMarker.maxZoom}`);
            });

        this.buildTags(
            createNewMarker.createDiv("additional-markers-container")
        );

        let add = new Setting(createNewMarker);

        if (this.tempMarker.isImage) {
            if (!this.canvas) {
                this.canvas = iconDisplay.createEl("canvas");
                let image = new Image();
                image.src = this.tempMarker.imageUrl;
                this.canvas.style.width = "100%";
                this.canvas.style.height = "100%";
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;

                let width = image.width,
                    height = image.height;
                if (width < height) {
                    if (width > this.canvas.width) {
                        height *= this.canvas.width / width;
                        width = this.canvas.width;
                    }
                } else {
                    if (height > this.canvas.height) {
                        width *= this.canvas.height / height;
                        height = this.canvas.height;
                    }
                }
                this.canvas
                    .getContext("2d")
                    .drawImage(image, 0, 0, width - 4, height - 4);
            } else {
                iconDisplay.appendChild(this.canvas);
            }
        }

        add.addButton((button: ButtonComponent): ButtonComponent => {
            let b = button.setTooltip(t("Save")).onClick(async () => {
                // Force refresh
                let error = false;
                if (
                    this.data.markerIcons.find(
                        (marker) => marker.type == this.tempMarker.type
                    ) &&
                    this.tempMarker.type != this.marker.type
                ) {
                    setValidationError(
                        typeTextInput,
                        t("Marker type already exists.")
                    );
                    error = true;
                }

                if (this.tempMarker.type.length == 0) {
                    setValidationError(
                        typeTextInput,
                        t("Marker name cannot be empty.")
                    );
                    error = true;
                }
                if (
                    !findIconDefinition({
                        iconName: iconTextInput.inputEl.value as IconName,
                        prefix: "fas"
                    }) &&
                    !this.tempMarker.isImage
                ) {
                    setValidationError(iconTextInput, t("Invalid icon name."));
                    error = true;
                }

                if (!this.tempMarker.iconName && !this.tempMarker.isImage) {
                    setValidationError(
                        iconTextInput,
                        t("Icon cannot be empty.")
                    );
                    error = true;
                }

                if (error) {
                    return;
                }

                this.marker.type = this.tempMarker.type;
                this.marker.iconName = this.tempMarker.iconName;
                this.marker.color = this.tempMarker.color;
                this.marker.alpha = this.tempMarker.alpha ?? 1;
                this.marker.layer = this.tempMarker.layer;
                this.marker.transform = this.tempMarker.transform;
                this.marker.isImage = this.tempMarker.isImage;
                this.marker.imageUrl = this.tempMarker.imageUrl;
                this.marker.tags = this.tempMarker.tags;
                this.marker.minZoom = this.tempMarker.minZoom;
                this.marker.maxZoom = this.tempMarker.maxZoom;

                this.saved = true;

                this.close();
            });
            b.buttonEl.appendChild(
                icon(
                    findIconDefinition({
                        iconName: "save",
                        prefix: "fas"
                    })
                ).node[0]
            );
            return b;
        });
        add.addExtraButton((b) => {
            b.setIcon("cross")
                .setTooltip(t("Cancel"))
                .onClick(() => {
                    this.close();
                });
        });

        if (focusEl) {
            (
                this.contentEl.querySelector(`#${focusEl}`) as HTMLInputElement
            ).focus();
        }
    }

    buildTags(containerEl: HTMLElement, focus: boolean = false) {
        containerEl.empty();
        let tag: string;
        const tagSetting = new Setting(containerEl)
            .setHeading()
            .setName(t("Associate Tags"))
            .setDesc(t("Markers created from this tag using "))
            .addText((t) => {
                t.setPlaceholder("Add Tag");
                t.onChange((v) => (tag = v));
                if (focus) t.inputEl.focus();
            })
            .addButton((b) => {
                b.setTooltip("Add Tag")
                    .setButtonText("+")
                    .onClick(() => {
                        if (
                            tag &&
                            tag.length &&
                            !this.tempMarker.tags?.includes(tag)
                        ) {
                            this.tempMarker.tags.push(tag);
                            this.buildTags(containerEl, true);
                        }
                    });
            });
        tagSetting.descEl.createEl("code", { text: "markerTag" });
        tagSetting.descEl.createSpan({
            text: t(" will use this marker icon by default.")
        });

        const tagContainer = containerEl.createDiv("additional-markers");
        if (!this.tempMarker.tags) return;
        for (let tag of this.tempMarker.tags) {
            new Setting(tagContainer).setName(tag).addExtraButton((b) =>
                b
                    .setIcon("trash")
                    .setTooltip("Remove Tag")
                    .onClick(() => {
                        this.tempMarker.tags = this.tempMarker.tags.filter(
                            (t) => t !== tag
                        );
                        this.buildTags(containerEl);
                    })
            );
        }
    }

    onOpen() {
        this.display();
    }

    getFillColor(el: HTMLElement): string[] {
        let fill = getComputedStyle(el).getPropertyValue("background-color");

        if (fill.includes("rgb")) {
            // Choose correct separator
            let sep = fill.indexOf(",") > -1 ? "," : " ";
            // Turn "rgb(r,g,b)" into [r,g,b]
            let rgbArr = fill.split("(")[1].split(")")[0].split(sep);
            let r = (+rgbArr[0]).toString(16),
                g = (+rgbArr[1]).toString(16),
                b = (+rgbArr[2]).toString(16);

            if (r.length == 1) r = "0" + r;
            if (g.length == 1) g = "0" + g;
            if (b.length == 1) b = "0" + b;

            return ["#" + r + g + b, rgbArr[3] ? `${+rgbArr[3]}` : "1"];
        }
        if (fill.includes("#")) {
            return [fill, "1"];
        }
    }
}



================================================
FILE: src/modals/suggester.ts
================================================
import {
    App,
    FuzzyMatch,
    FuzzySuggestModal,
    Scope,
    SuggestModal
} from "obsidian";
import { createPopper, Instance as PopperInstance } from "@popperjs/core";

class Suggester<T> {
    owner: SuggestModal<T>;
    items: T[];
    suggestions: HTMLDivElement[];
    selectedItem: number;
    containerEl: HTMLElement;
    constructor(
        owner: SuggestModal<T>,
        containerEl: HTMLElement,
        scope: Scope
    ) {
        this.containerEl = containerEl;
        this.owner = owner;
        containerEl.on(
            "click",
            ".suggestion-item",
            this.onSuggestionClick.bind(this)
        );
        containerEl.on(
            "mousemove",
            ".suggestion-item",
            this.onSuggestionMouseover.bind(this)
        );

        scope.register([], "ArrowUp", () => {
            this.setSelectedItem(this.selectedItem - 1, true);
            return false;
        });

        scope.register([], "ArrowDown", () => {
            this.setSelectedItem(this.selectedItem + 1, true);
            return false;
        });

        scope.register([], "Enter", (evt) => {
            this.useSelectedItem(evt);
            return false;
        });

        scope.register([], "Tab", (evt) => {
            this.chooseSuggestion(evt);
            return false;
        });
    }
    chooseSuggestion(evt: KeyboardEvent) {
        if (!this.items || !this.items.length) return;
        const currentValue = this.items[this.selectedItem];
        if (currentValue) {
            this.owner.onChooseSuggestion(currentValue, evt);
        }
    }
    onSuggestionClick(event: MouseEvent, el: HTMLDivElement): void {
        event.preventDefault();
        if (!this.suggestions || !this.suggestions.length) return;

        const item = this.suggestions.indexOf(el);
        this.setSelectedItem(item, false);
        this.useSelectedItem(event);
    }

    onSuggestionMouseover(event: MouseEvent, el: HTMLDivElement): void {
        if (!this.suggestions || !this.suggestions.length) return;
        const item = this.suggestions.indexOf(el);
        this.setSelectedItem(item, false);
    }
    empty() {
        this.containerEl.empty();
    }
    setSuggestions(items: T[]) {
        this.containerEl.empty();
        const els: HTMLDivElement[] = [];

        items.forEach((item) => {
            const suggestionEl = this.containerEl.createDiv("suggestion-item");
            this.owner.renderSuggestion(item, suggestionEl);
            els.push(suggestionEl);
        });
        this.items = items;
        this.suggestions = els;
        this.setSelectedItem(0, false);
    }
    useSelectedItem(event: MouseEvent | KeyboardEvent) {
        if (!this.items || !this.items.length) return;
        const currentValue = this.items[this.selectedItem];
        if (currentValue) {
            this.owner.selectSuggestion(currentValue, event);
        }
    }
    wrap(value: number, size: number): number {
        return ((value % size) + size) % size;
    }
    setSelectedItem(index: number, scroll: boolean) {
        const nIndex = this.wrap(index, this.suggestions.length);
        const prev = this.suggestions[this.selectedItem];
        const next = this.suggestions[nIndex];

        if (prev) prev.removeClass("is-selected");
        if (next) next.addClass("is-selected");

        this.selectedItem = nIndex;

        if (scroll) {
            next.scrollIntoView(false);
        }
    }
}

export abstract class SuggestionModal<T> extends FuzzySuggestModal<T> {
    items: T[] = [];
    suggestions: HTMLDivElement[];
    popper: PopperInstance;
    //@ts-ignore
    scope: Scope = new Scope(this.app.scope);
    suggester: Suggester<FuzzyMatch<T>>;
    suggestEl: HTMLDivElement;
    promptEl: HTMLDivElement;
    emptyStateText: string = "No match found";
    limit: number = 100;
    shouldNotOpen: boolean;
    constructor(app: App, inputEl: HTMLInputElement, items: T[]) {
        super(app);
        this.inputEl = inputEl;
        this.items = items;

        this.suggestEl = createDiv("suggestion-container");

        this.contentEl = this.suggestEl.createDiv("suggestion");

        this.suggester = new Suggester(this, this.contentEl, this.scope);

        this.scope.register([], "Escape", this.onEscape.bind(this));

        this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
        this.inputEl.addEventListener("focus", this.onFocus.bind(this));
        this.inputEl.addEventListener("blur", this.close.bind(this));
        this.suggestEl.on(
            "mousedown",
            ".suggestion-container",
            (event: MouseEvent) => {
                event.preventDefault();
            }
        );
    }
    empty() {
        this.suggester.empty();
    }
    onInputChanged(): void {
        if (this.shouldNotOpen) return;
        const inputStr = this.modifyInput(this.inputEl.value);
        const suggestions = this.getSuggestions(inputStr);
        if (suggestions.length > 0) {
            this.suggester.setSuggestions(suggestions.slice(0, this.limit));
        } else {
            this.onNoSuggestion();
        }
        this.open();
    }
    onFocus(): void {
        this.shouldNotOpen = false;
        this.onInputChanged();
    }
    modifyInput(input: string): string {
        return input;
    }
    onNoSuggestion() {
        this.empty();
        this.renderSuggestion(
            null,
            this.contentEl.createDiv("suggestion-item")
        );
    }
    open(): void {
        // TODO: Figure out a better way to do this. Idea from Periodic Notes plugin
        this.app.keymap.pushScope(this.scope);

        document.body.appendChild(this.suggestEl);
        this.popper = createPopper(this.inputEl, this.suggestEl, {
            placement: "bottom-start",
            modifiers: [
                {
                    name: "offset",
                    options: {
                        offset: [0, 10]
                    }
                },
                {
                    name: "flip",
                    options: {
                        fallbackPlacements: ["top"]
                    }
                }
            ]
        });
    }

    onEscape(): void {
        this.close();
        this.shouldNotOpen = true;
    }
    close(): void {
        // TODO: Figure out a better way to do this. Idea from Periodic Notes plugin
        this.app.keymap.popScope(this.scope);

        this.suggester.setSuggestions([]);
        if (this.popper) {
            this.popper.destroy();
        }

        this.suggestEl.detach();
    }
    createPrompt(prompts: HTMLSpanElement[]) {
        if (!this.promptEl)
            this.promptEl = this.suggestEl.createDiv("prompt-instructions");
        let prompt = this.promptEl.createDiv("prompt-instruction");
        for (let p of prompts) {
            prompt.appendChild(p);
        }
    }
    abstract onChooseItem(item: T, evt: MouseEvent | KeyboardEvent): void;
    abstract getItemText(arg: T): string;
    abstract getItems(): T[];
}



================================================
FILE: src/modals/tag.ts
================================================
[Empty file]


================================================
FILE: src/settings/settings.ts
================================================
import {
    PluginSettingTab,
    Setting,
    App,
    Notice,
    ButtonComponent,
    TFolder
} from "obsidian";
import { parse as parseCSV, unparse as unparseCSV } from "papaparse";

import {
    findIconDefinition,
    IconName,
    icon,
    getIcon,
    getId,
    iconNames,
    removeValidationError,
    setValidationError,
    getMarkerIcon,
    DEFAULT_TILE_SERVER,
    DEFAULT_ATTRIBUTION,
    DEFAULT_TILE_SUBDOMAINS
} from "src/utils";
import { IconSuggestionModal } from "src/modals";

import { FolderSuggestionModal } from "src/modals/path";
import type ObsidianLeaflet from "src/main";
import t from "src/l10n/locale";
import { TooltipDisplay, SavedMarkerProperties, MapMarkerData } from "types";

export class ObsidianLeafletSettingTab extends PluginSettingTab {
    plugin: ObsidianLeaflet;

    constructor(app: App, plugin: ObsidianLeaflet) {
        super(app, plugin);
        this.plugin = plugin;
    }
    get data() {
        return this.plugin.data;
    }
    async display(): Promise<void> {
        let { containerEl } = this;

        containerEl.empty();

        containerEl.addClass("obsidian-leaflet-settings");

        containerEl.createEl("h2", { text: t("Obsidian Leaflet Settings") });

        this.createCSVSetting(containerEl.createDiv());

        this.createMarkerSettings(containerEl.createDiv());

        this.createMapSettings(containerEl.createDiv());

        let defaultMarker = containerEl.createDiv(
            "additional-markers-container"
        );
        this.createDefaultMarkerSettings(defaultMarker);

        let additionalMarkers = containerEl.createDiv(
            "additional-markers-container"
        );

        this.createAdditionalMarkerSettings(additionalMarkers);
        const div = containerEl.createDiv("coffee");
        div.createEl("a", {
            href: "https://www.buymeacoffee.com/valentine195"
        }).createEl("img", {
            attr: {
                src: "https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=☕&slug=valentine195&button_colour=e3e7ef&font_colour=262626&font_family=Inter&outline_colour=262626&coffee_colour=ff0000"
            }
        });
        await this.plugin.saveSettings();
    }
    createDefaultMarkerSettings(defaultMarker: HTMLDivElement) {
        let defaultSetting = new Setting(defaultMarker)
            .setHeading()
            .setName(t("Default Map Marker"))
            .setDesc(t("This marker is always available."));
        let iconDisplay = defaultSetting.settingEl.createDiv({
            attr: {
                style: `align-self: start; margin: 0 18px; font-size: 24px; color: ${this.data.defaultMarker.color};`
            }
        });

        iconDisplay.appendChild(getMarkerIcon(this.data.defaultMarker).node);

        let settings = defaultMarker.createDiv({
            cls: "additional-markers"
        });
        const input = createEl("input", {
            attr: {
                type: "file",
                name: "image",
                accept: "image/*"
            }
        });
        const defaultMarkerIconSetting = new Setting(settings)
            .setName(t("Icon Name"))
            .addText((text) => {
                text.setPlaceholder(t("Icon Name")).setValue(
                    !this.data.defaultMarker.isImage
                        ? this.data.defaultMarker.iconName
                        : ""
                );

                const validate = async () => {
                    const new_value = text.inputEl.value;

                    if (!new_value.length) {
                        setValidationError(
                            text,
                            t("A default marker must be defined.")
                        );
                        return;
                    }
                    if (
                        !findIconDefinition({
                            iconName: new_value as IconName,
                            prefix: "fas"
                        })
                    ) {
                        setValidationError(
                            text,
                            t(
                                "The selected icon does not exist in Font Awesome Free."
                            )
                        );
                        return;
                    }

                    removeValidationError(text);
                    this.data.defaultMarker.iconName = new_value;
                    this.data.defaultMarker.isImage = false;

                    await this.plugin.saveMarkerTypes();

                    this.display();
                };

                const modal = new IconSuggestionModal(
                    this.app,
                    text,
                    iconNames
                );

                modal.onClose = validate;

                text.inputEl.onblur = validate;
            })
            .addButton((b) => {
                b.setButtonText(t("Upload Image")).setTooltip(
                    t("Upload Image")
                );
                b.buttonEl.addClass("leaflet-file-upload");
                b.buttonEl.appendChild(input);
                b.onClick(() => input.click());
            });

        /** Image Uploader */
        input.onchange = async () => {
            const { files } = input;

            if (!files.length) return;

            const image = files[0];
            const reader = new FileReader();
            reader.onloadend = (evt) => {
                var image = new Image();
                image.onload = () => {
                    // Resize the image
                    const canvas = document.createElement("canvas"),
                        max_size = 24;
                    let width = image.width,
                        height = image.height;
                    if (width >= height && width > max_size) {
                        height *= max_size / width;
                        width = max_size;
                    } else if (height >= width && height > max_size) {
                        width *= max_size / height;
                        height = max_size;
                    }
                    canvas.width = width;
                    canvas.height = height;
                    canvas
                        .getContext("2d")
                        .drawImage(image, 0, 0, width, height);

                    this.data.defaultMarker.isImage = true;
                    this.data.defaultMarker.imageUrl =
                        canvas.toDataURL("image/png");

                    this.plugin.saveMarkerTypes();
                    this.display();

                    //defaultMarkerIconSetting.settingEl.appendChild(canvas);
                };
                image.src = evt.target.result.toString();
            };
            reader.readAsDataURL(image);

            input.value = null;
        };
        if (!this.data.defaultMarker.isImage) {
            let colorInput = new Setting(settings).setName(t("Marker Color"));

            let colorInputNode = colorInput.controlEl.createEl("input", {
                attr: {
                    type: "color",
                    value: this.data.defaultMarker.color
                }
            });
            colorInputNode.oninput = ({ target }) => {
                this.data.defaultMarker.color = (
                    target as HTMLInputElement
                ).value;

                iconDisplay.children[0].setAttribute(
                    "style",
                    `color: ${this.data.defaultMarker.color}`
                );
            };
            colorInputNode.onchange = async ({ target }) => {
                this.data.defaultMarker.color = (
                    target as HTMLInputElement
                ).value;
                this.display();
            };

            new Setting(settings)
                .setName(t("Layer Base Marker"))
                .setDesc(
                    t("Use as base layer for additional markers by default.")
                )
                .addToggle((t) => {
                    t.setValue(this.data.layerMarkers);
                    t.onChange(async (v) => {
                        this.data.layerMarkers = v;
                        this.data.markerIcons.forEach(
                            (marker) => (marker.layer = v)
                        );

                        await this.plugin.saveMarkerTypes();

                        this.display();
                        return;
                    });
                });
        }
    }
    createAdditionalMarkerSettings(additionalMarkers: HTMLDivElement) {
        new Setting(additionalMarkers)
            .setHeading()
            .setName(t("Additional Map Markers"))
            .setDesc(
                t(
                    "These markers will be available in the right-click menu on the map."
                )
            )
            .addButton((button: ButtonComponent): ButtonComponent => {
                let b = button
                    .setTooltip(t("Add Additional"))
                    .onClick(async () => {
                        const newMarker =
                            await this.plugin.createNewMarkerType();
                        if (!newMarker) return;
                        this.data.markerIcons.push(newMarker);
                        await this.plugin.saveMarkerTypes();

                        this.display();
                    });
                b.buttonEl.appendChild(
                    icon(
                        findIconDefinition({
                            iconName: "plus",
                            prefix: "fas"
                        })
                    ).node[0]
                );
                return b;
            });
        let markers = additionalMarkers.createDiv({
            cls: "additional-markers"
        });
        this.plugin.markerIcons.slice(1).forEach((marker) => {
            let setting = new Setting(markers)
                .addExtraButton((b) =>
                    b.onClick(async () => {
                        const edit = await this.plugin.createNewMarkerType({
                            original: marker.markerIcon
                        });
                        if (!edit || !edit.type || !edit.iconName) {
                            return;
                        }

                        if (edit.type != marker.type) {
                            this.data.mapMarkers.forEach(({ markers }) => {
                                markers = markers.map((m) => {
                                    if (m.type == marker.type) {
                                        m.type = edit.type;
                                    }
                                    return m;
                                });
                            });
                        }

                        await this.plugin.saveMarkerTypes();
                        this.display();
                    })
                )
                .addExtraButton((b) =>
                    b.setIcon("trash").onClick(async () => {
                        this.data.markerIcons = this.data.markerIcons.filter(
                            (m) => m !== marker.markerIcon
                        );
                        await this.plugin.saveMarkerTypes();
                        this.display();
                    })
                );

            let markerIconDiv = createDiv({
                cls: "marker-icon-display"
            });
            markerIconDiv.innerHTML = marker.html;
            let name = setting.nameEl.createDiv("marker-type-display");
            name.appendChild(markerIconDiv);
            name.appendText(marker.type);
            if (marker.markerIcon.tags && marker.markerIcon.tags.length) {
                setting.setDesc(marker.markerIcon.tags.join(", "));
            }
        });
    }
    createMapSettings(containerEl: HTMLElement) {
        containerEl.empty();
        new Setting(containerEl)
            .setName(t("Default Latitude"))
            .setDesc(
                t(
                    "Real-world maps will open to this latitude if not specified."
                )
            )
            .addText((text) => {
                text.setValue(`${this.data.lat}`);
                text.onChange((v) => {
                    if (isNaN(Number(v))) {
                        setValidationError(
                            text,
                            t("Latitude must be a number.")
                        );
                        return;
                    }
                    removeValidationError(text);
                    this.data.lat = Number(v);
                    text.inputEl.addEventListener("blur", async () => {
                        this.display();
                    });
                });
            });
        new Setting(containerEl)
            .setName(t("Default Longitude"))
            .setDesc(
                t(
                    "Real-world maps will open to this longitude if not specified."
                )
            )
            .addText((text) => {
                text.setValue(`${this.data.long}`);
                text.onChange((v) => {
                    if (isNaN(Number(v))) {
                        setValidationError(
                            text,
                            t("Longitude must be a number.")
                        );
                        return;
                    }
                    removeValidationError(text);
                    this.data.long = Number(v);
                });

                text.inputEl.addEventListener("blur", async () => {
                    this.display();
                });
            });
        new Setting(containerEl)
            .setName(t("Default Units"))
            .setDesc(t("Select the default system of units for the map."))
            .addDropdown((d) => {
                d.addOption("imperial", t("Imperial"))
                    .addOption("metric", t("Metric"))
                    .setValue(this.plugin.data.defaultUnitType)
                    .onChange(async (v: "imperial" | "metric") => {
                        this.plugin.data.defaultUnitType = v;
                        await this.plugin.saveSettings();
                    });
            });
        new Setting(containerEl)
            .setName(t("Default Tile Server"))
            .setDesc(
                t(
                    "It is up to you to ensure you have proper access to this tile server."
                )
            )
            .addText((t) => {
                t.setValue(this.plugin.data.defaultTile).onChange((v) => {
                    this.plugin.data.defaultTile = v;
                    this.plugin.saveSettings();
                });
            })
            .addExtraButton((b) =>
                b
                    .setIcon("reset")
                    .setTooltip(t("Reset"))
                    .onClick(() => {
                        this.plugin.data.defaultTile = DEFAULT_TILE_SERVER;

                        this.createMapSettings(containerEl);
                        this.plugin.saveSettings();
                    })
            );
        new Setting(containerEl)
            .setName(t("Default Tile Server Subdomains"))
            .setDesc(
                t(
                    "Available subdomains for this tile server concurrent requests."
                )
            )
            .addText((t) => {
                t.setValue(this.plugin.data.defaultTileSubdomains).onChange(
                    (v) => {
                        this.plugin.data.defaultTileSubdomains = v;
                        this.plugin.saveSettings();
                    }
                );
            })
            .addExtraButton((b) =>
                b
                    .setIcon("reset")
                    .setTooltip(t("Reset"))
                    .onClick(() => {
                        this.plugin.data.defaultTileSubdomains =
                            DEFAULT_TILE_SUBDOMAINS;

                        this.createMapSettings(containerEl);
                        this.plugin.saveSettings();
                    })
            );
        new Setting(containerEl)
            .setName(t("Default Tile Server Attribution"))
            .setDesc(
                t(
                    "Please ensure your attribution meets all requirements set by the tile server."
                )
            )
            .addTextArea((t) => {
                t.setValue(this.plugin.data.defaultAttribution).onChange(
                    (v) => {
                        this.plugin.data.defaultAttribution = v;
                        this.plugin.saveSettings();
                    }
                );
            })
            .addExtraButton((b) =>
                b
                    .setIcon("reset")
                    .setTooltip(t("Reset"))
                    .onClick(() => {
                        this.plugin.data.defaultAttribution =
                            DEFAULT_ATTRIBUTION;

                        this.createMapSettings(containerEl);
                        this.plugin.saveSettings();
                    })
            );
        new Setting(containerEl)
            .setName(t("Default Tile Server (Dark Mode)"))
            .setDesc(
                t(
                    "It is up to you to ensure you have proper access to this tile server."
                )
            )
            .addText((t) => {
                t.setValue(this.plugin.data.defaultTileDark).onChange((v) => {
                    this.plugin.data.defaultTileDark = v;
                    this.plugin.saveSettings();
                });
            })
            .addExtraButton((b) =>
                b
                    .setIcon("reset")
                    .setTooltip(t("Reset"))
                    .onClick(() => {
                        this.plugin.data.defaultTileDark = DEFAULT_TILE_SERVER;
                        this.createMapSettings(containerEl);
                        this.plugin.saveSettings();
                    })
            );
    }
    createMarkerSettings(containerEl: HTMLElement) {
        const configSetting = new Setting(containerEl)
            .addText(async (text) => {
                let folders = this.app.vault
                    .getAllLoadedFiles()
                    .filter((f) => f instanceof TFolder);

                text.setPlaceholder(
                    this.data.configDirectory ?? this.app.vault.configDir
                );
                const modal = new FolderSuggestionModal(this.app, text, [
                    ...(folders as TFolder[])
                ]);

                modal.onClose = async () => {
                    if (!text.inputEl.value) {
                        this.data.configDirectory = null;
                    } else {
                        const exists = await this.app.vault.adapter.exists(
                            text.inputEl.value
                        );

                        if (!exists) {
                            //confirm}

                            this.data.configDirectory = text.inputEl.value;
                            await this.plugin.saveSettings();
                        }
                    }
                };

                text.inputEl.onblur = async () => {
                    if (!text.inputEl.value) {
                        return;
                    }
                    const exists = await this.app.vault.adapter.exists(
                        text.inputEl.value
                    );

                    this.data.configDirectory = text.inputEl.value;

                    await this.plugin.saveSettings();
                    this.display();
                };
            })
            .addExtraButton((b) => {
                b.setTooltip(t("Reset to Default"))
                    .setIcon("undo-glyph")
                    .onClick(async () => {
                        this.data.configDirectory = null;
                        await this.plugin.saveSettings();
                        this.display();
                    });
            });
        configSetting.descEl.createSpan({
            text: t("Please back up your data before changing this setting.")
        });
        configSetting.descEl.createEl("br");
        configSetting.descEl.createSpan({
            text: `${t("Current directory")}: `
        });
        const configDirectory =
            this.data.configDirectory ?? this.app.vault.configDir;
        configSetting.descEl.createEl("code", {
            text: configDirectory
        });

        let name = configSetting.nameEl.createDiv();
        name.appendChild(
            icon(
                findIconDefinition({
                    iconName: "exclamation-triangle",
                    prefix: "fas"
                })
            ).node[0]
        );
        name.appendChild(createSpan({ text: t("Default Config Directory") }));
        new Setting(containerEl)
            .setName(t("Default Marker Tooltip Behavior"))
            .setDesc(
                t(
                    "New markers will be created to this setting by default. Can be overridden per-marker."
                )
            )
            .addDropdown((drop) => {
                drop.addOption("always", t("Always"));
                drop.addOption("hover", t("Hover"));
                drop.addOption("never", t("Never"));
                drop.setValue(
                    this.plugin.data.displayMarkerTooltips ?? "hover"
                ).onChange((value: TooltipDisplay) => {
                    this.plugin.data.displayMarkerTooltips = value;
                });
            });
        new Setting(containerEl)
            .setName(t("Enable Draw Mode by Default"))
            .setDesc(
                t(
                    "The draw control will be added to maps by default. Can be overridden with the draw map block parameter."
                )
            )
            .addToggle((toggle) =>
                toggle
                    .setValue(this.data.enableDraw)

                    .onChange(async (v) => {
                        this.data.enableDraw = v;

                        await this.plugin.saveSettings();

                        this.display();
                    })
            );
        new Setting(containerEl)
            .setName(t("Display Note Preview"))
            .setDesc(
                t(
                    "Markers linked to notes will show a note preview when hovered."
                )
            )
            .addToggle((toggle) =>
                toggle.setValue(this.data.notePreview).onChange(async (v) => {
                    this.data.notePreview = v;

                    await this.plugin.saveSettings();

                    this.display();
                })
            );
        new Setting(containerEl)
            .setName(t("Display Overlay Tooltips"))
            .setDesc(t("Overlay tooltips will display when hovered."))
            .addToggle((toggle) =>
                toggle
                    .setValue(this.data.displayOverlayTooltips)
                    .onChange(async (v) => {
                        this.data.displayOverlayTooltips = v;

                        await this.plugin.saveSettings();
                        this.display();
                    })
            );
        new Setting(containerEl)
            .setName(t("Copy Coordinates on Shift-Click"))
            .setDesc(
                t(
                    "Map coordinates will be copied to the clipboard when shift-clicking."
                )
            )
            .addToggle((toggle) =>
                toggle.setValue(this.data.copyOnClick).onChange(async (v) => {
                    this.data.copyOnClick = v;

                    await this.plugin.saveSettings();
                    this.display();
                })
            );
    }
    createCSVSetting(containerEl: HTMLElement) {
        const importSetting = new Setting(containerEl).setDesc(
            t(
                "This setting is experimental and could cause marker data issues. Use at your own risk."
            )
        );
        let name = importSetting.nameEl.createDiv();
        name.appendChild(
            icon(
                findIconDefinition({
                    iconName: "exclamation-triangle",
                    prefix: "fas"
                })
            ).node[0]
        );
        name.appendChild(createSpan({ text: t("Import Marker CSV File") }));
        const input = createEl("input", {
            attr: {
                type: "file",
                name: "merge",
                accept: ".csv"
            }
        });
        importSetting.addButton((b) => {
            b.setButtonText(t("Choose File")).setTooltip(t("Upload CSV File"));
            b.buttonEl.addClass("leaflet-file-upload");
            b.buttonEl.appendChild(input);
            b.onClick(() => input.click());
        });
        input.onchange = async () => {
            const { files } = input;

            if (!files.length) return;
            try {
                const csv = await files[0].text(),
                    markersToAdd: Map<string, SavedMarkerProperties[]> =
                        new Map(),
                    parsed = parseCSV<string[]>(csv);

                if (parsed.data && parsed.data.length) {
                    for (let i = 0; i < parsed.data.length; i++) {
                        let data = parsed.data[i];
                        if (!data || data.length < 6) continue;
                        let [map, type, lat, long, link, layer, id] = data.map(
                            (l) => l.replace(/"/g, "")
                        );
                        if (!map || !map.length || map === "undefined") {
                            new Notice(
                                t("Map not specified for line %1", `${i + 1}`)
                            );
                            continue;
                        }
                        if (
                            !type ||
                            !type.length ||
                            type === "undefined" ||
                            (type != "default" &&
                                !this.data.markerIcons.find(
                                    ({ type: t }) => t == type
                                ))
                        ) {
                            type = "default";
                        }
                        if (!lat || !lat.length || isNaN(Number(lat))) {
                            new Notice(
                                t(
                                    "Could not parse latitude for line %1",
                                    `${i + 1}`
                                )
                            );
                            continue;
                        }
                        if (!long || !long.length || isNaN(Number(long))) {
                            new Notice(
                                t(
                                    "Could not parse longitude for line %1",
                                    `${i + 1}`
                                )
                            );
                            continue;
                        }

                        if (!link || !link.length || link === "undefined") {
                            link = undefined;
                        } else if (/\[\[[\s\S]+\]\]/.test(link)) {
                            //obsidian wiki-link
                            [, link] = link.match(/\[\[([\s\S]+)\]\]/);
                        }
                        if (!id || !id.length || id === "undefined") {
                            id = getId();
                        }
                        if (!markersToAdd.has(map)) markersToAdd.set(map, []);
                        const mapMap = markersToAdd.get(data[0]);
                        mapMap.push({
                            type: type,
                            loc: [Number(lat), Number(long)],
                            percent: undefined,
                            link: link,
                            layer: layer,
                            id: id,
                            command: false,
                            description: null,
                            mutable: true,
                            minZoom: null,
                            maxZoom: null,
                            tooltip: "hover"
                        });
                        markersToAdd.set(data[0], mapMap);
                    }

                    for (let [id, markers] of [...markersToAdd]) {
                        if (
                            !this.data.mapMarkers.find(({ id: p }) => p == id)
                        ) {
                            const map: MapMarkerData = {
                                id: id,
                                files: [],
                                lastAccessed: Date.now(),
                                markers: [],
                                overlays: [],
                                shapes: [],
                                locked: false
                            };
                            this.data.mapMarkers.push(map);
                        }

                        if (this.plugin.maps.find(({ id: p }) => p == id)) {
                            let map = this.plugin.maps.find(
                                ({ id: p }) => p == id
                            ).map;
                            for (let marker of markers) {
                                map.markers = map.markers.filter(
                                    ({ id }) => id != marker.id
                                );
                                map.createMarker(
                                    marker.type as string,
                                    marker.loc,
                                    undefined,
                                    marker.link,
                                    marker.id,
                                    marker.layer
                                );
                            }
                        } else {
                            let map = this.data.mapMarkers.find(
                                ({ id: p }) => p == id
                            );
                            for (let marker of markers) {
                                map.markers = map.markers.filter(
                                    ({ id }) => id != marker.id
                                );
                                map.markers.push(marker);
                            }
                        }
                    }
                    await this.plugin.saveSettings();
                    new Notice("Marker file successfully imported.");
                }
            } catch (e) {
                new Notice(
                    t("There was an error while importing %1", files[0].name)
                );
                console.error(e);
            }

            input.value = null;
        };

        let exportSetting = new Setting(containerEl);
        exportSetting
            .setName(t("Export Marker Data"))
            .setDesc(t("Export all marker data to a CSV file."))
            .addButton((b) => {
                b.setButtonText(t("Export")).onClick(() => {
                    let csv = [];
                    for (let { id: mapId, markers } of this.data.mapMarkers) {
                        for (let { type, loc, link, layer, id } of markers) {
                            csv.push([
                                mapId,
                                type,
                                loc[0],
                                loc[1],
                                link,
                                layer,
                                id
                            ]);
                        }
                    }

                    let csvFile = new Blob([unparseCSV(csv)], {
                        type: "text/csv"
                    });
                    let downloadLink = document.createElement("a");
                    downloadLink.download = "leaflet_marker_data.csv";
                    downloadLink.href = window.URL.createObjectURL(csvFile);
                    downloadLink.style.display = "none";
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                });
            });
    }
}



================================================
FILE: src/utils/constants.ts
================================================
import { Platform } from "obsidian";
import { BlockParameters, LeafletMapOptions, ObsidianAppData } from "../types";

export const OBSIDIAN_LEAFLET_POPOVER_SOURCE = "obsidian-leaflet";

export const VIEW_TYPE = "obsidian-leaflet-map-view";

export const DEFAULT_TILE_SERVER =
    "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png";
export const DEFAULT_TILE_SUBDOMAINS = "a,b,c,d";
export const TILE_SUBDOMAINS_SPILT = ",";

export const DEFAULT_ATTRIBUTION =
    '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>';

export const OVERLAY_TAG_REGEX = /^(\d+(?:\.\d+)?)\s?(\w*)/;

export const MAP_OVERLAY_STROKE_WIDTH = 2;
export const MAP_OVERLAY_STROKE_OPACITY = 0.6;

export const LAT_LONG_DECIMALS = 4;
export const DISTANCE_DECIMALS = 1;

export const DEFAULT_BLOCK_PARAMETERS: BlockParameters = {
    darkMode: "false",
    defaultZoom: 5,
    distanceMultiplier: 1,
    drawColor: "#3388ff",
    geojson: [],
    geojsonColor: "#3388ff",
    gpx: [],
    gpxColor: "#3388ff",
    height: "500px",
    image: "real",
    imageOverlay: [],
    isMapView: false,
    layers: [],
    linksFrom: [],
    linksTo: [],
    marker: [],
    commandMarker: [],
    markerFile: [],
    markerFolder: [],
    markerTag: [],
    maxZoom: 10,
    minZoom: 1,
    osmLayer: true,
    overlay: [],
    overlayColor: "blue",
    scale: 1,
    showAllMarkers: false,
    tileServer: [],
    verbose: false,
    zoomDelta: 1,
    zoomFeatures: false
};

export const DEFAULT_MAP_OPTIONS: LeafletMapOptions = {
    type: "real",
    minZoom: 1,
    maxZoom: 10,
    defaultZoom: 1,
    zoomDelta: 1,
    unit: "m",
    scale: 1,
    distanceMultiplier: 1,
    darkMode: false,
    overlayColor: "blue",
    osmLayer: true,
    isMapView: false
};
export const DEFAULT_SETTINGS: ObsidianAppData = {
    mapMarkers: [],
    defaultMarker: {
        type: "default",
        iconName: "map-marker",
        color: "#dddddd",
        transform: { size: 6, x: 0, y: -2 }
    },
    markerIcons: [],
    color: "#dddddd",
    lat: 39.983334,
    long: -82.98333,
    notePreview: false,
    layerMarkers: true,
    previousVersion: null,
    version: {
        major: null,
        minor: null,
        patch: null
    },
    warnedAboutMapMarker: false,
    copyOnClick: false,
    displayMarkerTooltips: "hover",
    displayOverlayTooltips: true,
    configDirectory: null,
    mapViewEnabled: true,
    mapViewParameters: {},
    enableDraw: true,
    defaultUnitType: "imperial",
    defaultTile: DEFAULT_TILE_SERVER,
    defaultTileDark: DEFAULT_TILE_SERVER,
    defaultAttribution: DEFAULT_ATTRIBUTION,
    defaultTileSubdomains: DEFAULT_TILE_SUBDOMAINS
};
export const BASE_POPUP_OPTIONS = {
    className: "leaflet-marker-link-popup",
    autoClose: false,
    closeButton: false,
    closeOnClick: false,
    autoPan: false
};

export const MODIFIER_KEY = Platform.isMacOS ? "Meta" : "Control";

/** From https://github.com/leaflet-extras/leaflet-providers/blob/master/leaflet-providers.js */
/** CURRENTLY UNUSED */
export const LEAFLET_PROVIDERS = {
    OpenStreetMap: {
        url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        options: {
            maxZoom: 19,
            attribution:
                '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        },
        variants: {
            Mapnik: {},
            DE: {
                url: "https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png",
                options: {
                    maxZoom: 18
                }
            },
            CH: {
                url: "https://tile.osm.ch/switzerland/{z}/{x}/{y}.png",
                options: {
                    maxZoom: 18,
                    bounds: [
                        [45, 5],
                        [48, 11]
                    ]
                }
            },
            France: {
                url: "https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png",
                options: {
                    maxZoom: 20,
                    attribution:
                        "&copy; OpenStreetMap France | {attribution.OpenStreetMap}"
                }
            },
            HOT: {
                url: "https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png",
                options: {
                    attribution:
                        "{attribution.OpenStreetMap}, " +
                        'Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> ' +
                        'hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
                }
            },
            BZH: {
                url: "https://tile.openstreetmap.bzh/br/{z}/{x}/{y}.png",
                options: {
                    attribution:
                        '{attribution.OpenStreetMap}, Tiles courtesy of <a href="http://www.openstreetmap.bzh/" target="_blank">Breton OpenStreetMap Team</a>',
                    bounds: [
                        [46.2, -5.5],
                        [50, 0.7]
                    ]
                }
            }
        }
    },
    OpenSeaMap: {
        url: "https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png",
        options: {
            attribution:
                'Map data: &copy; <a href="http://www.openseamap.org">OpenSeaMap</a> contributors'
        }
    },
    OpenPtMap: {
        url: "http://openptmap.org/tiles/{z}/{x}/{y}.png",
        options: {
            maxZoom: 17,
            attribution:
                'Map data: &copy; <a href="http://www.openptmap.org">OpenPtMap</a> contributors'
        }
    },
    OpenTopoMap: {
        url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
        options: {
            maxZoom: 17,
            attribution:
                'Map data: {attribution.OpenStreetMap}, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        }
    },
    OpenRailwayMap: {
        url: "https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png",
        options: {
            maxZoom: 19,
            attribution:
                'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://www.OpenRailwayMap.org">OpenRailwayMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        }
    },
    OpenFireMap: {
        url: "http://openfiremap.org/hytiles/{z}/{x}/{y}.png",
        options: {
            maxZoom: 19,
            attribution:
                'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="http://www.openfiremap.org">OpenFireMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        }
    },
    SafeCast: {
        url: "https://s3.amazonaws.com/te512.safecast.org/{z}/{x}/{y}.png",
        options: {
            maxZoom: 16,
            attribution:
                'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://blog.safecast.org/about/">SafeCast</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        }
    },
    Stadia: {
        url: "https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png",
        options: {
            maxZoom: 20,
            attribution:
                '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
        },
        variants: {
            AlidadeSmooth: {
                url: "https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png"
            },
            AlidadeSmoothDark: {
                url: "https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png"
            },
            OSMBright: {
                url: "https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png"
            },
            Outdoors: {
                url: "https://tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{y}{r}.png"
            }
        }
    },
    Thunderforest: {
        url: "https://{s}.tile.thunderforest.com/{variant}/{z}/{x}/{y}.png?apikey={apikey}",
        options: {
            attribution:
                '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, {attribution.OpenStreetMap}',
            variant: "cycle",
            apikey: "<insert your api key here>",
            maxZoom: 22
        },
        variants: {
            OpenCycleMap: "cycle",
            Transport: {
                options: {
                    variant: "transport"
                }
            },
            TransportDark: {
                options: {
                    variant: "transport-dark"
                }
            },
            SpinalMap: {
                options: {
                    variant: "spinal-map"
                }
            },
            Landscape: "landscape",
            Outdoors: "outdoors",
            Pioneer: "pioneer",
            MobileAtlas: "mobile-atlas",
            Neighbourhood: "neighbourhood"
        }
    },
    CyclOSM: {
        url: "https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png",
        options: {
            maxZoom: 20,
            attribution:
                '<a href="https://github.com/cyclosm/cyclosm-cartocss-style/releases" title="CyclOSM - Open Bicycle render">CyclOSM</a> | Map data: {attribution.OpenStreetMap}'
        }
    },
    Hydda: {
        url: "https://{s}.tile.openstreetmap.se/hydda/{variant}/{z}/{x}/{y}.png",
        options: {
            maxZoom: 20,
            variant: "full",
            attribution:
                'Tiles courtesy of <a href="http://openstreetmap.se/" target="_blank">OpenStreetMap Sweden</a> &mdash; Map data {attribution.OpenStreetMap}'
        },
        variants: {
            Full: "full",
            Base: "base",
            RoadsAndLabels: "roads_and_labels"
        }
    },
    Jawg: {
        url: "https://{s}.tile.jawg.io/{variant}/{z}/{x}/{y}{r}.png?access-token={accessToken}",
        options: {
            attribution:
                '<a href="http://jawg.io" title="Tiles Courtesy of Jawg Maps" target="_blank">&copy; <b>Jawg</b>Maps</a> ' +
                "{attribution.OpenStreetMap}",
            minZoom: 0,
            maxZoom: 22,
            subdomains: "abcd",
            variant: "jawg-terrain",
            // Get your own Jawg access token here : https://www.jawg.io/lab/
            // NB : this is a demonstration key that comes with no guarantee
            accessToken: "<insert your access token here>"
        },
        variants: {
            Streets: "jawg-streets",
            Terrain: "jawg-terrain",
            Sunny: "jawg-sunny",
            Dark: "jawg-dark",
            Light: "jawg-light",
            Matrix: "jawg-matrix"
        }
    },
    MapBox: {
        url: "https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}{r}?access_token={accessToken}",
        options: {
            attribution:
                '&copy; <a href="https://www.mapbox.com/about/maps/" target="_blank">Mapbox</a> ' +
                "{attribution.OpenStreetMap} " +
                '<a href="https://www.mapbox.com/map-feedback/" target="_blank">Improve this map</a>',
            tileSize: 512,
            maxZoom: 18,
            zoomOffset: -1,
            id: "mapbox/streets-v11",
            accessToken: "<insert your access token here>"
        }
    },
    MapTiler: {
        url: "https://api.maptiler.com/maps/{variant}/{z}/{x}/{y}{r}.{ext}?key={key}",
        options: {
            attribution:
                '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> <a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>',
            variant: "streets",
            ext: "png",
            key: "<insert your MapTiler Cloud API key here>",
            tileSize: 512,
            zoomOffset: -1,
            minZoom: 0,
            maxZoom: 21
        },
        variants: {
            Streets: "streets",
            Basic: "basic",
            Bright: "bright",
            Pastel: "pastel",
            Positron: "positron",
            Hybrid: {
                options: {
                    variant: "hybrid",
                    ext: "jpg"
                }
            },
            Toner: "toner",
            Topo: "topo",
            Voyager: "voyager"
        }
    },
    Stamen: {
        url: "https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}{r}.{ext}",
        options: {
            attribution:
                'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.',
            subdomains: "abcd",
            minZoom: 0,
            maxZoom: 20,
            variant: "toner",
            ext: "png"
        },
        variants: {
            Toner: "toner",
            TonerBackground: "toner-background",
            TonerHybrid: "toner-hybrid",
            TonerLines: "toner-lines",
            TonerLabels: "toner-labels",
            TonerLite: "toner-lite",
            Watercolor: {
                url: "https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}.{ext}",
                options: {
                    variant: "watercolor",
                    ext: "jpg",
                    minZoom: 1,
                    maxZoom: 16
                }
            },
            Terrain: {
                options: {
                    variant: "terrain",
                    minZoom: 0,
                    maxZoom: 18
                }
            },
            TerrainBackground: {
                options: {
                    variant: "terrain-background",
                    minZoom: 0,
                    maxZoom: 18
                }
            },
            TerrainLabels: {
                options: {
                    variant: "terrain-labels",
                    minZoom: 0,
                    maxZoom: 18
                }
            },
            TopOSMRelief: {
                url: "https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}.{ext}",
                options: {
                    variant: "toposm-color-relief",
                    ext: "jpg",
                    bounds: [
                        [22, -132],
                        [51, -56]
                    ]
                }
            },
            TopOSMFeatures: {
                options: {
                    variant: "toposm-features",
                    bounds: [
                        [22, -132],
                        [51, -56]
                    ],
                    opacity: 0.9
                }
            }
        }
    },
    TomTom: {
        url: "https://{s}.api.tomtom.com/map/1/tile/{variant}/{style}/{z}/{x}/{y}.{ext}?key={apikey}",
        options: {
            variant: "basic",
            maxZoom: 22,
            attribution:
                '<a href="https://tomtom.com" target="_blank">&copy;  1992 - ' +
                new Date().getFullYear() +
                " TomTom.</a> ",
            subdomains: "abcd",
            style: "main",
            ext: "png",
            apikey: "<insert your API key here>"
        },
        variants: {
            Basic: "basic",
            Hybrid: "hybrid",
            Labels: "labels"
        }
    },
    Esri: {
        url: "https://server.arcgisonline.com/ArcGIS/rest/services/{variant}/MapServer/tile/{z}/{y}/{x}",
        options: {
            variant: "World_Street_Map",
            attribution: "Tiles &copy; Esri"
        },
        variants: {
            WorldStreetMap: {
                options: {
                    attribution:
                        "{attribution.Esri} &mdash; " +
                        "Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012"
                }
            },
            DeLorme: {
                options: {
                    variant: "Specialty/DeLorme_World_Base_Map",
                    minZoom: 1,
                    maxZoom: 11,
                    attribution:
                        "{attribution.Esri} &mdash; Copyright: &copy;2012 DeLorme"
                }
            },
            WorldTopoMap: {
                options: {
                    variant: "World_Topo_Map",
                    attribution:
                        "{attribution.Esri} &mdash; " +
                        "Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community"
                }
            },
            WorldImagery: {
                options: {
                    variant: "World_Imagery",
                    attribution:
                        "{attribution.Esri} &mdash; " +
                        "Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community"
                }
            },
            WorldTerrain: {
                options: {
                    variant: "World_Terrain_Base",
                    maxZoom: 13,
                    attribution:
                        "{attribution.Esri} &mdash; " +
                        "Source: USGS, Esri, TANA, DeLorme, and NPS"
                }
            },
            WorldShadedRelief: {
                options: {
                    variant: "World_Shaded_Relief",
                    maxZoom: 13,
                    attribution: "{attribution.Esri} &mdash; Source: Esri"
                }
            },
            WorldPhysical: {
                options: {
                    variant: "World_Physical_Map",
                    maxZoom: 8,
                    attribution:
                        "{attribution.Esri} &mdash; Source: US National Park Service"
                }
            },
            OceanBasemap: {
                options: {
                    variant: "Ocean_Basemap",
                    maxZoom: 13,
                    attribution:
                        "{attribution.Esri} &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri"
                }
            },
            NatGeoWorldMap: {
                options: {
                    variant: "NatGeo_World_Map",
                    maxZoom: 16,
                    attribution:
                        "{attribution.Esri} &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC"
                }
            },
            WorldGrayCanvas: {
                options: {
                    variant: "Canvas/World_Light_Gray_Base",
                    maxZoom: 16,
                    attribution:
                        "{attribution.Esri} &mdash; Esri, DeLorme, NAVTEQ"
                }
            }
        }
    },
    OpenWeatherMap: {
        url: "http://{s}.tile.openweathermap.org/map/{variant}/{z}/{x}/{y}.png?appid={apiKey}",
        options: {
            maxZoom: 19,
            attribution:
                'Map data &copy; <a href="http://openweathermap.org">OpenWeatherMap</a>',
            apiKey: "<insert your api key here>",
            opacity: 0.5
        },
        variants: {
            Clouds: "clouds",
            CloudsClassic: "clouds_cls",
            Precipitation: "precipitation",
            PrecipitationClassic: "precipitation_cls",
            Rain: "rain",
            RainClassic: "rain_cls",
            Pressure: "pressure",
            PressureContour: "pressure_cntr",
            Wind: "wind",
            Temperature: "temp",
            Snow: "snow"
        }
    },
    HERE: {
        /*
         * HERE maps, formerly Nokia maps.
         * These basemaps are free, but you need an api id and app key. Please sign up at
         * https://developer.here.com/plans
         */
        url:
            "https://{s}.{base}.maps.api.here.com/maptile/2.1/" +
            "{type}/{mapID}/{variant}/{z}/{x}/{y}/{size}/{format}?" +
            "app_id={app_id}&app_code={app_code}&lg={language}",
        options: {
            attribution:
                "Map &copy; 1987-" +
                new Date().getFullYear() +
                ' <a href="http://developer.here.com">HERE</a>',
            subdomains: "1234",
            mapID: "newest",
            app_id: "<insert your app_id here>",
            app_code: "<insert your app_code here>",
            base: "base",
            variant: "normal.day",
            maxZoom: 20,
            type: "maptile",
            language: "eng",
            format: "png8",
            size: "256"
        },
        variants: {
            normalDay: "normal.day",
            normalDayCustom: "normal.day.custom",
            normalDayGrey: "normal.day.grey",
            normalDayMobile: "normal.day.mobile",
            normalDayGreyMobile: "normal.day.grey.mobile",
            normalDayTransit: "normal.day.transit",
            normalDayTransitMobile: "normal.day.transit.mobile",
            normalDayTraffic: {
                options: {
                    variant: "normal.traffic.day",
                    base: "traffic",
                    type: "traffictile"
                }
            },
            normalNight: "normal.night",
            normalNightMobile: "normal.night.mobile",
            normalNightGrey: "normal.night.grey",
            normalNightGreyMobile: "normal.night.grey.mobile",
            normalNightTransit: "normal.night.transit",
            normalNightTransitMobile: "normal.night.transit.mobile",
            reducedDay: "reduced.day",
            reducedNight: "reduced.night",
            basicMap: {
                options: {
                    type: "basetile"
                }
            },
            mapLabels: {
                options: {
                    type: "labeltile",
                    format: "png"
                }
            },
            trafficFlow: {
                options: {
                    base: "traffic",
                    type: "flowtile"
                }
            },
            carnavDayGrey: "carnav.day.grey",
            hybridDay: {
                options: {
                    base: "aerial",
                    variant: "hybrid.day"
                }
            },
            hybridDayMobile: {
                options: {
                    base: "aerial",
                    variant: "hybrid.day.mobile"
                }
            },
            hybridDayTransit: {
                options: {
                    base: "aerial",
                    variant: "hybrid.day.transit"
                }
            },
            hybridDayGrey: {
                options: {
                    base: "aerial",
                    variant: "hybrid.grey.day"
                }
            },
            hybridDayTraffic: {
                options: {
                    variant: "hybrid.traffic.day",
                    base: "traffic",
                    type: "traffictile"
                }
            },
            pedestrianDay: "pedestrian.day",
            pedestrianNight: "pedestrian.night",
            satelliteDay: {
                options: {
                    base: "aerial",
                    variant: "satellite.day"
                }
            },
            terrainDay: {
                options: {
                    base: "aerial",
                    variant: "terrain.day"
                }
            },
            terrainDayMobile: {
                options: {
                    base: "aerial",
                    variant: "terrain.day.mobile"
                }
            }
        }
    },
    HEREv3: {
        /*
         * HERE maps API Version 3.
         * These basemaps are free, but you need an API key. Please sign up at
         * https://developer.here.com/plans
         * Version 3 deprecates the app_id and app_code access in favor of apiKey
         *
         * Supported access methods as of 2019/12/21:
         * @see https://developer.here.com/faqs#access-control-1--how-do-you-control-access-to-here-location-services
         */
        url:
            "https://{s}.{base}.maps.ls.hereapi.com/maptile/2.1/" +
            "{type}/{mapID}/{variant}/{z}/{x}/{y}/{size}/{format}?" +
            "apiKey={apiKey}&lg={language}",
        options: {
            attribution:
                "Map &copy; 1987-" +
                new Date().getFullYear() +
                ' <a href="http://developer.here.com">HERE</a>',
            subdomains: "1234",
            mapID: "newest",
            apiKey: "<insert your apiKey here>",
            base: "base",
            variant: "normal.day",
            maxZoom: 20,
            type: "maptile",
            language: "eng",
            format: "png8",
            size: "256"
        },
        variants: {
            normalDay: "normal.day",
            normalDayCustom: "normal.day.custom",
            normalDayGrey: "normal.day.grey",
            normalDayMobile: "normal.day.mobile",
            normalDayGreyMobile: "normal.day.grey.mobile",
            normalDayTransit: "normal.day.transit",
            normalDayTransitMobile: "normal.day.transit.mobile",
            normalNight: "normal.night",
            normalNightMobile: "normal.night.mobile",
            normalNightGrey: "normal.night.grey",
            normalNightGreyMobile: "normal.night.grey.mobile",
            normalNightTransit: "normal.night.transit",
            normalNightTransitMobile: "normal.night.transit.mobile",
            reducedDay: "reduced.day",
            reducedNight: "reduced.night",
            basicMap: {
                options: {
                    type: "basetile"
                }
            },
            mapLabels: {
                options: {
                    type: "labeltile",
                    format: "png"
                }
            },
            trafficFlow: {
                options: {
                    base: "traffic",
                    type: "flowtile"
                }
            },
            carnavDayGrey: "carnav.day.grey",
            hybridDay: {
                options: {
                    base: "aerial",
                    variant: "hybrid.day"
                }
            },
            hybridDayMobile: {
                options: {
                    base: "aerial",
                    variant: "hybrid.day.mobile"
                }
            },
            hybridDayTransit: {
                options: {
                    base: "aerial",
                    variant: "hybrid.day.transit"
                }
            },
            hybridDayGrey: {
                options: {
                    base: "aerial",
                    variant: "hybrid.grey.day"
                }
            },
            pedestrianDay: "pedestrian.day",
            pedestrianNight: "pedestrian.night",
            satelliteDay: {
                options: {
                    base: "aerial",
                    variant: "satellite.day"
                }
            },
            terrainDay: {
                options: {
                    base: "aerial",
                    variant: "terrain.day"
                }
            },
            terrainDayMobile: {
                options: {
                    base: "aerial",
                    variant: "terrain.day.mobile"
                }
            }
        }
    },
    FreeMapSK: {
        url: "https://{s}.freemap.sk/T/{z}/{x}/{y}.jpeg",
        options: {
            minZoom: 8,
            maxZoom: 16,
            subdomains: "abcd",
            bounds: [
                [47.204642, 15.996093],
                [49.830896, 22.576904]
            ],
            attribution:
                '{attribution.OpenStreetMap}, vizualization CC-By-SA 2.0 <a href="http://freemap.sk">Freemap.sk</a>'
        }
    },
    MtbMap: {
        url: "http://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png",
        options: {
            attribution: "{attribution.OpenStreetMap} &amp; USGS"
        }
    },
    CartoDB: {
        url: "https://{s}.basemaps.cartocdn.com/{variant}/{z}/{x}/{y}{r}.png",
        options: {
            attribution:
                '{attribution.OpenStreetMap} &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: "abcd",
            maxZoom: 19,
            variant: "light_all"
        },
        variants: {
            Positron: "light_all",
            PositronNoLabels: "light_nolabels",
            PositronOnlyLabels: "light_only_labels",
            DarkMatter: "dark_all",
            DarkMatterNoLabels: "dark_nolabels",
            DarkMatterOnlyLabels: "dark_only_labels",
            Voyager: "rastertiles/voyager",
            VoyagerNoLabels: "rastertiles/voyager_nolabels",
            VoyagerOnlyLabels: "rastertiles/voyager_only_labels",
            VoyagerLabelsUnder: "rastertiles/voyager_labels_under"
        }
    },
    HikeBike: {
        url: "https://tiles.wmflabs.org/{variant}/{z}/{x}/{y}.png",
        options: {
            maxZoom: 19,
            attribution: "{attribution.OpenStreetMap}",
            variant: "hikebike"
        },
        variants: {
            HikeBike: {},
            HillShading: {
                options: {
                    maxZoom: 15,
                    variant: "hillshading"
                }
            }
        }
    },
    BasemapAT: {
        url: "https://maps{s}.wien.gv.at/basemap/{variant}/{type}/google3857/{z}/{y}/{x}.{format}",
        options: {
            maxZoom: 19,
            attribution:
                'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
            subdomains: ["", "1", "2", "3", "4"],
            type: "normal",
            format: "png",
            bounds: [
                [46.35877, 8.782379],
                [49.037872, 17.189532]
            ],
            variant: "geolandbasemap"
        },
        variants: {
            basemap: {
                options: {
                    maxZoom: 20, // currently only in Vienna
                    variant: "geolandbasemap"
                }
            },
            grau: "bmapgrau",
            overlay: "bmapoverlay",
            terrain: {
                options: {
                    variant: "bmapgelaende",
                    type: "grau",
                    format: "jpeg"
                }
            },
            surface: {
                options: {
                    variant: "bmapoberflaeche",
                    type: "grau",
                    format: "jpeg"
                }
            },
            highdpi: {
                options: {
                    variant: "bmaphidpi",
                    format: "jpeg"
                }
            },
            orthofoto: {
                options: {
                    maxZoom: 20, // currently only in Vienna
                    variant: "bmaporthofoto30cm",
                    format: "jpeg"
                }
            }
        }
    },
    nlmaps: {
        url: "https://geodata.nationaalgeoregister.nl/tiles/service/wmts/{variant}/EPSG:3857/{z}/{x}/{y}.png",
        options: {
            minZoom: 6,
            maxZoom: 19,
            bounds: [
                [50.5, 3.25],
                [54, 7.6]
            ],
            attribution:
                'Kaartgegevens &copy; <a href="kadaster.nl">Kadaster</a>'
        },
        variants: {
            standaard: "brtachtergrondkaart",
            pastel: "brtachtergrondkaartpastel",
            grijs: "brtachtergrondkaartgrijs",
            luchtfoto: {
                url: "https://geodata.nationaalgeoregister.nl/luchtfoto/rgb/wmts/2018_ortho25/EPSG:3857/{z}/{x}/{y}.png"
            }
        }
    },
    NASAGIBS: {
        url: "https://map1.vis.earthdata.nasa.gov/wmts-webmerc/{variant}/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}",
        options: {
            attribution:
                "Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System " +
                '(<a href="https://earthdata.nasa.gov">ESDIS</a>) with funding provided by NASA/HQ.',
            bounds: [
                [-85.0511287776, -179.999999975],
                [85.0511287776, 179.999999975]
            ],
            minZoom: 1,
            maxZoom: 9,
            format: "jpg",
            time: "",
            tilematrixset: "GoogleMapsCompatible_Level"
        },
        variants: {
            ModisTerraTrueColorCR: "MODIS_Terra_CorrectedReflectance_TrueColor",
            ModisTerraBands367CR: "MODIS_Terra_CorrectedReflectance_Bands367",
            ViirsEarthAtNight2012: {
                options: {
                    variant: "VIIRS_CityLights_2012",
                    maxZoom: 8
                }
            },
            ModisTerraLSTDay: {
                options: {
                    variant: "MODIS_Terra_Land_Surface_Temp_Day",
                    format: "png",
                    maxZoom: 7,
                    opacity: 0.75
                }
            },
            ModisTerraSnowCover: {
                options: {
                    variant: "MODIS_Terra_Snow_Cover",
                    format: "png",
                    maxZoom: 8,
                    opacity: 0.75
                }
            },
            ModisTerraAOD: {
                options: {
                    variant: "MODIS_Terra_Aerosol",
                    format: "png",
                    maxZoom: 6,
                    opacity: 0.75
                }
            },
            ModisTerraChlorophyll: {
                options: {
                    variant: "MODIS_Terra_Chlorophyll_A",
                    format: "png",
                    maxZoom: 7,
                    opacity: 0.75
                }
            }
        }
    },
    NLS: {
        // NLS maps are copyright National library of Scotland.
        // http://maps.nls.uk/projects/api/index.html
        // Please contact NLS for anything other than non-commercial low volume usage
        //
        // Map sources: Ordnance Survey 1:1m to 1:63K, 1920s-1940s
        //   z0-9  - 1:1m
        //  z10-11 - quarter inch (1:253440)
        //  z12-18 - one inch (1:63360)
        url: "https://nls-{s}.tileserver.com/nls/{z}/{x}/{y}.jpg",
        options: {
            attribution:
                '<a href="http://geo.nls.uk/maps/">National Library of Scotland Historic Maps</a>',
            bounds: [
                [49.6, -12],
                [61.7, 3]
            ],
            minZoom: 1,
            maxZoom: 18,
            subdomains: "0123"
        }
    },
    JusticeMap: {
        // Justice Map (http://www.justicemap.org/)
        // Visualize race and income data for your community, county and country.
        // Includes tools for data journalists, bloggers and community activists.
        url: "http://www.justicemap.org/tile/{size}/{variant}/{z}/{x}/{y}.png",
        options: {
            attribution:
                '<a href="http://www.justicemap.org/terms.php">Justice Map</a>',
            // one of 'county', 'tract', 'block'
            size: "county",
            // Bounds for USA, including Alaska and Hawaii
            bounds: [
                [14, -180],
                [72, -56]
            ]
        },
        variants: {
            income: "income",
            americanIndian: "indian",
            asian: "asian",
            black: "black",
            hispanic: "hispanic",
            multi: "multi",
            nonWhite: "nonwhite",
            white: "white",
            plurality: "plural"
        }
    },
    GeoportailFrance: {
        url: "https://wxs.ign.fr/{apikey}/geoportail/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER={variant}&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}",
        options: {
            attribution:
                '<a target="_blank" href="https://www.geoportail.gouv.fr/">Geoportail France</a>',
            bounds: [
                [-75, -180],
                [81, 180]
            ],
            minZoom: 2,
            maxZoom: 18,
            // Get your own geoportail apikey here : http://professionnels.ign.fr/ign/contrats/
            // NB : 'choisirgeoportail' is a demonstration key that comes with no guarantee
            apikey: "choisirgeoportail",
            format: "image/png",
            style: "normal",
            variant: "GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2"
        },
        variants: {
            plan: "GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2",
            parcels: {
                options: {
                    variant: "CADASTRALPARCELS.PARCELLAIRE_EXPRESS",
                    style: "PCI vecteur",
                    maxZoom: 20
                }
            },
            orthos: {
                options: {
                    maxZoom: 19,
                    format: "image/jpeg",
                    variant: "ORTHOIMAGERY.ORTHOPHOTOS"
                }
            }
        }
    },
    OneMapSG: {
        url: "https://maps-{s}.onemap.sg/v3/{variant}/{z}/{x}/{y}.png",
        options: {
            variant: "Default",
            minZoom: 11,
            maxZoom: 18,
            bounds: [
                [1.56073, 104.11475],
                [1.16, 103.502]
            ],
            attribution:
                '<img src="https://docs.onemap.sg/maps/images/oneMap64-01.png" style="height:20px;width:20px;"/> New OneMap | Map data &copy; contributors, <a href="http://SLA.gov.sg">Singapore Land Authority</a>'
        },
        variants: {
            Default: "Default",
            Night: "Night",
            Original: "Original",
            Grey: "Grey",
            LandLot: "LandLot"
        }
    },
    USGS: {
        url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}",
        options: {
            maxZoom: 20,
            attribution:
                'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>'
        },
        variants: {
            USTopo: {},
            USImagery: {
                url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}"
            },
            USImageryTopo: {
                url: "https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}"
            }
        }
    },
    WaymarkedTrails: {
        url: "https://tile.waymarkedtrails.org/{variant}/{z}/{x}/{y}.png",
        options: {
            maxZoom: 18,
            attribution:
                'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://waymarkedtrails.org">waymarkedtrails.org</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        },
        variants: {
            hiking: "hiking",
            cycling: "cycling",
            mtb: "mtb",
            slopes: "slopes",
            riding: "riding",
            skating: "skating"
        }
    },
    OpenAIP: {
        url: "http://{s}.tile.maps.openaip.net/geowebcache/service/tms/1.0.0/openaip_basemap@EPSG%3A900913@png/{z}/{x}/{y}.{ext}",
        options: {
            attribution:
                '<a href="https://www.openaip.net/">openAIP Data</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-NC-SA</a>)',
            ext: "png",
            minZoom: 4,
            maxZoom: 14,
            tms: true,
            detectRetina: true,
            subdomains: "12"
        }
    },
    OpenSnowMap: {
        url: "https://tiles.opensnowmap.org/{variant}/{z}/{x}/{y}.png",
        options: {
            minZoom: 9,
            maxZoom: 18,
            attribution:
                'Map data: {attribution.OpenStreetMap} & ODbL, &copy; <a href="https://www.opensnowmap.org/iframes/data.html">www.opensnowmap.org</a> <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'
        },
        variants: {
            pistes: "pistes"
        }
    }
};



================================================
FILE: src/utils/hotline.ts
================================================
//@ts-nocheck

export function HotlinePlugin(L) {
    if (L.Hotline) {
        return L;
    }
    var Hotline = function (canvas) {
        if (!(this instanceof Hotline)) {
            return new Hotline(canvas);
        }
        var defaultPalette = {
            0: "green",
            0.5: "yellow",
            1: "red"
        };
        this._canvas = canvas =
            typeof canvas === "string"
                ? document.getElementById(canvas)
                : canvas;
        this._ctx = canvas.getContext("2d");
        this._width = canvas.width;
        this._height = canvas.height;
        this._weight = 5;
        this._outlineWidth = 1;
        this._outlineColor = "black";
        this._min = 0;
        this._max = 1;
        this._data = [];
        this.palette(defaultPalette);
    };
    Hotline.prototype = {
        width: function (width) {
            this._width = width;
            return this;
        },
        height: function (height) {
            this._height = height;
            return this;
        },
        weight: function (weight) {
            this._weight = weight;
            return this;
        },
        outlineWidth: function (outlineWidth) {
            this._outlineWidth = outlineWidth;
            return this;
        },
        outlineColor: function (outlineColor) {
            this._outlineColor = outlineColor;
            return this;
        },
        palette: function (palette) {
            var canvas = document.createElement("canvas"),
                ctx = canvas.getContext("2d"),
                gradient = ctx.createLinearGradient(0, 0, 0, 256);
            canvas.width = 1;
            canvas.height = 256;
            for (var i in palette) {
                gradient.addColorStop(i, palette[i]);
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1, 256);
            this._palette = ctx.getImageData(0, 0, 1, 256).data;
            return this;
        },
        min: function (min) {
            this._min = min;
            return this;
        },
        max: function (max) {
            this._max = max;
            return this;
        },
        data: function (data) {
            this._data = data;
            return this;
        },
        add: function (path) {
            this._data.push(path);
            return this;
        },
        draw: function () {
            var ctx = this._ctx;
            ctx.globalCompositeOperation = "source-over";
            ctx.lineCap = "round";
            this._drawOutline(ctx);
            this._drawHotline(ctx);
            return this;
        },
        getRGBForValue: function (value) {
            var valueRelative = Math.min(
                Math.max((value - this._min) / (this._max - this._min), 0),
                0.999
            );
            var paletteIndex = Math.floor(valueRelative * 256) * 4;
            return [
                this._palette[paletteIndex],
                this._palette[paletteIndex + 1],
                this._palette[paletteIndex + 2]
            ];
        },
        _drawOutline: function (ctx) {
            var i, j, dataLength, path, pathLength, pointStart, pointEnd;
            if (this._outlineWidth) {
                for (
                    i = 0, dataLength = this._data.length;
                    i < dataLength;
                    i++
                ) {
                    path = this._data[i];
                    ctx.lineWidth = this._weight + 2 * this._outlineWidth;
                    for (j = 1, pathLength = path.length; j < pathLength; j++) {
                        pointStart = path[j - 1];
                        pointEnd = path[j];
                        ctx.strokeStyle = this._outlineColor;
                        ctx.beginPath();
                        ctx.moveTo(pointStart.x, pointStart.y);
                        ctx.lineTo(pointEnd.x, pointEnd.y);
                        ctx.stroke();
                    }
                }
            }
        },
        _drawHotline: function (ctx) {
            var i,
                j,
                dataLength,
                path,
                pathLength,
                pointStart,
                pointEnd,
                gradient,
                gradientStartRGB,
                gradientEndRGB;
            ctx.lineWidth = this._weight;
            for (i = 0, dataLength = this._data.length; i < dataLength; i++) {
                path = this._data[i];
                for (j = 1, pathLength = path.length; j < pathLength; j++) {
                    pointStart = path[j - 1];
                    pointEnd = path[j];
                    gradient = ctx.createLinearGradient(
                        pointStart.x,
                        pointStart.y,
                        pointEnd.x,
                        pointEnd.y
                    );
                    gradientStartRGB = this.getRGBForValue(pointStart.z);
                    gradientEndRGB = this.getRGBForValue(pointEnd.z);
                    gradient.addColorStop(
                        0,
                        "rgb(" + gradientStartRGB.join(",") + ")"
                    );
                    gradient.addColorStop(
                        1,
                        "rgb(" + gradientEndRGB.join(",") + ")"
                    );
                    ctx.strokeStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(pointStart.x, pointStart.y);
                    ctx.lineTo(pointEnd.x, pointEnd.y);
                    ctx.stroke();
                }
            }
        }
    };
    var Renderer = L.Canvas.extend({
        _initContainer: function () {
            L.Canvas.prototype._initContainer.call(this);
            this._hotline = new Hotline(this._container);
        },
        _update: function () {
            L.Canvas.prototype._update.call(this);
            this._hotline.width(this._container.width);
            this._hotline.height(this._container.height);
        },
        _updatePoly: function (layer) {
            if (!this._drawing) {
                return;
            }
            var parts = layer._parts;
            if (!parts.length) {
                return;
            }
            this._updateOptions(layer);
            this._hotline.data(parts).draw();
        },
        _updateOptions: function (layer) {
            if (layer.options.min != null) {
                this._hotline.min(layer.options.min);
            }
            if (layer.options.max != null) {
                this._hotline.max(layer.options.max);
            }
            if (layer.options.weight != null) {
                this._hotline.weight(layer.options.weight);
            }
            if (layer.options.outlineWidth != null) {
                this._hotline.outlineWidth(layer.options.outlineWidth);
            }
            if (layer.options.outlineColor != null) {
                this._hotline.outlineColor(layer.options.outlineColor);
            }
            if (layer.options.palette) {
                this._hotline.palette(layer.options.palette);
            }
        }
    });
    var renderer = function (options) {
        return L.Browser.canvas ? new Renderer(options) : null;
    };
    var Util = {
        clipSegment: function (a, b, bounds, useLastCode, round) {
            var codeA = useLastCode
                    ? this._lastCode
                    : L.LineUtil._getBitCode(a, bounds),
                codeB = L.LineUtil._getBitCode(b, bounds),
                codeOut,
                p,
                newCode;
            this._lastCode = codeB;
            while (true) {
                if (!(codeA | codeB)) {
                    return [a, b];
                } else if (codeA & codeB) {
                    return false;
                } else {
                    codeOut = codeA || codeB;
                    p = L.LineUtil._getEdgeIntersection(
                        a,
                        b,
                        codeOut,
                        bounds,
                        round
                    );
                    newCode = L.LineUtil._getBitCode(p, bounds);
                    if (codeOut === codeA) {
                        p.z = a.z;
                        a = p;
                        codeA = newCode;
                    } else {
                        p.z = b.z;
                        b = p;
                        codeB = newCode;
                    }
                }
            }
        }
    };
    L.Hotline = L.Polyline.extend({
        statics: {
            Renderer: Renderer,
            renderer: renderer
        },
        options: {
            renderer: renderer(),
            min: 0,
            max: 1,
            palette: {
                0: "green",
                0.5: "yellow",
                1: "red"
            },
            weight: 5,
            outlineColor: "black",
            outlineWidth: 1
        },
        getRGBForValue: function (value) {
            return this._renderer._hotline.getRGBForValue(value);
        },
        _projectLatlngs: function (latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof L.LatLng,
                len = latlngs.length,
                i,
                ring;
            if (flat) {
                ring = [];
                for (i = 0; i < len; i++) {
                    ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
                    ring[i].z = latlngs[i].alt;
                    projectedBounds.extend(ring[i]);
                }
                result.push(ring);
            } else {
                for (i = 0; i < len; i++) {
                    this._projectLatlngs(latlngs[i], result, projectedBounds);
                }
            }
        },
        _clipPoints: function () {
            if (this.options.noClip) {
                this._parts = this._rings;
                return;
            }
            this._parts = [];
            var parts = this._parts,
                bounds = this._renderer._bounds,
                i,
                j,
                k,
                len,
                len2,
                segment,
                points;
            for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
                points = this._rings[i];
                for (j = 0, len2 = points.length; j < len2 - 1; j++) {
                    segment = Util.clipSegment(
                        points[j],
                        points[j + 1],
                        bounds,
                        j,
                        true
                    );
                    if (!segment) {
                        continue;
                    }
                    parts[k] = parts[k] || [];
                    parts[k].push(segment[0]);
                    if (segment[1] !== points[j + 1] || j === len2 - 2) {
                        parts[k].push(segment[1]);
                        k++;
                    }
                }
            }
        },
        _clickTolerance: function () {
            return (
                this.options.weight / 2 +
                this.options.outlineWidth +
                (L.Browser.touch ? 10 : 0)
            );
        }
    });
    L.hotline = function (latlngs, options) {
        return new L.Hotline(latlngs, options);
    };
    return L;
}



================================================
FILE: src/utils/icons.ts
================================================
import { fas } from "@fortawesome/free-solid-svg-icons";

import {
    findIconDefinition,
    icon,
    library,
    IconParams,
} from "@fortawesome/fontawesome-svg-core";
import type {
    IconDefinition,
    IconName
} from "@fortawesome/fontawesome-svg-core";
import { Icon } from "../types";

library.add(fas);

export const DESCRIPTION_ICON = "obsidian-leaflet-plugin-icon-description";
export const DESCRIPTION_ICON_SVG = icon(getIcon("info-circle")).html[0];
export const BULLSEYE = "obsidian-leaflet-plugin-icon-bullseye";
export const BULLSEYE_ICON_SVG = icon(getIcon("bullseye")).html[0];
export const VIEW_ICON = "obsidian-leaflet-plugin-icon-map";
export const VIEW_ICON_SVG = icon(getIcon("map-marked-alt")).html[0];

export const iconNames = Object.values(fas).map((i) => i.iconName);

export function getIcon(iconName: string): IconDefinition {
    if (!iconName) return null;
    return findIconDefinition({
        iconName: iconName as IconName,
        prefix: "fas"
    });
}

import {
    faEyeSlash,
    faHeart,
    faMagic,
    faDeaf,
    faSpider,
    faHandsHelping,
    faGhost,
    faSlash,
    faWalking,
    faMountain,
    faSkullCrossbones,
    faBed,
    faBolt,
    faLink,
    faDizzy,
    faSkull
} from "@fortawesome/free-solid-svg-icons";

import { layer } from "@fortawesome/fontawesome-svg-core";
const paralyzed = layer((push) => {
    push(icon(faWalking));
    push(icon(faSlash));
}).node[0];
export const StatusMap: Map<string, Element> = new Map([
    [
        "Blinded",
        icon(faEyeSlash, { attributes: { stroke: "coral", "stroke-width": 1 } })
            .node[0]
    ],
    [
        "Charmed",
        icon(faHeart, { attributes: { stroke: "coral", "stroke-width": 1 } })
            .node[0]
    ],
    ["Concentrating", icon(faMagic).node[0]],
    ["Deafened", icon(faDeaf).node[0]],
    ["Frightened", icon(faSpider).node[0]],
    ["Grappled", icon(faHandsHelping).node[0]],
    ["Incapacitated", icon(faSkull).node[0]],
    ["Invisible", icon(faGhost).node[0]],
    ["Paralyzed", paralyzed],
    ["Petrified", icon(faMountain).node[0]],
    ["Poisoned", icon(faSkullCrossbones).node[0]],
    ["Prone", icon(faBed).node[0]],
    ["Reacted", icon(faBolt).node[0]],
    ["Restrained", icon(faLink).node[0]],
    ["Stunned", icon(faDizzy).node[0]],
    ["Unconscious", icon(faSkull).node[0]]
]);

interface InternalMarkerIcon {
    html: string;
    node: Element;
}

export function getMarkerIcon(
    marker: Icon,
    params?: IconParams
): InternalMarkerIcon {
    if (!marker) return null;

    if (marker.isImage) {
        let element = new Image();
        element.src = marker.imageUrl;

        const ret = {
            html: element.outerHTML,
            node: element
        };

        return ret;
    }

    const i = icon(getIcon(marker.iconName), params);
    return {
        html: i.html[0],
        node: i.node[0]
    };
}

export { fas, icon, findIconDefinition, IconDefinition, IconName };



================================================
FILE: src/utils/index.ts
================================================
export * from "./icons";
export * from "./utils";
export * from "./constants";
export * from "./units";



================================================
FILE: src/utils/leaflet-import.ts
================================================
import { MAP_OVERLAY_STROKE_OPACITY, MAP_OVERLAY_STROKE_WIDTH } from ".";
import type * as Leaflet from "leaflet";

declare global {
    interface Window {
        [LeafletSymbol]: typeof Leaflet;
    }
}

export const LeafletSymbol = "OBSIDIAN_LEAFLET_PLUGIN";

const WindowL = window.L;
if (!window.L) {
    require("leaflet");
}

window[LeafletSymbol] = window.L;
window[LeafletSymbol].Circle.mergeOptions({
    weight: MAP_OVERLAY_STROKE_WIDTH,
    opacity: MAP_OVERLAY_STROKE_OPACITY
});

require("leaflet-fullscreen");
require("leaflet-hotline");

window.L = WindowL;



================================================
FILE: src/utils/units.ts
================================================
import t from "src/l10n/locale";

export const UNIT_NAME_ALIASES = {
    meter: t("meters"),
    meters: t("meters"),
    metre: t("meters"),
    metres: t("meters"),
    m: t("meters"),

    petameter: t("petameters"),
    petametre: t("petameters"),
    petameters: t("petameters"),
    petametres: t("petameters"),
    Pm: t("petameters"),

    terameter: t("terameters"),
    terametre: t("terameters"),
    terameters: t("terameters"),
    terametres: t("terameters"),
    Tm: t("terameters"),

    gigameter: t("gigameters"),
    gigametre: t("gigameters"),
    gigameters: t("gigameters"),
    gigametres: t("gigameters"),
    Gm: t("gigameters"),

    megameter: t("megameters"),
    megametre: t("megameters"),
    megameters: t("megameters"),
    megametres: t("megameters"),
    Mm: t("megameters"),

    kilometer: t("kilometers"),
    kilometre: t("kilometers"),
    kilometers: t("kilometers"),
    kilometres: t("kilometers"),
    km: t("kilometers"),

    hectometer: t("hectometers"),
    hectometre: t("hectometers"),
    hectometers: t("hectometers"),
    hectometres: t("hectometers"),
    hm: t("hectometers"),

    decameter: t("decameters"),
    decametre: t("decameters"),
    decameters: t("decameters"),
    decametres: t("decameters"),
    dam: t("decameters"),

    decimeter: t("decimeters"),
    decimetre: t("decimeters"),
    decimeters: t("decimeters"),
    decimetres: t("decimeters"),
    dm: t("decimeters"),

    centimeter: t("centimeters"),
    centimetre: t("centimeters"),
    centimeters: t("centimeters"),
    centimetres: t("centimeters"),
    cm: t("centimeters"),

    millimeter: t("millimeters"),
    millimetre: t("millimeters"),
    millimeters: t("millimeters"),
    millimetres: t("millimeters"),
    mm: t("millimeters"),

    micrometer: t("micrometers"),
    micrometre: t("micrometers"),
    micrometers: t("micrometers"),
    micrometres: t("micrometers"),
    μm: t("micrometers"),

    nanometer: t("nanometers"),
    nanometre: t("nanometers"),
    nanometers: t("nanometers"),
    nanometres: t("nanometers"),
    nm: t("nanometers"),

    picometer: t("picometers"),
    picometre: t("picometers"),
    picometers: t("picometers"),
    picometres: t("picometers"),
    pm: t("picometers"),

    femtometer: t("femtometers"),
    femtometre: t("femtometers"),
    femtometers: t("femtometers"),
    femtometres: t("femtometers"),
    fm: t("femtometers"),

    foot: t("feet"),
    feet: t("feet"),
    ft: t("feet"),

    inch: t("inches"),
    inches: t("inches"),
    in: t("inches"),

    yard: t("yards"),
    yards: t("yards"),
    yd: t("yards"),

    mile: t("miles"),
    miles: t("miles"),
    mi: t("miles"),

    "nautical mile": t("nautical miles"),
    "nautical miles": t("nautical miles"),
    M: t("nautical miles"),
    NM: t("nautical miles"),
    nmi: t("nautical miles")
};
export const UNIT_SYSTEM = {
    meter: "metric",
    meters: "metric",
    metre: "metric",
    metres: "metric",
    m: "metric",

    petameter: "metric",
    petametre: "metric",
    petameters: "metric",
    petametres: "metric",
    Pm: "metric",

    terameter: "metric",
    terametre: "metric",
    terameters: "metric",
    terametres: "metric",
    Tm: "metric",

    gigameter: "metric",
    gigametre: "metric",
    gigameters: "metric",
    gigametres: "metric",
    Gm: "metric",

    megameter: "metric",
    megametre: "metric",
    megameters: "metric",
    megametres: "metric",
    Mm: "metric",

    kilometer: "metric",
    kilometre: "metric",
    kilometers: "metric",
    kilometres: "metric",
    km: "metric",

    hectometer: "metric",
    hectometre: "metric",
    hectometers: "metric",
    hectometres: "metric",
    hm: "metric",

    decameter: "metric",
    decametre: "metric",
    decameters: "metric",
    decametres: "metric",
    dam: "metric",

    decimeter: "metric",
    decimetre: "metric",
    decimeters: "metric",
    decimetres: "metric",
    dm: "metric",

    centimeter: "metric",
    centimetre: "metric",
    centimeters: "metric",
    centimetres: "metric",
    cm: "metric",

    millimeter: "metric",
    millimetre: "metric",
    millimeters: "metric",
    millimetres: "metric",
    mm: "metric",

    micrometer: "metric",
    micrometre: "metric",
    micrometers: "metric",
    micrometres: "metric",
    μm: "metric",

    nanometer: "metric",
    nanometre: "metric",
    nanometers: "metric",
    nanometres: "metric",
    nm: "metric",

    picometer: "metric",
    picometre: "metric",
    picometers: "metric",
    picometres: "metric",
    pm: "metric",

    femtometer: "metric",
    femtometre: "metric",
    femtometers: "metric",
    femtometres: "metric",
    fm: "metric",

    foot: "imperial",
    feet: "imperial",
    ft: "imperial",

    inch: "imperial",
    inches: "imperial",
    in: "imperial",

    yard: "imperial",
    yards: "imperial",
    yd: "imperial",

    mile: "imperial",
    miles: "imperial",
    mi: "imperial",

    "nautical mile": "imperial",
    "nautical miles": "imperial",
    M: "imperial",
    NM: "imperial",
    nmi: "imperial"
};



================================================
FILE: src/utils/utils.ts
================================================
import {
    App,
    Notice,
    parseYaml,
    setIcon,
    TextComponent,
    TFile
} from "obsidian";
import Color from "color";

import { BaseMapType, BlockParameters } from "../types";
import { LAT_LONG_DECIMALS } from "./constants";
import { DESCRIPTION_ICON } from ".";
import t from "src/l10n/locale";

const locale = window.moment.locale;

export function formatNumber(number: number, digits: number) {
    return new Intl.NumberFormat(locale(), {
        style: "decimal",
        maximumFractionDigits: digits
    }).format(number);
}

export function formatLatLng(latlng: L.LatLng) {
    return {
        lat: formatNumber(latlng.lat, LAT_LONG_DECIMALS),
        lng: formatNumber(latlng.lng, LAT_LONG_DECIMALS)
    };
}

export async function copyToClipboard(loc: L.LatLng): Promise<void> {
    await new Promise<void>((resolve, reject) => {
        navigator.clipboard
            .writeText(
                `${formatNumber(loc.lat, LAT_LONG_DECIMALS)}, ${formatNumber(
                    loc.lng,
                    LAT_LONG_DECIMALS
                )}`
            )
            .then(() => {
                new Notice(t("Coordinates copied to clipboard."));
                resolve();
            })
            .catch(() => {
                new Notice(
                    t(
                        "There was an error trying to copy coordinates to clipboard."
                    )
                );
                reject();
            });
    });
}

export function renderError(el: HTMLElement, error: string): void {
    let pre = createEl("pre", { attr: { id: "leaflet-error" } });
    pre.setText(`\`\`\`leaflet
${t("There was an error rendering the map")}:

${error}
\`\`\``);
    el.replaceWith(pre);
}

export function log(verbose: boolean, id: string, message: string) {
    if (!verbose) return;
    console.log(`Obsidian Leaflet Map ${id}: ${message}`);
}

export function getHex(color: string): string {
    return Color(color).hex();
}

export function getImageDimensions(url: string): Promise<any> {
    return new Promise(function (resolved, reject) {
        var i = new Image();
        i.onload = function () {
            const { width, height } = i;
            i.detach();
            resolved({ w: width, h: height });
        };
        i.onerror = () => {
            new Notice(t("There was an issue getting the image dimensions."));
            reject();
        };

        i.src = url;
    });
}

export function getId() {
    return "ID_xyxyxyxyxyxy".replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0,
            v = c == "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

export { compare as compareVersions } from "compare-versions";

export const setValidationError = function (
    textInput: TextComponent,
    message?: string
) {
    textInput.inputEl.addClass("is-invalid");
    if (message) {
        textInput.inputEl.parentElement.addClasses([
            "has-invalid-message",
            "unset-align-items"
        ]);
        textInput.inputEl.parentElement.parentElement.addClass(
            ".unset-align-items"
        );
        let mDiv = textInput.inputEl.parentElement.querySelector(
            ".invalid-feedback"
        ) as HTMLDivElement;

        if (!mDiv) {
            mDiv = createDiv({ cls: "invalid-feedback" });
        }
        mDiv.innerText = message;
        textInput.inputEl.parentNode.appendChild(mDiv);
    }
};
export const removeValidationError = function (textInput: TextComponent) {
    textInput.inputEl.removeClass("is-invalid");
    textInput.inputEl.parentElement.removeClasses([
        "has-invalid-message",
        "unset-align-items"
    ]);
    textInput.inputEl.parentElement.parentElement.removeClass(
        ".unset-align-items"
    );

    if (textInput.inputEl.parentElement.children[1]) {
        textInput.inputEl.parentElement.removeChild(
            textInput.inputEl.parentElement.children[1]
        );
    }
};

export function getHeight(el: HTMLElement, height: string): string {
    try {
        if (!/\d+(px|%)/.test(height))
            throw new Error(t("Unparseable height provided."));
        if (/\d+%/.test(height)) {
            const element = el.closest(".markdown-preview-view");

            let [, perc] = height.match(/(\d+)%/);

            let computedStyle = getComputedStyle(element);

            let clHeight = element.clientHeight; // height with padding

            clHeight -=
                parseFloat(computedStyle.paddingTop) +
                parseFloat(computedStyle.paddingBottom);

            height = `${(clHeight * Number(perc)) / 100}px`;
        }
    } catch (e) {
        new Notice(
            t("There was a problem with the provided height. Using 500px.")
        );
        height = "500px";
    } finally {
        return height;
    }
}

export async function getBlob(url: string, app: App) {
    let response, blob: Blob, extension: string, alias: string;
    url = decodeURIComponent(url);
    try {
        if (/https?:/.test(url)) {
            //url
            response = await fetch(url);
            blob = await response.blob();
        } else if (/obsidian:\/\/open/.test(url)) {
            //obsidian link
            let [, filePath] = url.match(/\?vault=[\s\S]+?&file=([\s\S]+)/);

            filePath = decodeURIComponent(filePath);
            let file = app.vault.getAbstractFileByPath(filePath);
            if (!file) throw new Error();
            extension = (file as TFile).extension;
            let buffer = await app.vault.readBinary(file as TFile);
            blob = new Blob([new Uint8Array(buffer)]);
        } else {
            //file exists on disk;
            let file = app.metadataCache.getFirstLinkpathDest(
                parseLink(url).split("|").shift(),
                ""
            );
            if (!file) throw new Error();

            extension = file.extension;

            let buffer = await app.vault.readBinary(file);
            blob = new Blob([new Uint8Array(buffer)]);
            alias = (
                url.includes("|") ? url.split("|").pop() : file.basename
            ).replace(/(\[|\])/g, "");
        }
    } catch (e) {
        console.error(e);
    }
    return { blob, id: encodeURIComponent(url), alias, extension };
}

export function parseLink(link: string) {
    if (!link) return undefined;
    if (/(?:\[.*\]\(|\[\[)(.+)(?:\)|\]\])/.test(link)) {
        const [_, path] = link.match(/(?:\[.*\]\(|\[\[)(.+)(?:\)|\]\])/) ?? [];
        return path;
    }
    return link?.replace(/(\[|\])/g, "");
}

type MarkerType =
    | "marker"
    | "markerFile"
    | "markerFolder"
    | "markerTag"
    | "commandMarker"
    | "filterTag";

/** Parses source block and returns an object of block parameters
 * 1. First, it tries to parse the source as YAML. If the YAML parser fails, it tries to parse it manually.
 * 2. Next, it pulls out multiple images defined in the source. If there are multiple image tags, YAML will return only the last,
 * so it detects that to return them all correctly.
 * 3. Next, it pulls out markers defined in the source block. This is clunky to support previous version's syntax, but works.
 */
export function getParamsFromSource(source: string): BlockParameters {
    let params: BlockParameters = {};

    /** Pull out links */

    const links = source.match(/(?:\[.*\]\(|\[\[)[^\[\]]*(?:\)|\]\])/g) ?? [];
    for (let link of links) {
        source = source.replace(
            link,
            `LEAFLET_INTERNAL_LINK_${links.indexOf(link)}`
        );
    }

    /** Pull out tags */
    try {
        params = parseYaml(source);
    } catch (e) {
        console.error(`Obsidian Leaflet: YAML Parsing failed\n${e}`)
        params = Object.fromEntries(
            source.split("\n").map((l) => l.split(/:\s?/))
        );
    } finally {
        if (!params) params = {};
        let image: string[], layers: string[];

        if (links.length) {
            let stringified = JSON.stringify(params);

            for (let link of links) {
                stringified = stringified.replace(
                    `LEAFLET_INTERNAL_LINK_${links.indexOf(link)}`,
                    link
                );
                source = source.replace(
                    `LEAFLET_INTERNAL_LINK_${links.indexOf(link)}`,
                    link
                );
            }
            params = JSON.parse(stringified);
        }

        /** Get Images from Parameters */
        if ((source.match(/^\bimage\b:[\s\S]*?$/gm) ?? []).length > 1) {
            layers = (source.match(/^\bimage\b:([\s\S]*?)$/gm) || []).map(
                (p) => p.split("image: ")[1]
            );
        }

        if (typeof params.image === "string") {
            image = [params.image];
        } else if (params.image instanceof Array) {
            image = [...params.image];
        } else {
            image = ["real"];
        }

        params.layers = layers ?? [...image];

        params.image = params.layers[0];

        let obj: {
            marker: string[];
            markerFile: string[];
            markerFolder: string[];
            markerTag: string[][];
            filterTag: string[][];
            commandMarker: string[];
            geojson: string[];
            linksTo: string[];
            linksFrom: string[];
            overlay: string[];
        } = {
            marker: [],
            markerFile: [],
            markerFolder: [],
            markerTag: [],
            filterTag: [],
            commandMarker: [],
            geojson: [],
            linksTo: [],
            linksFrom: [],
            overlay: []
        };

        if (
            /* /(command)?[mM]arker(File|Folder|Tag)?:/ */ new RegExp(
                `(${Object.keys(obj).join("|")})`
            ).test(source)
        ) {
            //markers defined in code block;

            //Pull Markers

            Object.keys(obj).forEach((type: MarkerType) => {
                let r = new RegExp(`^\\b${type}\\b:\\s?([\\s\\S]*?)$`, "gm");

                switch (type) {
                    case "filterTag":
                    case "markerTag": {
                        if ((source.match(r) || []).length > 1) {
                            //defined separately
                            obj[type] = (source.match(r) || []).map((p) =>
                                p
                                    .split(new RegExp(`(?:${type}):\\s?`))[1]
                                    ?.trim()
                                    .split(/,\s?/)
                            );
                        } else if (params[type] instanceof Array) {
                            obj[type] = params[type].map((param) => {
                                if (param instanceof Array) return param;
                                return [param];
                            });
                        } else if (params[type] !== undefined && params) {
                            obj[type] = [[params[type] as unknown as string]];
                        }
                        break;
                    }
                    case "markerFile": {
                        if ((source.match(r) || []).length > 1) {
                            //defined separately
                            obj[type] = (source.match(r) || []).map((p) =>
                                p
                                    .split(new RegExp(`(?:${type}):\\s?`))[1]
                                    ?.trim()
                            );
                        } else if (params[type] instanceof Array) {
                            obj[type] = params[type].flat(2) as string[];
                        } else if (params[type] !== undefined) {
                            obj[type] = [params[type] as unknown as string];
                        }
                        break;
                    }
                    default: {
                        if ((source.match(r) || []).length > 1) {
                            //defined separately
                            obj[type] = (source.match(r) || []).map((p) =>
                                parseYaml(
                                    p
                                        .split(
                                            new RegExp(`(?:${type}):\\s?`)
                                        )[1]
                                        ?.trim()
                                )
                            );
                        } else if (params[type] instanceof Array) {
                            obj[type] = params[type];
                        } else if (params[type] !== undefined) {
                            obj[type] = [params[type] as unknown as string];
                        }
                    }
                }
            });
        }
        Object.assign(params, obj);

        return params;
    }
}

export function getGroupSeparator(locale: string) {
    const numberWithDecimalSeparator = 1000.1;
    return Intl.NumberFormat(locale)
        .formatToParts(numberWithDecimalSeparator)
        .find((part) => part.type === "group").value;
}

export function catchError(
    target: BaseMapType,
    name: string,
    descriptor: PropertyDescriptor
) {
    const original = descriptor.value;
    if (typeof original === "function") {
        descriptor.value = function (...args: any[]) {
            try {
                return original.apply(this, args);
            } catch (e) {
                //throw error here
                console.error(target, name, e, original);
                renderError(
                    this.contentEl?.parentElement ?? this.contentEl,
                    e.message
                );
            }
        };
    }
}

export function catchErrorAsync(
    target: BaseMapType,
    name: string,
    descriptor: PropertyDescriptor
) {
    const original = descriptor.value;
    if (typeof original === "function") {
        descriptor.value = async function (...args: any[]) {
            try {
                return await original.apply(this, args);
            } catch (e) {
                //throw error here
                console.error(target, name, e, original);
                renderError(
                    this.contentEl?.parentElement ?? this.contentEl,
                    e.message
                );
            }
        };
    }
}



================================================
FILE: src/utils/watcher.ts
================================================
import type { MarkerIcon, SavedOverlayData } from "../types";
import {
    Component,
    Events,
    FrontMatterCache,
    Notice,
    TAbstractFile,
    TFile
} from "obsidian";

import { Length } from "convert/dist/types/units";
import { getId, OVERLAY_TAG_REGEX } from ".";

import { LeafletSymbol } from "src/utils/leaflet-import";

import { LeafletRenderer } from "src/renderer/renderer";
import t from "src/l10n/locale";
import { Marker, Overlay } from "src/layer";
const L = window[LeafletSymbol];

export class Watcher extends Component {
    frontmatter: FrontMatterCache;
    type: MarkerIcon;
    ids: Map<string, string> = new Map();
    overlays: Overlay[];
    get plugin() {
        return this.renderer.plugin;
    }
    get app() {
        return this.plugin.app;
    }
    markers: Marker[] = [];
    constructor(public renderer: LeafletRenderer, public file: TFile) {
        super();

        this.loadMarkers();

        this.registerEvent(
            this.app.metadataCache.on("changed", (file) => this._onChange(file))
        );
        this.registerEvent(
            this.app.vault.on("rename", (file) => this._onRename(file))
        );
        this.registerEvent(
            this.app.vault.on("delete", (file) => this._onDelete(file))
        );

        this.load();
    }
    _onChange(file: TFile): any {
        if (file !== this.file) return;
    }
    _onRename(file: TAbstractFile): any {
        if (file !== this.file) return;
    }
    _onDelete(file: TAbstractFile): any {
        if (file !== this.file) return;
    }
    loadMarkers() {
        const cache = this.app.metadataCache.getFileCache(this.file);
        if (!("frontmatter" in cache)) return;

        this.frontmatter = cache.frontmatter;

        this.type = this.parseMarkerType(this.frontmatter);

        if ("location" in this.frontmatter) {
            let locations = this.frontmatter.location;
            if (
                locations instanceof Array &&
                !(locations[0] instanceof Array)
            ) {
                locations = [locations];
            }
            this.ids.set("location", getId());
            for (let index in locations) {
                const location = locations[index];
                if (
                    !(
                        location.length == 2 &&
                        location.every((v: any) => typeof v == "number")
                    )
                )
                    continue;
                this.markers.push(
                    new Marker(this.renderer.map, {
                        id: this.ids.get("location"),
                        type: this.type.type,
                        /* icon: this.type.icon, */
                        loc: L.latLng(location),
                        link: this.file.path,
                        layer: this.renderer.map.mapLayers[0].id,
                        mutable: false,
                        command: false,
                        zoom: null,
                        percent: null,
                        description: null
                    })
                );
            }
        }

        if (this.frontmatter.mapmarkers) {
            try {
                const { mapmarkers } = this.frontmatter;
                if (!Array.isArray(mapmarkers)) return;
                this.ids.set("mapmarkers", getId());
                mapmarkers.forEach(
                    ([type, location, description]: [
                        type: string,
                        location: [number, number],
                        description: string
                    ]) => {
                        this.markers.push(
                            new Marker(this.renderer.map, {
                                type: type,
                                loc: L.latLng(location),
                                percent: null,
                                id: this.ids.get("mapmarkers"),
                                link: this.plugin.app.metadataCache.fileToLinktext(
                                    this.file,
                                    "",
                                    true
                                ),
                                layer: this.renderer.map.currentGroup.id,
                                command: false,
                                mutable: false,
                                description: description,
                                zoom: null
                            })
                        );
                    }
                );
            } catch (e) {
                new Notice(
                    t(`There was an error updating the markers for %1.`)
                );
            }
        }

        if (
            this.frontmatter.mapoverlay &&
            this.frontmatter.mapoverlay instanceof Array
        ) {
            this.overlays.push(...this.frontmatter.mapoverlay);
        }

        /*if (this.fileIds.has("overlayTag")) {
            if (this.map.options.overlayTag in this.frontmatter) {
                this.map.overlays = this.map.overlays.filter(
                    ({ id, leafletInstance }) => {
                        if (id === this.fileIds.get("overlayTag")) {
                            leafletInstance.remove();
                        }
                        return id != this.fileIds.get("overlayTag");
                    }
                );
                let locations = this.frontmatter.location ?? [0, 0];
                if (
                    locations &&
                    locations instanceof Array &&
                    !(locations[0] instanceof Array)
                ) {
                    locations = [locations];
                }
                overlays.push([
                    this.map.options.overlayColor ?? "blue",
                    locations[0],
                    this.frontmatter[this.map.options.overlayTag],
                    `${file.basename}: ${this.map.options.overlayTag}`,
                    this.fileIds.get("overlayTag")
                ]);
            }
        } */
    }

    parseMarkerType(frontmatter: FrontMatterCache) {
        if (!("mapmarker" in frontmatter))
            return this.plugin.markerIcons.find((m) => m.type == "default");

        if (typeof frontmatter.mapmarker == "string") {
            const type = this.plugin.markerIcons.find(
                (m) => m.type == frontmatter.mapmarker
            );
            return (
                type ?? this.plugin.markerIcons.find((m) => m.type == "default")
            );
        }
        if (typeof frontmatter.mapmarker == "object") {
        }
        return this.plugin.markerIcons.find((m) => m.type == "default");
    }
}

export default class OldWatcher extends Events {
    frontmatter: FrontMatterCache;
    get plugin() {
        return this.renderer.plugin;
    }
    get map() {
        return this.renderer.map;
    }
    constructor(
        private renderer: LeafletRenderer,
        public file: TFile,
        private fileIds: Map<string, string>
    ) {
        super();

        this.renderer.registerEvent(
            this.plugin.app.metadataCache.on("changed", (file) =>
                this._onChange(file)
            )
        );
        this.renderer.registerEvent(
            this.plugin.app.vault.on("rename", (file) => this._onRename(file))
        );
        this.renderer.registerEvent(
            this.plugin.app.vault.on("delete", (file) => this._onDelete(file))
        );
    }

    //TODO REFACTOR AND IMPROVE LOGIC
    //VERY MESSY
    private _onChange(file: TFile) {
        if (file !== this.file) return;

        const cache = this.plugin.app.metadataCache.getFileCache(file);
        if (!("frontmatter" in cache)) return;
        this.frontmatter = cache.frontmatter;
        let overlays = [];
        const markers = this.map.getMarkersById(this.fileIds.get("marker"));

        if (
            markers &&
            this.frontmatter.location &&
            this.frontmatter.location instanceof Array
        ) {
            try {
                let locations = this.frontmatter.location;
                if (
                    locations &&
                    locations instanceof Array &&
                    !(locations[0] instanceof Array)
                ) {
                    locations = [locations];
                }

                for (let index in locations) {
                    const location = locations[index];
                    const marker = markers[index];

                    if (
                        marker &&
                        location.length == 2 &&
                        location.every((v: any) => typeof v == "number")
                    ) {
                        if (
                            !marker.loc.equals(
                                L.latLng(<L.LatLngTuple>location)
                            )
                        ) {
                            marker.setLatLng(L.latLng(<L.LatLngTuple>location));
                        }
                    }
                }
            } catch (e) {
                console.error(e);
                new Notice(
                    t(
                        `There was an error updating the marker for %1.`,
                        file.name
                    )
                );
            }
        }

        if (markers && this.frontmatter.mapmarker) {
            try {
                const { mapmarker } = this.frontmatter;

                if (
                    this.plugin.markerIcons.find(
                        ({ type }) => type == mapmarker
                    )
                ) {
                    for (const marker of markers) {
                        marker.icon = this.plugin.markerIcons.find(
                            ({ type }) => type == mapmarker
                        );
                    }
                }
            } catch (e) {
                console.error(e);
                new Notice(
                    t(
                        `There was an error updating the marker type for %1.`,
                        file.name
                    )
                );
            }
        }
        if (this.frontmatter.mapmarkers) {
            try {
                const markers = this.map.getMarkersById(
                    this.fileIds.get("mapmarkers")
                );
                const { mapmarkers } = this.frontmatter;
                for (const marker of markers) {
                    this.map.removeMarker(marker);
                }
                mapmarkers.forEach(
                    ([type, location, description]: [
                        type: string,
                        location: [number, number],
                        description: string
                    ]) => {
                        this.map.addMarker({
                            type: type,
                            loc: location,
                            percent: null,
                            id: this.fileIds.get("mapmarkers"),
                            link: this.plugin.app.metadataCache.fileToLinktext(
                                file,
                                "",
                                true
                            ),
                            layer: this.map.currentGroup.id,
                            command: false,
                            mutable: false,
                            description: description,
                            minZoom: null,
                            maxZoom: null,
                            tooltip: "hover"
                        });
                    }
                );
            } catch (e) {
                console.error(e);
                new Notice(
                    t(`There was an error updating the markers for %1.`)
                );
            }
        }

        if (this.fileIds.has("overlay")) {
            this.map.overlays
                .filter(({ data }) => data.id === this.fileIds.get("overlay"))
                ?.forEach((overlay) => {
                    overlay.leafletInstance.remove();
                });
            this.map.overlays = this.map.overlays.filter(
                ({ data }) => data.id != this.fileIds.get("overlay")
            );

            if (
                this.frontmatter.mapoverlay &&
                this.frontmatter.mapoverlay instanceof Array
            ) {
                overlays.push(...this.frontmatter.mapoverlay);
            }
        }
        if (this.fileIds.has("overlayTag")) {
            if (this.map.options.overlayTag in this.frontmatter) {
                this.map.overlays = this.map.overlays.filter(
                    ({ id, leafletInstance }) => {
                        if (id === this.fileIds.get("overlayTag")) {
                            leafletInstance.remove();
                        }
                        return id != this.fileIds.get("overlayTag");
                    }
                );
                let locations = this.frontmatter.location ?? [0, 0];
                if (
                    locations &&
                    locations instanceof Array &&
                    !(locations[0] instanceof Array)
                ) {
                    locations = [locations];
                }
                overlays.push([
                    this.map.options.overlayColor ?? "blue",
                    locations[0],
                    this.frontmatter[this.map.options.overlayTag],
                    `${file.basename}: ${this.map.options.overlayTag}`,
                    this.fileIds.get("overlayTag")
                ]);
            }
        }
        if (overlays.length) {
            const overlayArray: SavedOverlayData[] = [...overlays].map(
                ([
                    color,
                    loc,
                    length,
                    desc,
                    id = this.fileIds.get("overlay")
                ]) => {
                    const match = length.match(OVERLAY_TAG_REGEX);
                    if (!match || isNaN(Number(match[1]))) {
                        throw new Error(
                            "Could not parse overlay radius. Please make sure it is in the format `<length> <unit>`."
                        );
                    }
                    const [, radius, unit = "m"] = match;

                    return {
                        radius: Number(radius),
                        loc: loc,
                        color: color,
                        unit: unit as Length,
                        layer: this.map.currentGroup.id,
                        desc: desc,
                        id: id,
                        mutable: false
                    };
                }
            );
            this.map.addOverlay(...overlayArray);
        }
    }
    private _onRename(file: TAbstractFile) {
        if (file !== this.file) return;
        const markers = this.map.getMarkersById(this.fileIds.get("marker"));

        for (const marker of markers) {
            marker.link = this.plugin.app.metadataCache.fileToLinktext(
                this.file,
                "",
                true
            );
        }
    }
    private _onDelete(file: TAbstractFile) {
        if (file !== this.file) return;
        this.file = null;
        const markers = this.map.getMarkersById(this.fileIds.get("marker"));

        for (const marker of markers) {
            this.map.removeMarker(marker);
        }

        this.map.overlays
            .filter(({ data }) => data.id === this.fileIds.get("overlay"))
            ?.forEach((overlay) => {
                overlay.leafletInstance.remove();
            });
        this.map.overlays = this.map.overlays.filter(
            ({ data }) => data.id != this.fileIds.get("overlay")
        );
        this.trigger("remove");
    }
}



================================================
FILE: src/utils/fullscreen/fullscreen.ts
================================================
//@ts-nocheck
export function FullscreenPlugin(L) {
    L.Control.Fullscreen = L.Control.extend({
        options: {
            position: "topleft",
            title: {
                false: "View Fullscreen",
                true: "Exit Fullscreen"
            }
        },

        onAdd: function (map) {
            var container = L.DomUtil.create(
                "div",
                "leaflet-control-fullscreen leaflet-bar leaflet-control"
            );

            this.link = L.DomUtil.create(
                "a",
                "leaflet-control-fullscreen-button leaflet-bar-part",
                container
            );
            this.link.href = "#";

            this._map = map;
            this._map.on("fullscreenchange", this._toggleTitle, this);
            this._toggleTitle();

            L.DomEvent.on(this.link, "click", this._click, this);

            return container;
        },

        _click: function (e) {
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            this._map.toggleFullscreen(this.options);
        },

        _toggleTitle: function () {
            this.link.title = this.options.title[this._map.isFullscreen()];
        }
    });

    L.Map.include({
        isFullscreen: function () {
            return this._isFullscreen || false;
        },

        toggleFullscreen: function (options) {
            var container = this.getContainer();
            if (this.isFullscreen()) {
                if (options && options.pseudoFullscreen) {
                    this._disablePseudoFullscreen(container);
                } else if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else {
                    this._disablePseudoFullscreen(container);
                }
            } else {
                if (options && options.pseudoFullscreen) {
                    this._enablePseudoFullscreen(container);
                } else if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen(
                        Element.ALLOW_KEYBOARD_INPUT
                    );
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                } else {
                    this._enablePseudoFullscreen(container);
                }
            }
        },

        _enablePseudoFullscreen: function (container) {
            L.DomUtil.addClass(container, "leaflet-pseudo-fullscreen");
            this._setFullscreen(true);
            this.fire("fullscreenchange");
        },

        _disablePseudoFullscreen: function (container) {
            L.DomUtil.removeClass(container, "leaflet-pseudo-fullscreen");
            this._setFullscreen(false);
            this.fire("fullscreenchange");
        },

        _setFullscreen: function (fullscreen) {
            this._isFullscreen = fullscreen;
            var container = this.getContainer();
            if (fullscreen) {
                L.DomUtil.addClass(container, "leaflet-fullscreen-on");
            } else {
                L.DomUtil.removeClass(container, "leaflet-fullscreen-on");
            }
            this.invalidateSize();
        },

        _onFullscreenChange: function (e) {
            var fullscreenElement =
                document.fullscreenElement ||
                document.mozFullScreenElement ||
                document.webkitFullscreenElement ||
                document.msFullscreenElement;

            if (
                fullscreenElement === this.getContainer() &&
                !this._isFullscreen
            ) {
                this._setFullscreen(true);
                this.fire("fullscreenchange");
            } else if (
                fullscreenElement !== this.getContainer() &&
                this._isFullscreen
            ) {
                this._setFullscreen(false);
                this.fire("fullscreenchange");
            }
        }
    });

    L.Map.mergeOptions({
        fullscreenControl: false
    });

    L.Map.addInitHook(function () {
        if (this.options.fullscreenControl) {
            this.fullscreenControl = new L.Control.Fullscreen(
                this.options.fullscreenControl
            );
            this.addControl(this.fullscreenControl);
        }

        var fullscreenchange;

        if ("onfullscreenchange" in document) {
            fullscreenchange = "fullscreenchange";
        } else if ("onmozfullscreenchange" in document) {
            fullscreenchange = "mozfullscreenchange";
        } else if ("onwebkitfullscreenchange" in document) {
            fullscreenchange = "webkitfullscreenchange";
        } else if ("onmsfullscreenchange" in document) {
            fullscreenchange = "MSFullscreenChange";
        }

        if (fullscreenchange) {
            var onFullscreenChange = L.bind(this._onFullscreenChange, this);

            this.whenReady(function () {
                L.DomEvent.on(document, fullscreenchange, onFullscreenChange);
            });

            this.on("unload", function () {
                L.DomEvent.off(document, fullscreenchange, onFullscreenChange);
            });
        }
    });

    L.control.fullscreen = function (options) {
        return new L.Control.Fullscreen(options);
    };

    return L;
}



================================================
FILE: src/utils/fullscreen/leaflet.fullscreen.css
================================================
.leaflet-control-fullscreen a {
  background:#fff url(fullscreen.png) no-repeat 0 0;
  background-size:26px 52px;
  }
  .leaflet-touch .leaflet-control-fullscreen a {
    background-position: 2px 2px;
    }
  .leaflet-fullscreen-on .leaflet-control-fullscreen a {
    background-position:0 -26px;
    }
  .leaflet-touch.leaflet-fullscreen-on .leaflet-control-fullscreen a {
    background-position: 2px -24px;
    }

/* Do not combine these two rules; IE will break. */
.leaflet-container:-webkit-full-screen {
  width:100%!important;
  height:100%!important;
  }
.leaflet-container.leaflet-fullscreen-on {
  width:100%!important;
  height:100%!important;
  }

.leaflet-pseudo-fullscreen {
  position:fixed!important;
  width:100%!important;
  height:100%!important;
  top:0!important;
  left:0!important;
  z-index:99999;
  }

@media
  (-webkit-min-device-pixel-ratio:2),
  (min-resolution:192dpi) {
    .leaflet-control-fullscreen a {
      background-image:url(fullscreen@2x.png);
    }
  }



================================================
FILE: src/worker/gpx.worker.ts
================================================
import { GPX_OPTIONS, GPX_Data, Coordinate } from "../types/gpx";
import { DOMParser } from "xmldom";

const ctx: Worker = self as any;

// Respond to message from parent thread
ctx.onmessage = async (event) => {
    try {
        let str = event.data.string;
        str = str.replace(/>\s+</g, "><");
        str = str.replace(
            /gpxtpx:|gpxx:|ns3:|gpxdata:|wptx1:|ctx:|mytrails:/g,
            ""
        );
        str = str.replace(/cadence>/g, "cad>");
        str = str.replace(/heartrate>/g, "hr>");
        str = str.replace(/<\/temp>/g, "</atemp>");
        str = str.replace(/<temp>/g, "<atemp>");

        const parser = new GPXParser(str);
        ctx.postMessage({ data: parser.info });
    } catch (e) {
        ctx.postMessage({ error: e });
    }
};

const _MAX_POINT_INTERVAL_MS = 15000;
const _SECOND_IN_MILLIS = 1000;
const _MINUTE_IN_MILLIS = 60 * _SECOND_IN_MILLIS;
const _HOUR_IN_MILLIS = 60 * _MINUTE_IN_MILLIS;
const _DAY_IN_MILLIS = 24 * _HOUR_IN_MILLIS;

const _GPX_STYLE_NS = "http://www.topografix.com/GPX/gpx_style/0/2";
const _DEFAULT_POLYLINE_OPTS = {
    color: "blue"
};
const _DEFAULT_GPX_OPTS: GPX_OPTIONS = {
    parseElements: ["track", "route", "waypoint"],
    joinTrackSegments: true,
    max_point_interval: _MAX_POINT_INTERVAL_MS,
    polyline_options: _DEFAULT_POLYLINE_OPTS
};

class GPXParser {
    info: GPX_Data;
    layers: any = {};
    options: GPX_OPTIONS;
    constructor(public xml: string, options: GPX_OPTIONS = _DEFAULT_GPX_OPTS) {
        this.options = {
            ...options,
            ..._DEFAULT_GPX_OPTS
        };
        this._init_info();
        this._parse(this.xml);
    }
    get_duration_string(duration: number, hidems: boolean) {
        let s = "";

        if (duration >= _DAY_IN_MILLIS) {
            s += Math.floor(duration / _DAY_IN_MILLIS) + "d ";
            duration = duration % _DAY_IN_MILLIS;
        }

        if (duration >= _HOUR_IN_MILLIS) {
            s += Math.floor(duration / _HOUR_IN_MILLIS) + ":";
            duration = duration % _HOUR_IN_MILLIS;
        }

        const mins = Math.floor(duration / _MINUTE_IN_MILLIS);
        duration = duration % _MINUTE_IN_MILLIS;
        if (mins < 10) s += "0";
        s += mins + "'";

        const secs = Math.floor(duration / _SECOND_IN_MILLIS);
        duration = duration % _SECOND_IN_MILLIS;
        if (secs < 10) s += "0";
        s += secs;

        if (!hidems && duration > 0)
            s += "." + Math.round(Math.floor(duration) * 1000) / 1000;
        else s += '"';

        return s;
    }

    get_duration_string_iso(duration: number, hidems: boolean) {
        const s = this.get_duration_string(duration, hidems);
        return s.replace("'", ":").replace('"', "");
    }

    // Private methods
    _merge_objs(a: Record<any, any>, b: Record<any, any>) {
        return {
            ...a,
            ...b
        };
    }

    _prepare_data_point(
        p: any,
        trans1: (...args: any[]) => any,
        trans2: (...args: any[]) => any,
        trans_tooltip: any
    ) {
        const r = [
            (trans1 && trans1(p[0])) || p[0],
            (trans2 && trans2(p[1])) || p[1]
        ];
        r.push(
            (trans_tooltip && trans_tooltip(r[0], r[1])) || r[0] + ": " + r[1]
        );
        return r;
    }

    _init_info() {
        this.info = {
            name: null,
            desc: null,
            author: null,
            copyright: null,
            waypoints: [],
            styles: [],
            coords: [],
            length: 0.0,
            flags: {
                elevation: false,
                speed: false,
                hr: false,
                duration: false,
                atemp: false,
                cad: false
            },
            elevation: {
                gain: 0.0,
                loss: 0.0,
                max: 0.0,
                min: Infinity,
                total: 0,
                avg: 0,
                points: []
            },
            speed: {
                max: 0.0,
                min: Infinity,
                avg: 0,
                total: 0,
                points: []
            },
            hr: {
                avg: 0,
                min: Infinity,
                max: 0,
                total: 0,
                points: []
            },
            duration: {
                start: null,
                end: null,
                moving: 0,
                total: 0
            },
            atemp: {
                avg: 0,
                min: Infinity,
                max: 0,
                total: 0,
                points: []
            },
            cad: {
                avg: 0,
                min: Infinity,
                max: 0,
                total: 0,
                points: []
            }
        };
    }
    _parse(input: string, options: any = this.options, async: boolean = false) {
        const cb = (gpx: XMLDocument, options: any) => {
            const layers = this._parse_gpx_data(gpx, options);
            if (!layers) {
                throw new Error("No layers found.");
            }
            this.layers = layers;
            this.info.coords = this.layers.map((layer: any) => layer.coords);
            this.info.styles = this.layers.map((layer: any) => layer.style);
        };
        const parser = new DOMParser();
        if (async) {
            setTimeout(function () {
                cb(parser.parseFromString(input, "text/xml"), options);
            });
        } else {
            cb(parser.parseFromString(input, "text/xml"), options);
        }
    }

    _parse_gpx_data(xml: XMLDocument, options = this.options) {
        let layers: any[] = [];

        const name = xml.getElementsByTagName("name");
        if (name.length > 0) {
            this.info.name = name[0].textContent;
        }
        const desc = xml.getElementsByTagName("desc");
        if (desc.length > 0) {
            this.info.desc = desc[0].textContent;
        }
        const author = xml.getElementsByTagName("author");
        if (author.length > 0) {
            this.info.author = author[0].textContent;
        }
        const copyright = xml.getElementsByTagName("copyright");
        if (copyright.length > 0) {
            this.info.copyright = copyright[0].textContent;
        }

        const parseElements = options.parseElements;
        if (parseElements.indexOf("route") > -1) {
            // routes are <rtept> tags inside <rte> sections
            const routes = xml.getElementsByTagName("rte");
            for (let i = 0; i < routes.length; i++) {
                layers.push(
                    ...this._parse_segment(routes[i], options, {}, "rtept")
                );
            }
        }

        if (parseElements.indexOf("track") > -1) {
            // tracks are <trkpt> tags in one or more <trkseg> sections in each <trk>
            const tracks = xml.getElementsByTagName("trk");
            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                const polyline_options = this._extract_styling(track);

                if (options.joinTrackSegments) {
                    layers.push(
                        ...this._parse_segment(
                            track,
                            options,
                            polyline_options,
                            "trkpt"
                        )
                    );
                } else {
                    const segments = track.getElementsByTagName("trkseg");
                    for (let j = 0; j < segments.length; j++) {
                        layers.push(
                            ...this._parse_segment(
                                segments[j],
                                options,
                                polyline_options,
                                "trkpt"
                            )
                        );
                    }
                }
            }
        }

        this.info.hr.avg = Math.round(
            this.info.hr.total / this.info.hr.points.length
        );
        this.info.cad.avg = Math.round(
            this.info.cad.total / this.info.cad.points.length
        );
        this.info.atemp.avg = Math.round(
            this.info.atemp.total / this.info.atemp.points.length
        );
        this.info.speed.avg = Math.round(
            this.info.speed.total / this.info.speed.points.length
        );
        this.info.elevation.avg = Math.round(
            this.info.elevation.total / this.info.elevation.points.length
        );

        // parse waypoints and add markers for each of them
        if (parseElements.indexOf("waypoint") > -1) {
            this.info.waypoints = [];
            const el = xml.getElementsByTagName("wpt");
            for (let i = 0; i < el.length; i++) {
                var ll = {
                    lat: Number(el[i].getAttribute("lat")),
                    lng: Number(el[i].getAttribute("lon"))
                };

                const nameEl = el[i].getElementsByTagName("name");
                const name = nameEl.length > 0 ? nameEl[0].textContent : "";

                const descEl = el[i].getElementsByTagName("desc");
                const desc = descEl.length > 0 ? descEl[0].textContent : "";

                const symEl = el[i].getElementsByTagName("sym");
                const symKey = symEl.length > 0 ? symEl[0].textContent : null;

                const typeEl = el[i].getElementsByTagName("type");
                const typeKey =
                    typeEl.length > 0 ? typeEl[0].textContent : null;

                this.info.waypoints.push({
                    ...ll,
                    name,
                    desc,
                    symbol: symKey,
                    type: typeKey
                });
            }
        }
        return layers;
    }

    _parse_segment(
        line: Element,
        options: GPX_OPTIONS,
        polyline_options: any,
        tag: string
    ) {
        const el = line.getElementsByTagName(tag);
        if (!el.length) return [];

        const coords: Coordinate[] = [];
        let last = null;

        for (let i = 0; i < el.length; i++) {
            const ll: Coordinate = {
                lat: Number(el[i].getAttribute("lat")),
                lng: Number(el[i].getAttribute("lon")),
                meta: {
                    time: null,
                    elevation: null,
                    hr: null,
                    cad: null,
                    atemp: null,
                    speed: null
                }
            };
            /** Time */
            const timeEl = el[i].getElementsByTagName("time");
            if (
                timeEl.length > 0 &&
                !isNaN(Date.parse(timeEl[0].textContent))
            ) {
                ll.meta.time = new Date(Date.parse(timeEl[0].textContent));
            }
            const time_diff =
                last != null
                    ? Math.abs(
                          ll.meta.time?.valueOf() ??
                              0 - last.meta.time?.valueOf()
                      ) ?? null
                    : null;

            const eleEl = el[i].getElementsByTagName("ele");

            if (eleEl.length > 0) {
                ll.meta.elevation = parseFloat(eleEl[0].textContent);
                this.info.flags.elevation = true;
            } else if (last && last.meta?.elevation) {
                // If the point doesn't have an <ele> tag, assume it has the same
                // elevation as the point before it (if it had one).
                ll.meta.elevation = last.meta.elevation;
                this.info.flags.elevation = true;
            } else {
                ll.meta.elevation = null;
            }
            const ele_diff =
                last != null ? ll.meta.elevation - last.meta.elevation : null;
            const dist_3d = last != null ? this._dist3d(last, ll) : null;

            const speedEl = el[i].getElementsByTagName("speed");
            if (speedEl.length > 0) {
                this.info.flags.speed = true;
                ll.meta.speed = parseFloat(speedEl[0].textContent);
            } else {
                // speed in meter per second
                ll.meta.speed =
                    time_diff > 0 ? (1000.0 * dist_3d) / time_diff : null;
            }

            const hrEl = el[i].getElementsByTagNameNS("*", "hr");
            if (hrEl.length > 0) {
                this.info.flags.hr = true;
                ll.meta.hr = parseInt(hrEl[0].textContent);
                this.info.hr.points.push([ll.lat, ll.lng, ll.meta.hr]);
                this.info.hr.total += ll.meta.hr;
            }

            const cadEl = el[i].getElementsByTagNameNS("*", "cad");
            if (cadEl.length > 0) {
                this.info.flags.cad = true;
                ll.meta.cad = parseInt(cadEl[0].textContent);
                this.info.cad.points.push([ll.lat, ll.lng, ll.meta.cad]);
                this.info.cad.total += ll.meta.cad;
                if (ll.meta.cad > this.info.cad.max) {
                    this.info.cad.max = ll.meta.cad;
                }
                if (ll.meta.cad < this.info.cad.min) {
                    this.info.cad.min = ll.meta.cad;
                }
            }

            const atempEl = el[i].getElementsByTagNameNS("*", "atemp");
            if (atempEl.length > 0) {
                this.info.flags.atemp = true;
                ll.meta.atemp = parseInt(atempEl[0].textContent);
                this.info.atemp.points.push([ll.lat, ll.lng, ll.meta.atemp]);
                this.info.atemp.total += ll.meta.atemp;
            }

            if (ll.meta.elevation > this.info.elevation.max) {
                this.info.elevation.max = ll.meta.elevation;
            }
            if (ll.meta.elevation < this.info.elevation.min) {
                this.info.elevation.min = ll.meta.elevation;
            }
            this.info.elevation.total += ll.meta.elevation;
            this.info.elevation.points.push([
                ll.lat,
                ll.lng,
                ll.meta.elevation
            ]);

            if (ll.meta.speed > this.info.speed.max) {
                this.info.speed.max = ll.meta.speed;
            }
            if (ll.meta.speed < this.info.speed.min) {
                this.info.speed.min = ll.meta.speed;
            }
            this.info.speed.total += ll.meta.speed;
            this.info.speed.points.push([ll.lat, ll.lng, ll.meta.speed]);

            if (last == null && this.info.duration.start == null) {
                this.info.duration.start = ll.meta.time;
            }
            this.info.duration.end = ll.meta.time;
            this.info.duration.total += time_diff;
            if (time_diff < options.max_point_interval) {
                this.info.duration.moving += time_diff;
            }

            this.info.length += dist_3d;

            if (ele_diff > 0) {
                this.info.elevation.gain += ele_diff;
            } else {
                this.info.elevation.loss += Math.abs(ele_diff);
            }

            last = ll;
            coords.push(ll);
        }

        return [
            {
                coords,
                style: this._extract_styling(
                    line,
                    polyline_options,
                    options.polyline_options
                )
            }
        ];
    }

    _extract_styling(el: Element, base?: any, overrides?: any) {
        var style = this._merge_objs(_DEFAULT_POLYLINE_OPTS, base);
        var e = el.getElementsByTagNameNS(_GPX_STYLE_NS, "line");
        if (e.length > 0) {
            var _ = e[0].getElementsByTagName("color");
            if (_.length > 0) style.color = "#" + _[0].textContent;
            var _ = e[0].getElementsByTagName("opacity");
            if (_.length > 0) style.opacity = _[0].textContent;
            var _ = e[0].getElementsByTagName("weight");
            if (_.length > 0) style.weight = _[0].textContent;
            var _ = e[0].getElementsByTagName("linecap");
            if (_.length > 0) style.lineCap = _[0].textContent;
            var _ = e[0].getElementsByTagName("linejoin");
            if (_.length > 0) style.lineJoin = _[0].textContent;
            var _ = e[0].getElementsByTagName("dasharray");
            if (_.length > 0) style.dashArray = _[0].textContent;
            var _ = e[0].getElementsByTagName("dashoffset");
            if (_.length > 0) style.dashOffset = _[0].textContent;
        }
        return this._merge_objs(style, overrides);
    }

    _dist2d(a: any, b: any) {
        var R = 6371000;
        var dLat = this._deg2rad(b.lat - a.lat);
        var dLon = this._deg2rad(b.lng - a.lng);
        var r =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(this._deg2rad(a.lat)) *
                Math.cos(this._deg2rad(b.lat)) *
                Math.sin(dLon / 2) *
                Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1 - r));
        var d = R * c;
        return d;
    }

    _dist3d(a: any, b: any) {
        var planar = this._dist2d(a, b);
        var height = Math.abs(b.meta.elevation - a.meta.elevation);
        return Math.sqrt(Math.pow(planar, 2) + Math.pow(height, 2));
    }

    _deg2rad(deg: number) {
        return (deg * Math.PI) / 180;
    }
}



================================================
FILE: src/worker/image.worker.ts
================================================
const ctx: Worker = self as any;

// Respond to message from parent thread
ctx.onmessage = async (event) => {
    if (!event.data.type) return;

    if (event.data.type === "url") {
        for (let { blob, id } of event.data.blobs) {
            ctx.postMessage({ data: await toDataURL(blob), id });
        }
    }
};

async function toDataURL(
    blob: Blob
): Promise<{ data: string /* h: number; w: number */ }> {
    //determine link type
    return new Promise(async (resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (typeof reader.result === "string") {
                let data = reader.result.slice(
                    reader.result.indexOf(";base64,")
                );
                resolve({ data /* , h, w */ });
            } else {
                reject();
            }
        };

        /*         const bitmap = await createImageBitmap(blob);
        const { height: h, width: w } = bitmap;
 */
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}



================================================
FILE: src/worker/loader.ts
================================================
import { App, Events, Notice } from "obsidian";

import { parseLink } from "../utils";
import { ImageLayerData } from "../types";
import t from "src/l10n/locale";

export default class Loader extends Events {
    constructor(public app: App) {
        super();
    }
    async loadImage(id: string, layers: string[]): Promise<void> {
        for (let image of layers) {
            const { link, id: layerId, alias } = await this.getLink(image);

            const { h, w } = await this.getImageDimensions(link);
            const layer = {
                data: link,
                h,
                w,
                alias,
                id: layerId
            };
            this.trigger(`${id}-layer-data-ready`, layer);
        }
    }

    async loadImageAsync(
        id: string,
        layers: string[]
    ): Promise<ImageLayerData> {
        return new Promise(async (resolve, reject) => {
            for (let image of layers) {
                const { link, id: layerId, alias } = await this.getLink(image);

                const { h, w } = await this.getImageDimensions(link);
                const layer = {
                    data: link,
                    h,
                    w,
                    alias,
                    id: layerId
                };
                resolve(layer);
            }
        });
    }
    unload() {}
    getImageDimensions(url: string): Promise<{ h: number; w: number }> {
        return new Promise(function (resolved, reject) {
            var i = new Image();
            i.onload = function () {
                const { width, height } = i;
                i.detach();
                resolved({ w: width, h: height });
            };
            i.onerror = () => {
                new Notice(
                    t("There was an issue getting the image dimensions.")
                );
                reject();
            };

            i.src = url;
        });
    }
    async getLink(url: string) {
        url = decodeURIComponent(url);
        let type: "link" | "file";
        let link: string, alias: string;
        try {
            if (/https?:/.test(url)) {
                //url
                type = "link";
                const [linkpath, aliaspath] = parseLink(url).split("|");
                link = linkpath;
                alias = aliaspath;
            } else {
                type = "file";
                const [linkpath, aliaspath] = parseLink(url).split("|");
                alias = aliaspath && aliaspath.length ? aliaspath : null;
                let file = this.app.metadataCache.getFirstLinkpathDest(
                    linkpath,
                    ""
                );
                if (!file) throw new Error();
                link = this.app.vault.getResourcePath(file);
            }
        } catch (e) {
            console.error(e);
        }
        return { link, id: encodeURIComponent(url), alias };
    }
}



================================================
FILE: types/controls.d.ts
================================================
import type { IconName } from "@fortawesome/free-solid-svg-icons";
import type L from "leaflet";
import type { GPX } from "./layers";

import { BaseMapType } from "./map";

export class GPXControl extends FontAwesomeControl {
    target: GPX;
    constructor(opts: FontAwesomeControlOptions, map: BaseMapType);
    onClick(evt: MouseEvent): void;
    setTarget(gpx: GPX): void;
}

export interface FontAwesomeControlOptions extends L.ControlOptions {
    icon: IconName;
    cls: string;
    tooltip: string;
}
export abstract class FontAwesomeControl extends L.Control {
    icon: IconName;
    controlEl: HTMLElement;
    cls: string;
    tooltip: string;
    leafletInstance: L.Map;
    iconEl: HTMLElement;
    enabled: boolean;
    constructor(opts: FontAwesomeControlOptions, leafletMap: L.Map);
    onAdd(leafletMap: L.Map): HTMLElement;
    abstract onClick(evt: MouseEvent): void;
    added(): void;
    disable(): void;
    enable(): void;
    setTooltip(tooltip: string): void;
    removeTooltip(): void;
}



================================================
FILE: types/gpx.d.ts
================================================
export interface PolylineOptions {
    color?: string;
}

export interface GPX_OPTIONS {
    parseElements: Array<"track" | "route" | "waypoint">;
    joinTrackSegments: boolean;
    max_point_interval: number;
    polyline_options: PolylineOptions;
}

export interface InfoItem {
    min: number;
    max: number;
    total: number;
    avg: number;
    points: any[];
}

export interface Elevation extends InfoItem {
    gain: number;
    loss: number;
}

export interface Duration
    extends Omit<InfoItem, "min" | "max" | "avg" | "points"> {
    start: Date;
    end: Date;
    moving: number;
    total: number;
}
export interface GPX_Data {
    flags: {
        elevation: boolean;
        speed: boolean;
        hr: boolean;
        duration: boolean;
        atemp: boolean;
        cad: boolean;
    };
    name?: string;
    coords?: any[];
    desc?: string;
    author?: string;
    copyright?: string;
    waypoints?: any[];
    styles?: any[];
    length?: number;
    elevation?: Elevation;
    speed?: InfoItem;
    hr?: InfoItem;
    duration?: Duration;
    atemp?: InfoItem;
    cad?: InfoItem;
}

export interface Coordinate {
    lat: number;
    lng: number;
    meta: {
        time: Date;
        elevation: number;
        hr: number;
        cad: number;
        atemp: number;
        speed: number;
    };
}



================================================
FILE: types/index.d.ts
================================================
export * from "./main";
export * from "./map";
export * from "./overlay";
export * from "./marker";
export * from "./saved";
export * from "./view";



================================================
FILE: types/layers.d.ts
================================================
import type L from "leaflet";
import type { BaseMapType, LayerGroup, Popup } from "./map";

export abstract class Layer<T extends L.Layer> {
    map: BaseMapType;
    layer: string;

    abstract popup: Popup;

    get mapLayer(): LayerGroup<L.TileLayer | L.ImageOverlay>;

    abstract leafletInstance: T;
    abstract get group(): L.LayerGroup;

    onShow(): void;
    show(): void;
    onHide(): void;
    hide(): void;

    checkAndAddToMap(): void;
    remove(): void;
}

export interface GPXPoint extends L.LatLng {
    meta: {
        atemp: number;
        cad: number;
        elevation: number;
        hr: number;
        speed: number;
        time: Date;
    };
}

export class GPX extends Layer<L.GeoJSON> {
    leafletInstance: L.GeoJSON;
    style: { opacity: string; color: string };
    hotline: L.Polyline;
    popup: Popup;
    gpx: GeoJSON.FeatureCollection;
    domObject: Record<any, any>;
    data: any;
    worker: Worker;

    parsed: boolean;
    displaying: string;

    get group(): L.FeatureGroup;
    get renderer(): L.Canvas;
    constructor(
        map: BaseMapType,
        gpx: string,
        /* options: GPXOptions, */
        icons: any
    );
    switch(which: "cad" | "ele" | "hr" | "speed" | "default"): void;
/*     bindHotlineEvents(): void; */
    findClosestPoint(latlng: L.LatLng): GPXPoint;
    get points(): GPXPoint[];
    get speed(): {
        points: L.LatLng[];
        min: number;
        max: number;
        avg: number;
    };
    get cad(): {
        points: L.LatLng[];
        min: number;
        max: number;
        avg: number;
    };
    get elevation(): {
        gain: number;
        loss: number;
        max: number;
        min: number;
        total: number;
        avg: number;
        points: L.LatLng[];
    };
    get hr(): {
        points: L.LatLng[];
        min: number;
        max: number;
        avg: number;
    };
    get atemp(): { points: L.LatLng[]; min: number; max: number; avg: number };

    featureGroup: L.FeatureGroup;
}



================================================
FILE: types/main.d.ts
================================================
import { Length } from "convert/dist/types/units";
import {
    Debouncer,
    MarkdownPostProcessorContext,
    Platform,
    Plugin
} from "obsidian";
import {
    BaseMapType,
    Icon,
    LeafletMapView,
    MarkerIcon,
    ObsidianAppData
} from ".";

export interface MapInterface {
    map: BaseMapType;
    source: string;
    el: HTMLElement;
    id: string;
}

export interface BlockParameters {
    id?: string;
    image?: string | string[];
    layers?: string[];
    tileServer?: string | string[];
    tileSubdomains?: string | string[];
    tileOverlay?: string | string[];
    osmLayer?: boolean;
    marker?: string[];
    commandMarker?: string[];
    markerFolder?: string[];
    markerFile?: string[];
    markerTag?: string[][];
    filterTag?: string[][];
    imageOverlay?: Array<[string, [number, number], [number, number]]>;
    overlay?: string[];
    overlayTag?: string;
    overlayColor?: string;
    height?: string;
    minZoom?: number;
    maxZoom?: number;
    defaultZoom?: number;
    zoomDelta?: number;
    lat?: string;
    long?: string;
    scale?: number;
    unit?: string;
    distanceMultiplier?: number;
    darkMode?: string;
    bounds?: [[number, number], [number, number]];
    coordinates?: [string, string] | string;
    zoomTag?: string;
    linksTo?: string[];
    linksFrom?: string[];
    geojsonFolder?: string[];
    geojson?: string[];
    gpxFolder?: string[];
    gpx?: string[];
    gpxMarkers?: {
        start?: string;
        end?: string;
        waypoint?: string;
    };
    geojsonColor?: string;
    gpxColor?: string;
    drawColor?: string;
    zoomFeatures?: boolean;
    showAllMarkers?: boolean;
    verbose?: boolean;
    isMapView?: boolean;
    isInitiativeView?: boolean;
    draw?: boolean;
    preserveAspect?: boolean;
    noUI?: boolean;
    width?: string;
    recenter?: boolean;
    noScrollZoom?: boolean;
    lock?: boolean;
}




================================================
FILE: types/map.d.ts
================================================
import type { Length } from "convert/dist/types/units";

import type L from "leaflet";
import type { DivIcon } from "leaflet";
import type { EventRef, Events } from "obsidian";
import type { MarkerIcon, SavedMarkerProperties, SavedOverlayData } from ".";

import type { Marker } from ".";
import type { ObsidianAppData, TooltipDisplay } from "./saved";
import type { Overlay } from "src/layer";
import type { Layer } from "src/layer/layer";
import type { GPXControl } from "./controls";
import type { LeafletRenderer } from "src/renderer/renderer";
import { DrawingController } from "src/draw/controller";
import { ShapeProperties } from "src/draw/shape";
import type geojson from "geojson";
import type ObsidianLeaflet from "src/main";

export interface ImageLayerData {
    data: string;
    alias: string;
    id: string;
    h: number;
    w: number;
}
export interface LayerGroup<T extends L.TileLayer | L.ImageOverlay> {
    /** Layer group containing the marker layer groups */
    group: L.LayerGroup;

    /** Marker type layer groups (used to filter out marker types) */
    markers: { [type: string]: L.LayerGroup };
    /** Marker type layer groups (used to filter out marker types) */
    overlays: { [type: string]: L.LayerGroup };

    /** Actual rendered map layer */
    layer: T;

    /** Reference ID */
    id: string;

    /** Only used for image maps -> actual image map data as base64 */
    /* data: string ;*/

    /** Only used for image maps -> dimensions of image */
    dimensions?: [number, number];

    /** Alias */
    alias?: string;
}

export interface MarkerDivIconOptions extends L.DivIconOptions {
    data?: { [key: string]: string };
}

export interface DivIconMarkerOptions extends L.MarkerOptions {
    icon: MarkerDivIcon;
}
export interface LeafletMapOptions {
    bounds?: [[number, number], [number, number]];
    context?: string;
    darkMode?: boolean;
    defaultZoom?: number;
    distanceMultiplier?: number;

    draw?: boolean;
    drawColor?: string;

    geojsonColor?: string;
    gpxColor?: string;

    localMarkerTypes?: MarkerIcon[];

    hasAdditional?: boolean;
    height?: string;
    width?: string;
    id?: string;
    imageOverlays?: {
        alias: string;
        bounds: [[number, number], [number, number]];
        data: string;
        id: string;
    }[];

    isInitiativeView?: boolean;
    isMapView: boolean;

    layers?: string[];

    lock?: boolean;

    maxZoom?: number;
    minZoom?: number;

    noUI?: boolean;
    noScrollZoom?: boolean;

    osmLayer?: boolean;

    overlayColor?: string;
    overlayTag?: string;

    recenter?: boolean;

    scale?: number;

    unit?: string;

    tileLayer?: string[];
    tileOverlay?: string[];

    tileSubdomains: string[];

    type?: "image" | "real";
    verbose?: boolean;
    zoomDelta?: number;
    zoomFeatures?: boolean;
    zoomMarkers?: boolean;
}

declare class Popup {
    leafletInstance: L.Popup;
    handlerTarget: any;
    options: L.PopupOptions;
    constructor(
        map: BaseMapType,
        target: Layer<any> | L.LatLng | L.Polyline,
        options?: L.PopupOptions
    );
    open(
        content: ((source: L.Layer) => L.Content) | L.Content,
        handler?: L.Layer
    ): void;
    close(): void;
    isOpen(): boolean;
    setContent(content: ((source: L.Layer) => L.Content) | L.Content): void;
    setLatLng(latlng: L.LatLng): void;
    setTarget(target: Layer<any> | L.LatLng | L.Polyline): Popup;
}

declare abstract class BaseMap /* <
    T extends L.ImageOverlay | L.TileLayer
> */
    extends Events
{
    abstract render(options: {
        coords: [number, number];
        zoomDistance: number;
        imageOverlayData?: {
            id: string;
            data: string;
            alias: string;
            bounds: [[number, number], [number, number]];
        }[];
    }): Promise<void>;
    abstract type: string;
    abstract get bounds(): L.LatLngBounds;
    abstract get scale(): number;
    abstract get CRS(): L.CRS;

    constructor(renderer: LeafletRenderer, options: LeafletMapOptions);

    canvas: L.Canvas;

    controller: DrawingController;

    get currentGroup(): LayerGroup<L.TileLayer | L.ImageOverlay>;
    contentEl: HTMLElement;
    currentLayer: L.ImageOverlay | L.TileLayer;

    get data(): ObsidianAppData;
    get defaultIcon(): MarkerIcon;

    displaying: Map<string, boolean>;
    get displayed(): Marker[];
    distanceAlongPolylines(polylines: L.Polyline[]): string;
    drawingLayer: L.LayerGroup;

    featureLayer: L.FeatureGroup;

    geojsonData: any[];

    gpxControl: GPXControl;
    gpxLayer: L.FeatureGroup;
    gpxData: { data: string; alias?: string }[];
    gpxIcons: {
        start: string;
        end: string;
        waypoint: string;
    };

    get id(): string;

    initialCoords: [number, number];

    isDrawing: boolean;
    get isFullscreen(): boolean;

    leafletInstance: L.Map;
    mapLayers: LayerGroup<L.TileLayer | L.ImageOverlay>[];

    markers: Marker[];
    get markerIcons(): Map<string, MarkerIcon>;
    get markerTypes(): string[];

    options: LeafletMapOptions;
    overlays: Overlay[];

    get plugin(): ObsidianLeaflet;

    popup: Popup;
    previousDistanceLines: L.Polyline[];

    readyForDrawings: boolean;

    renderer: LeafletRenderer;
    rendered: boolean;

    tempCircle: L.Circle;

    verbose: boolean;

    zoom: {
        min: number;
        max: number;
        default: number;
        delta: number;
    };
    zoomDistance: number;

    unit: Length;

    /** Marker Methods */
    addMarker(...markers: SavedMarkerProperties[]): Marker[];

    createMarker(
        type: string,
        loc: [number, number],
        percent: [number, number],
        id: string,
        link?: string,
        layer?: string,
        mutable?: boolean,
        command?: boolean,
        description?: string,
        minZoom?: number,
        maxZoom?: number,
        tooltip?: TooltipDisplay
    ): Marker;

    onMarkerClick(marker: Marker, evt: L.LeafletMouseEvent): void;

    updateMarker(marker: Marker): void;

    /** Overlay Methods */
    addOverlay(...overlays: SavedOverlayData[]): void;
    createOverlay(overlay: SavedOverlayData): void;
    beginOverlayDrawingContext(
        original: L.LeafletMouseEvent,
        marker?: Marker
    ): void;

    /** Other Methods */
    addShapes(...shapes: ShapeProperties[]): void;
    closePopup(popup: L.Popup): void;
    distance(latlng1: L.LatLng, latlng2: L.LatLng): string;
    getMarkersById(id: string): Marker[];
    getOverlaysUnderClick(evt: L.LeafletMouseEvent): Overlay[];
    getZoom(): number;
    handleMapContext(evt: L.LeafletMouseEvent, overlay?: Overlay): void;
    isLayerRendered(layer: string): boolean;

    loadFeatureData(data: {
        geojsonData: { data: geojson.GeoJsonObject; alias?: string }[];
        gpxData: { data: string; alias?: string }[];
        gpxIcons: {
            start: string;
            end: string;
            waypoint: string;
        };
    }): void;

    log(text: string): void;
    registerScope(): void;
    remove(): void;
    removeMarker(marker: Marker): void;
    resetZoom(): void;
    unregisterScope(): void;
    abstract setInitialCoords(coords: [number, number]): void;

    sortOverlays(): void;
    setZoomByDistance(zoomDistance: number): void;
    startDrawingContext(): void;
    stopDrawingContext(): void;
    toProperties(): SavedMapData;
    updateMarkerIcons(): void;

    updateLockState(state: boolean): void;

    zoomAllMarkers(): void;

    on(name: "removed", callback: () => void): EventRef;
    on(
        name: "layer-ready-for-features",
        callback: (layer: string) => void
    ): EventRef;
    on(name: "first-layer-ready", callback: (layer: string) => void): EventRef;
    on(
        name: "create-immutable-layer",
        callback: (layer: Marker | Overlay) => Promise<void>
    ): EventRef;
    on(name: "should-save", callback: () => Promise<void>): EventRef;
    on(name: "marker-added", callback: (marker: Marker) => void): EventRef;
    on(name: "marker-dragging", callback: (marker: Marker) => void): EventRef;
    on(
        name: "marker-data-updated",
        callback: (marker: Marker) => void
    ): EventRef;
    on(name: "marker-updated", callback: (marker: Marker) => void): EventRef;
    on(name: "marker-deleted", callback: (marker: Marker) => void): EventRef;
    on(name: "markers-updated", callback: () => void): EventRef;
    on(name: "should-close-popup", callback: (source: Popup) => void): EventRef;
    on(name: "should-save", callback: () => void): EventRef;
    on(name: "lock", callback: () => void): EventRef;
    on(name: "ready-for-drawings", callback: () => void): EventRef;
}

declare class RealMap extends BaseMap /* <L.TileLayer> */ {
    CRS: L.CRS;
    type: string;
    constructor(renderer: LeafletRenderer, options: LeafletMapOptions);

    get bounds(): L.LatLngBounds;

    get scale(): number;

    setInitialCoords(coords: [number, number]): void;

    render(options: {
        coords: [number, number];
        zoomDistance: number;
        imageOverlayData?: {
            id: string;
            data: string;
            alias: string;
            bounds: [[number, number], [number, number]];
        }[];
    }): Promise<void>;
}
declare class ImageMap extends BaseMap /* <L.ImageOverlay> */ {
    CRS: L.CRS;
    type: string;
    constructor(renderer: LeafletRenderer, options: LeafletMapOptions);

    get bounds(): L.LatLngBounds;

    get scale(): number;

    setInitialCoords(coords: [number, number]): void;

    render(options: {
        coords: [number, number];
        zoomDistance: number;
        imageOverlayData?: {
            id: string;
            data: string;
            alias: string;
            bounds: [[number, number], [number, number]];
        }[];
    }): Promise<void>;

    buildLayer(layer: ImageLayerData): Promise<void>;
}

export type BaseMapType = RealMap | ImageMap;

export interface SavedMapData {
    id: string;
    locked: boolean;
    lastAccessed: number;
    markers: SavedMarkerProperties[];
    overlays: SavedOverlayData[];
    shapes: ShapeProperties[];
}

declare class MarkerDivIcon extends DivIcon {
    options: MarkerDivIconOptions;
    div: HTMLElement;
    constructor(options: MarkerDivIconOptions);
    createIcon(oldIcon: HTMLElement): HTMLElement;
    setData(data: { [key: string]: string }): void;
}

declare class DivIconMarker extends L.Marker {
    options: DivIconMarkerOptions;
    constructor(
        latlng: L.LatLng,
        options: L.MarkerOptions,
        data: { [key: string]: string }
    );
}

declare class DistanceDisplay extends L.Control {
    controlEl: HTMLElement;
    textEl: HTMLSpanElement;
    get lines(): L.Polyline[];
    map: BaseMapType;
    popups: Popup[];
    constructor(opts: L.ControlOptions, map: BaseMapType);
    initEvents(): void;
    onMouseEnter(): void;
    onClick(evt: MouseEvent): void;
    onMouseLeave(): void;
    onAdd(map: L.Map): HTMLElement;
    setText(text: string): void;
}



================================================
FILE: types/marker.d.ts
================================================
import { Icon, TooltipDisplay } from ".";
import { MarkerDivIcon } from "./map";
import type { Marker as MarkerDefinition } from "../src/layer/marker";

export type Marker = MarkerDefinition;
export interface MarkerIcon {
    readonly type: string;
    readonly html: string;
    readonly icon: MarkerDivIcon;
    readonly markerIcon: Icon;
}

export interface MarkerProperties {
    id: string;
    type: string;
    loc: L.LatLng;
    link: string;
    layer: string;
    mutable: boolean;
    command: boolean;
    zoom: number;
    percent: [number, number];
    description: string;
    minZoom?: number;
    maxZoom?: number;
    tooltip?: TooltipDisplay;
}

export interface SavedMarkerProperties {
    type:
        | string
        | {
              icon: string;
              color: string;
              layer: boolean;
          };
    loc: [number, number];
    percent: [number, number];
    id: string;
    link: string;
    layer: string;
    command: boolean;
    mutable: boolean;
    description: string;
    minZoom: number;
    maxZoom: number;
    tooltip: TooltipDisplay;
}



================================================
FILE: types/overlay.d.ts
================================================
import { Length } from "convert/dist/types/units";
import { TooltipDisplay } from ".";

export interface LeafletOverlay {
    leafletInstance: L.Circle;
    layer: string;
    data: SavedOverlayData;
    mutable: boolean;
    id: string;
    marker?: string;
    tooltip?: TooltipDisplay;
}
export interface SavedOverlayData {
    radius: number;
    loc: [number, number];
    color: string;
    layer: string;
    unit: Length;
    desc: string;
    id?: string;
    mutable: boolean;
    tooltip?: TooltipDisplay;
    marker?: string;
}



================================================
FILE: types/saved.d.ts
================================================
/** Settings Interfaces */
import { ShapeProperties } from "src/draw/shape";
import { BlockParameters, SavedMarkerProperties, SavedOverlayData } from ".";

export type TooltipDisplay = "always" | "hover" | "never";

export interface Icon {
    type: string;
    iconName?: string;
    isImage?: boolean;
    imageUrl?: string;
    color?: string;
    alpha?: number;
    layer?: boolean;
    transform?: { size: number; x: number; y: number };
    tags?: string[];
    minZoom?: number;
    maxZoom?: number;
}

export interface MapMarkerData {
    path?: string;
    files: string[];
    lastAccessed: number;
    id: string;
    locked: boolean;
    markers: SavedMarkerProperties[];
    overlays: SavedOverlayData[];
    shapes: ShapeProperties[];
}

export interface ObsidianAppData {
    mapMarkers: MapMarkerData[];
    markerIcons: Icon[];
    defaultMarker: Icon;
    color: string;
    lat: number;
    long: number;
    notePreview: boolean;
    layerMarkers: boolean;
    previousVersion: string;
    version: {
        major: number;
        minor: number;
        patch: number;
    };
    warnedAboutMapMarker: boolean;
    copyOnClick: boolean;
    displayOverlayTooltips: boolean;
    displayMarkerTooltips: TooltipDisplay;
    configDirectory: string;
    mapViewParameters: BlockParameters;
    mapViewEnabled: boolean;
    enableDraw: boolean;
    defaultUnitType: "metric" | "imperial";
    defaultTile: string;
    defaultTileSubdomains: string;
    defaultTileDark: string;
    defaultAttribution: string;
}



================================================
FILE: types/view.d.ts
================================================
import { ItemView, MarkdownRenderChild, WorkspaceLeaf } from "obsidian";

import type ObsidianLeaflet from "src/main";
import { BaseMapType } from "./map";

export class LeafletMapView extends ItemView {
    map: BaseMapType;
    mapEl: HTMLDivElement;
    innerContentEl: HTMLDivElement;
    context: MarkdownRenderChild;
    constructor(leaf: WorkspaceLeaf, plugin: ObsidianLeaflet);
    onOpen(): Promise<void>;
    update(): void;
    getDisplayText(): string;
    getViewType(): string;
    onResize(): void;
}



================================================
FILE: .github/workflows/release-please.yml
================================================
on:
    workflow_dispatch:

    push:
        branches:
            - "main"
env:
    PLUGIN_NAME: obsidian-leaflet

permissions:
    contents: write
    pull-requests: write

name: release-please

jobs:
    release-please:
        runs-on: ubuntu-latest
        outputs:
            release_created: ${{ steps.release.outputs.release_created }}
            upload_url: ${{ steps.release.outputs.upload_url }}
            tag_name: ${{ steps.release.outputs.tag_name }}
        steps:
            - uses: google-github-actions/release-please-action@v3
              id: release
              with:
                  command: manifest

    upload-build:
        runs-on: ubuntu-latest
        needs: release-please
        if: ${{ needs.release-please.outputs.release_created }}
        env:
            upload_url: ${{ needs.release-please.outputs.upload_url }}
            tag_name: ${{ needs.release-please.outputs.tag_name }}
        steps:
            - uses: actions/checkout@v2
            - name: Use Node.js
              uses: actions/setup-node@v1
              with:
                  node-version: "18.x" # You might need to adjust this value to your own version
            - name: Build
              id: build
              run: |
                  npm install
                  npm run build --if-present
                  mkdir ${{ env.PLUGIN_NAME }}
                  cp main.js manifest.json styles.css ${{ env.PLUGIN_NAME }}
                  zip -r ${{ env.PLUGIN_NAME }}.zip ${{ env.PLUGIN_NAME }}
            - name: Upload zip file
              id: upload-zip
              uses: actions/upload-release-asset@v1
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              with:
                  upload_url: ${{ env.upload_url }}
                  asset_path: ./${{ env.PLUGIN_NAME }}.zip
                  asset_name: ${{ env.PLUGIN_NAME }}-${{ env.tag_name }}.zip
                  asset_content_type: application/zip
            - name: Upload main.js
              id: upload-main
              uses: actions/upload-release-asset@v1
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              with:
                  upload_url: ${{ env.upload_url }}
                  asset_path: ./main.js
                  asset_name: main.js
                  asset_content_type: text/javascript
            - name: Upload manifest.json
              id: upload-manifest
              uses: actions/upload-release-asset@v1
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              with:
                  upload_url: ${{ env.upload_url }}
                  asset_path: ./manifest.json
                  asset_name: manifest.json
                  asset_content_type: application/json
            - name: Upload styles.css
              id: upload-css
              uses: actions/upload-release-asset@v1
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              with:
                  upload_url: ${{ env.upload_url }}
                  asset_path: ./styles.css
                  asset_name: styles.css
                  asset_content_type: text/css

    notify:
        needs: upload-build
        uses: javalent/workflows/.github/workflows/notify.yml@main
        secrets: inherit
        with:
            name: Obsidian Leaflet
            repo: obsidian-leaflet
            
    publish:
        needs: release-please
        if: ${{ needs.release-please.outputs.release_created }}
        uses: javalent/workflows/.github/workflows/publish.yml@main
        secrets: inherit

    upgrade-overload:
        needs: publish
        uses: javalent/obsidian-overload/.github/workflows/upgrade.yml@main
        secrets: inherit
        with:
            module: obsidian-leaflet


